/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["@jsiqle/core"] = factory();
	else
		root["@jsiqle/core"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NameError\": () => (/* binding */ NameError),\n/* harmony export */   \"ValidationError\": () => (/* binding */ ValidationError),\n/* harmony export */   \"DuplicationError\": () => (/* binding */ DuplicationError),\n/* harmony export */   \"DefaultValueError\": () => (/* binding */ DefaultValueError),\n/* harmony export */   \"ExperimentalAPIUsageError\": () => (/* binding */ ExperimentalAPIUsageError)\n/* harmony export */ });\nclass NameError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NameError';\n  }\n\n}\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n\n}\nclass DuplicationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'DuplicationError';\n  }\n\n}\nclass DefaultValueError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'DefaultValueError';\n  }\n\n}\nclass ExperimentalAPIUsageError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ExperimentalAPIUsageError';\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/errors.js?");

/***/ }),

/***/ "./src/field.js":
/*!**********************!*\
  !*** ./src/field.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Field\": () => (/* binding */ Field)\n/* harmony export */ });\n// import symbols from 'src/symbols';\n// import { ValidationError } from 'src/errors';\n// import { Validator } from 'src/validator';\n// import { capitalize } from 'src/utils';\n// import { isUndefined, isOptional, isEnum, standardTypes } from 'src/types';\n// const { $defaultValue, $validators } = symbols;\nclass Field {\n  static typeChecks = {\n    boolean: value => typeof value === 'boolean',\n    number: value => typeof value === 'number',\n    string: value => typeof value === 'string',\n    date: value => value instanceof Date\n  };\n  static types = [...Object.keys(Field.typeChecks), ...Object.keys(Field.typeChecks).map(key => key + 'Array'), 'enum'];\n\n  static create({\n    name,\n    type,\n    defaultValue = null,\n    notNull = false,\n    ...options\n  }) {\n    if (!Field.types.includes(type)) throw new TypeError(`Field ${name} has an invalid type ${type}.`);\n    if (notNull && defaultValue === null) throw new TypeError(`Non-nullable field ${name} has a default value of null.`); // Specific type flags\n\n    const isArrayType = type.endsWith('Array');\n    const isDateType = type.startsWith('date');\n    const isNumberType = type.startsWith('number');\n    const isStringType = type.startsWith('string');\n    const isEnum = type === 'enum';\n    const valueType = isArrayType ? type.replace(/Array$/, '') : type; // Uniqueness validation\n\n    const isUniqueValidated = options.unique;\n    const uniqueValues = new Set(); // Variables for validators\n\n    const arrayValidators = [];\n    const typeValidators = []; // Error strings\n\n    const typePhrase = isArrayType ? 'Elements of field ' : 'Field ';\n    const nullableErrorString = !notNull ? ' or null' : ''; // Array validators parsing\n\n    if (isArrayType) {\n      const {\n        minSize,\n        maxSize,\n        uniqueValues\n      } = options; // Check for truthiness, as 0 is the same as not being present\n\n      if (minSize) arrayValidators.push(value => {\n        if (value.length < minSize) throw new Error(`Field ${name} must have at least ${minSize} elements.`);\n      });\n      if (maxSize !== undefined) arrayValidators.push(value => {\n        if (value.length > maxSize) throw new Error(`Field ${name} must have at most ${maxSize} elements.`);\n      });\n      if (uniqueValues) arrayValidators.push(value => {\n        const unique = new Set(value);\n        if (unique.size !== value.length) throw new Error(`Field ${name} must have unique elements.`);\n      });\n    } // Type validators parsing\n\n\n    if (isDateType || isNumberType) {\n      const {\n        min,\n        max\n      } = options;\n      if (min !== undefined) typeValidators.push(value => {\n        if (value < min) throw new Error(`${typePhrase}${name} must be at least ${min}.`);\n      });\n      if (max !== undefined) typeValidators.push(value => {\n        if (value > max) throw new Error(`${typePhrase}${name} must be at most ${max}.`);\n      });\n    }\n\n    if (isNumberType) {\n      const {\n        integer\n      } = options;\n      if (integer) typeValidators.push(value => {\n        if (value % 1 !== 0) throw new Error(`${typePhrase}${name} must be an integer.`);\n      });\n    }\n\n    if (isStringType) {\n      const {\n        minLength,\n        maxLength,\n        regex\n      } = options; // Check for truthiness, as 0 is the same as not being present\n\n      if (minLength) typeValidators.push(value => {\n        if (value.length < minLength) throw new Error(`${typePhrase}${name} must be at least ${minLength} characters.`);\n      });\n      if (maxLength !== undefined) typeValidators.push(value => {\n        if (value.length > maxLength) throw new Error(`${typePhrase}${name} must be at most ${maxLength} characters.`);\n      });\n      if (regex) typeValidators.push(value => {\n        if (!regex.test(value)) throw new Error(`${typePhrase}${name} must match ${regex}.`);\n      });\n    } // Default value\n\n\n    const createDefaultValue = () => {\n      if (defaultValue === null) return null;\n\n      if (isArrayType) {\n        return isDateType ? defaultValue.map(date => new Date(date)) : [...defaultValue];\n      } else {\n        return isDateType ? new Date(defaultValue) : defaultValue;\n      }\n    }; // Validation\n\n\n    const typeCheck = value => {\n      if (!notNull && value === null) return true;else if (isEnum && !options.values.includes(value)) {\n        throw new Error(`Field ${name} value is invalid.`);\n      } else if (isArrayType) {\n        if (!Array.isArray(value)) throw new Error(`Field ${name} must be an array${nullableErrorString}.`);\n        if (value.some(item => !Field.typeChecks[valueType](item))) throw new Error(`Field ${name} must contain only ${type}s.`);\n        arrayValidators.forEach(validator => validator(value));\n        typeValidators.forEach(validator => {\n          value.forEach(item => validator(item));\n        });\n      } else {\n        if (!Field.typeChecks[valueType](value)) throw new Error(`Field ${name} must be a ${type}${nullableErrorString}.`);\n        typeValidators.forEach(validator => validator(value));\n      }\n      return true;\n    }; // TODO: This needs to be better fleshed out to make sense\n    // Right now it's only a placeholder\n    // Unique value operations\n\n\n    const operateOnUniqueValues = (operation, {\n      value,\n      previous\n    }) => {\n      if (!isUniqueValidated) return;\n\n      if (operation === 'delete') {\n        if (previous !== undefined && previous !== null) uniqueValues.delete(previous);\n      } else if (operation === 'add') {\n        if (value !== undefined && value !== null) if (!uniqueValues.has(value)) uniqueValues.add(value);else throw new Error(`Field ${name} value is not unique.`);\n      } else if (operation === 'update') {\n        if (previous !== undefined && previous !== null) uniqueValues.delete(previous);\n        if (value !== undefined && value !== null) if (!uniqueValues.has(value)) uniqueValues.add(value);else throw new Error(`Field ${name} value is not unique.`);\n      }\n    }; // Value creation\n\n\n    const create = value => {\n      let newValue;\n      if (value === null) newValue = null;else if (typeof value === 'undefined') newValue = createDefaultValue();else if (isArrayType && isDateType) newValue = value.map(date => new Date(date));else if (isArrayType) newValue = [...value];else if (isDateType) newValue = new Date(value);else newValue = value;\n      typeCheck(newValue);\n      return newValue;\n    }; // Field object\n\n\n    return {\n      get name() {\n        return name;\n      },\n\n      create,\n      typeCheck,\n      createDefaultValue,\n      operateOnUniqueValues\n    };\n  }\n\n} // class Field {\n//   #name;\n//   #defaultValue;\n//   #type;\n//   #validators;\n//   constructor({ name, type, defaultValue = null, validators = {} }) {\n//     this.#name = name;\n//     this.#type = Field.#validateType(type);\n//     this.#defaultValue = Field.#validateDefaultValue(defaultValue, this.#type);\n//     this.#validators = new Map();\n//     Object.entries(validators).forEach(([validatorName, validator]) => {\n//       this.addValidator(validatorName, validator);\n//     });\n//   }\n//   addValidator(validatorName, validator) {\n//     this.#validators.set(\n//       ...Field.#parseFieldValidator(this.#name, validatorName, validator)\n//     );\n//   }\n//   get name() {\n//     return this.#name;\n//   }\n//   typeCheck(value) {\n//     return this.#type(value);\n//   }\n//   // Protected (package internal-use only)\n//   get [$defaultValue]() {\n//     return this.#defaultValue;\n//   }\n//   get [$validators]() {\n//     return this.#validators;\n//   }\n//   // Private\n//   static #validateType(type) {\n//     if (typeof type !== 'function')\n//       throw new TypeError('Field type must be a function.');\n//     return isOptional(type);\n//   }\n//   static #validateDefaultValue(defaultValue, type) {\n//     if (isUndefined(defaultValue)) return null;\n//     if (!type(defaultValue))\n//       throw new ValidationError('Default value must be valid.');\n//     return defaultValue;\n//   }\n//   static #parseFieldValidator(fieldName, validatorName, validator) {\n//     if (Validator[validatorName] !== undefined)\n//       return [\n//         `${fieldName}${capitalize(validatorName)}`,\n//         Validator[validatorName](fieldName, validator),\n//       ];\n//     if (typeof validator !== 'function')\n//       throw new TypeError(`Validator ${validatorName} is not defined.`);\n//     return [\n//       `${fieldName}${capitalize(validatorName)}`,\n//       Validator.custom(fieldName, validator),\n//     ];\n//   }\n// }\n// // Create convenience static methods on the Field class\n// Object.entries(standardTypes).forEach(([typeName, standardType]) => {\n//   const { type } = standardType;\n//   Field[typeName] = options => {\n//     if (typeof options === 'string') return new Field({ name: options, type });\n//     return new Field({ ...options, type });\n//   };\n// });\n// // Enum is special, handle it separately\n// Field.enum = ({ name, values }) => new Field({ name, type: isEnum(...values) });\n\n\n\n\n//# sourceURL=webpack://@jsiqle/core/./src/field.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema */ \"./src/schema.js\");\n // This is the public API, be extra careful not to add anything internal here.\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);\n\n//# sourceURL=webpack://@jsiqle/core/./src/index.js?");

/***/ }),

/***/ "./src/model.js":
/*!**********************!*\
  !*** ./src/model.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Model\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema */ \"./src/schema.js\");\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./field */ \"./src/field.js\");\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./record */ \"./src/record/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ \"./src/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n\n\n\n\n\nconst {\n  $fields,\n  $properties,\n  $cachedProperties,\n  $methods,\n  $scopes,\n  $relationships,\n  $validators,\n  $recordHandler,\n  $addScope,\n  $addRelationshipAsField,\n  $addRelationshipAsProperty,\n  $getField,\n  $getProperty,\n  $removeScope,\n  $instances,\n  $handleExperimentalAPIMessage\n} = _symbols__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\nconst allStandardTypes = [...Object.keys(_types__WEBPACK_IMPORTED_MODULE_5__.standardTypes), 'enum'];\nclass Model {\n  #records;\n  #recordHandler;\n  #fields;\n  #properties;\n  #methods;\n  #relationships;\n  #validators;\n  #cachedProperties;\n  static #instances = new Map();\n\n  constructor({\n    name,\n    fields = {},\n    properties = {},\n    methods = {},\n    scopes = {},\n    validators = {}\n  } = {}) {\n    this.name = name;\n    if (Model.#instances.has(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__.DuplicationError(`A model named ${name} already exists.`); // Create the record storage and handler\n\n    this.#records = new _record__WEBPACK_IMPORTED_MODULE_2__.RecordSet();\n    this.#recordHandler = new _record__WEBPACK_IMPORTED_MODULE_2__.RecordHandler(this); // Initialize private fields\n\n    this.#fields = new Map();\n    this.#properties = new Map();\n    this.#methods = new Map();\n    this.#relationships = new Map();\n    this.#validators = new Map();\n    this.#cachedProperties = new Set(); // Add fields, checking for duplicates and invalids\n\n    Object.entries(fields).forEach(([fieldName, field]) => {\n      if (typeof field === 'object') this.addField({\n        name: fieldName,\n        ...field\n      });else this.addField({\n        name: fieldName,\n        type: field\n      });\n    }); // Add properties, checking for duplicates and invalids\n\n    Object.entries(properties).forEach(([propertyName, property]) => {\n      if (typeof property === 'object') this.addProperty({\n        name: propertyName,\n        ...property\n      });else this.addProperty({\n        name: propertyName,\n        body: property\n      });\n    }); // Add methods, checking for duplicates and invalids\n\n    Object.entries(methods).forEach(([methodName, method]) => {\n      this.addMethod(methodName, method);\n    }); // Add scopes, checking for duplicates and invalids\n\n    Object.entries(scopes).forEach(([scopeName, scope]) => {\n      this.addScope(scopeName, ...Model.#parseScope(scope));\n    }); // Add validators, checking for duplicates and invalids\n\n    Object.entries(validators).forEach(([validatorName, validator]) => {\n      this.addValidator(validatorName, validator);\n    }); // Add the model to the instances map\n\n    Model.#instances.set(this.name, this);\n  }\n\n  addField(fieldOptions) {\n    const {\n      type,\n      name\n    } = fieldOptions;\n    if (typeof type !== 'string') throw new TypeError(`Field ${type} is not an string or a function.`);\n    const field = _field__WEBPACK_IMPORTED_MODULE_1__.Field.create(fieldOptions);\n    this.#fields.set(name, field);\n    return field;\n  }\n\n  addProperty({\n    name,\n    body,\n    cache = false\n  }) {\n    if (typeof body !== 'function') throw new TypeError(`Property ${name} is not a function.`);\n    this.#properties.set(name, body);\n    if (cache) this.#cachedProperties.add(name);\n  }\n\n  addMethod(name, method) {\n    if (typeof method !== 'function') throw new TypeError(`Method ${name} is not a function.`);\n    this.#methods.set(name, method);\n  }\n\n  addScope(name, scope, sortFn) {\n    const scopeName = (0,_utils__WEBPACK_IMPORTED_MODULE_6__.validateName)(name);\n    this.#records[$addScope](scopeName, scope, sortFn);\n  }\n\n  removeScope(name) {\n    if (!Model.#validateContains(this.name, 'Scope', name, this.#records[$scopes])) return false;\n    this.#records[$removeScope](name);\n    return true;\n  }\n\n  addValidator(name, validator) {\n    if (typeof validator !== 'function') throw new TypeError(`Validator ${name} is not a function.`);\n    if (this.#validators.has(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__.DuplicationError(`Validator ${name} already exists.`);\n    this.#validators.set(name, validator);\n  }\n\n  removeValidator(name) {\n    if (!Model.#validateContains(this.name, 'Validator', name, this.#validators)) return false;\n    this.#validators.delete(name);\n    return true;\n  } // TODO: V2 Enhancements\n  // Connect all record events to an event emitter\n\n\n  createRecord(record) {\n    const [newRecordId, newRecord] = this.#recordHandler.createRecord(record);\n    this.#records.set(newRecordId, newRecord);\n    return newRecord;\n  }\n\n  removeRecord(recordId) {\n    if (!this.#records.has(recordId)) {\n      console.warn(`Record ${recordId} does not exist.`);\n      return false;\n    }\n\n    this.#records.delete(recordId);\n    return true;\n  }\n\n  updateRecord(recordId, record) {\n    if (typeof record !== 'object') throw new TypeError('Record data must be an object.');\n    if (!this.#records.has(recordId)) throw new ReferenceError(`Record ${recordId} does not exist.`);\n    const oldRecord = this.#records.get(recordId);\n    Object.entries(record).forEach(([fieldName, fieldValue]) => {\n      oldRecord[fieldName] = fieldValue;\n    });\n    return oldRecord;\n  }\n\n  get records() {\n    return this.#records;\n  } // Protected (package internal-use only)\n\n\n  static get [$instances]() {\n    return Model.#instances;\n  }\n\n  get [$recordHandler]() {\n    return this.#recordHandler;\n  }\n\n  get [$fields]() {\n    return this.#fields;\n  }\n\n  get [$properties]() {\n    return this.#properties;\n  } // TODO: V2 Enhancements\n  // Add a method to the model, so that it's possible to reset caches for all\n  // records. This removes some uncertainty and allows for recalculation without\n  // hacks. Also update the docs to reflect this.\n\n\n  get [$cachedProperties]() {\n    return this.#cachedProperties;\n  }\n\n  get [$methods]() {\n    return this.#methods;\n  }\n\n  get [$relationships]() {\n    return this.#relationships;\n  }\n\n  get [$validators]() {\n    return this.#validators;\n  }\n\n  [$addRelationshipAsField](relationship) {\n    const {\n      name,\n      fieldName,\n      field\n    } = relationship[$getField]();\n    const relationshipName = `${name}.${fieldName}`;\n    if (['id', ...this.#fields.keys(), ...this.#properties.keys(), ...this.#methods.keys()].includes(fieldName)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NameError(`Relationship field ${fieldName} is already in use.`);\n    if (this.#relationships.has(relationshipName)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NameError(`Relationship ${relationshipName} is already in use.`);\n    this.#fields.set(fieldName, field);\n    this.#relationships.set(relationshipName, relationship);\n  }\n\n  [$addRelationshipAsProperty](relationship) {\n    const {\n      name,\n      propertyName,\n      property\n    } = relationship[$getProperty]();\n    const relationshipName = `${name}.${propertyName}`;\n    if (['id', ...this.#fields.keys(), ...this.#properties.keys(), ...this.#methods.keys()].includes(propertyName)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NameError(`Relationship property ${propertyName} is already in use.`);\n    if (this.#relationships.has(relationshipName)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NameError(`Relationship ${name} is already in use.`);\n    this.#properties.set(propertyName, property);\n    this.#relationships.set(relationshipName, relationship);\n  } // Private\n\n\n  static #parseScope(scope) {\n    if (typeof scope === 'function') return [scope];\n\n    if (typeof scope === 'object') {\n      const {\n        matcher,\n        sorter\n      } = scope;\n      if (typeof matcher !== 'function') throw new TypeError(`The provided matcher for the scope is not a function.`);\n      if (sorter && typeof sorter !== 'function') throw new TypeError(`The provided sorter for the scope is not a function.`);\n      return [matcher, sorter];\n    }\n\n    throw new TypeError(`The provided scope is not a function or valid object.`);\n  }\n\n  static #validateContains(modelName, objectType, objectName, objects) {\n    if (!objects.has(objectName)) {\n      console.warn(`Model ${modelName} does not contain a ${objectType.toLowerCase()} named ${objectName}.`);\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/model.js?");

/***/ }),

/***/ "./src/record/fragment.js":
/*!********************************!*\
  !*** ./src/record/fragment.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RecordFragment)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\nconst {\n  $recordTag\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nclass RecordFragment extends Array {\n  #tag;\n\n  constructor(values, tag) {\n    super();\n    values.forEach(value => {\n      this.push(value);\n    });\n    this.#tag = tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordTag]() {\n    return this.#tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$recordTag];\n  }\n\n  toObject() {\n    return [...this];\n  }\n\n  toJSON() {\n    return this.toObject();\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/fragment.js?");

/***/ }),

/***/ "./src/record/group.js":
/*!*****************************!*\
  !*** ./src/record/group.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RecordGroup)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set */ \"./src/record/set.js\");\n\n\nconst {\n  $groupTag\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nclass RecordGroup extends _set__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  #groupName;\n\n  constructor({\n    iterable = [],\n    copyScopesFrom = null,\n    groupName = ''\n  } = {}) {\n    super({\n      iterable,\n      copyScopesFrom\n    });\n    this.#groupName = groupName;\n  }\n  /* istanbul ignore next */\n\n\n  get [$groupTag]() {\n    return this.#groupName;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$groupTag];\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/group.js?");

/***/ }),

/***/ "./src/record/handler.js":
/*!*******************************!*\
  !*** ./src/record/handler.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./record */ \"./src/record/record.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types */ \"./src/types.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\n\n\n\n\nconst {\n  $fields,\n  $defaultValue,\n  $properties,\n  $cachedProperties,\n  $methods,\n  $relationships,\n  $validators,\n  $recordValue,\n  $wrappedRecordValue,\n  $recordModel,\n  $recordTag,\n  $isRecord,\n  $get\n} = _symbols__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n\nclass RecordHandler {\n  #model;\n\n  constructor(model) {\n    this.#model = model;\n  }\n\n  get model() {\n    return this.#model;\n  }\n\n  createRecord(recordData) {\n    if (!recordData) throw new TypeError('Record data cannot be empty.');\n    if (typeof recordData !== 'object') throw new TypeError('Record data must be an object.');\n    const modelName = this.#getModelName(); // Validate record id\n\n    const newRecordId = RecordHandler.#validateNewRecordId(modelName, recordData.id, this.#model.records); // Clone record data\n\n    const clonedRecord = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.deepClone)(recordData);\n    const newRecord = new _record__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      id: newRecordId\n    }, this); // Set fields and skip validation\n\n    this.#getFieldNames().forEach(field => {\n      this.set(newRecord, field, clonedRecord[field], newRecord, true);\n    }); // Validate record just once\n\n    this.#getValidators().forEach((validator, validatorName) => {\n      if (!validator(newRecord, this.#model.records)) throw new RangeError(`${modelName} record with id ${newRecordId} failed validation for ${validatorName}.`);\n    });\n    return [newRecordId, newRecord];\n  }\n  /*  ======  Trap definitions  ======  */\n\n\n  get(record, property) {\n    // Check relationships first to avoid matching them as fields\n    if (this.#hasRelationshipField(property)) return this.#getRelationship(record, property); // Id or field, return as-is\n\n    if (this.#isRecordId(property) || this.#hasField(property)) return this.#getFieldValue(record, property); // Property, get and call, this also matches relationship reverses (properties)\n\n    if (this.#hasProperty(property)) return this.#getProperty(record, property); // Method, get and call\n\n    if (this.#hasMethod(property)) return this.#getMethod(record, property); // Serialize method, call and return\n\n    if (this.#isCallToSerialize(property)) return RecordHandler.#recordToObject(record, this.#model, this); // Call toString method, return key value\n\n    if (this.#isCallToString(property)) return () => this.getRecordId(record); // Known symbol, handle as required\n\n    if (this.#isKnownSymbol(property)) return this.#getKnownSymbol(record, property); // Unknown property, return undefined\n\n    return undefined;\n  }\n\n  set(record, property, value, receiver, skipValidation) {\n    // Receiver is the same as record but never used (API compatibility)\n    const recordValue = record[$recordValue];\n    const recordId = this.getRecordId(record);\n    const otherRecords = this.#model.records.except(recordId); // Throw an error when trying to set a property, also catches\n    // relationship reverses, safeguarding against issues there.\n\n    if (this.#hasProperty(property)) throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set property ${property}.`); // Throw an error when trying to set a method.\n\n    if (this.#hasMethod(property)) throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set method ${property}.`); // Validate and set field, warn if field is not defined\n\n    /* istanbul ignore else*/\n\n    if (this.#hasField(property)) {\n      const field = this.#getField(property);\n      RecordHandler.#setRecordField(this.#model.name, record, field, value, this.#hasRelationshipField(property)); // Never skip individual field validation\n      // field[$validators].forEach((validator, validatorName) => {\n      //   if (\n      //     ![null, undefined].includes(recordValue[property]) &&\n      //     !validator(recordValue, otherRecords)\n      //   )\n      //     throw new RangeError(\n      //       `${this.#getModelName()} record with id ${recordId} failed validation for ${validatorName}.`\n      //     );\n      // });\n    } // Perform model validations\n    // The last argument, `skipValidation`, is used to skip validation\n    // and should only ever be set to `true` by the by the handler itself.\n\n\n    if (!skipValidation) {\n      this.#getValidators().forEach((validator, validatorName) => {\n        if (!validator(recordValue, otherRecords)) throw new RangeError(`${this.#getModelName()} record with id ${recordId} failed validation for ${validatorName}.`);\n      });\n    }\n\n    return true;\n  } // Private methods\n\n\n  static #setRecordField(modelName, record, field, value, isRelationship) {\n    // Set the default value if the field is null or undefined\n    const recordValue = !isRelationship && (0,_types__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(value) ? field.createDefaultValue() : value;\n    if (!isRelationship && !field.typeCheck(recordValue)) // Throw an error if the field value is invalid\n      throw new TypeError(`${modelName} record has invalid value for field ${field.name}.`); // We check for $wrappedRecordValue to ensure the record is wrapped in a\n    // handler (i.e. initialized) and not a plain object (i.e. initializing).\n\n    if (record[$wrappedRecordValue]) record[$cachedProperties].clear();\n    record[$recordValue][field.name] = recordValue;\n  }\n\n  static #recordToObject(record, model) {\n    const recordValue = record[$recordValue];\n    const fields = model[$fields];\n    const object = {\n      id: recordValue.id\n    };\n    fields.forEach(field => {\n      const value = recordValue[field.name];\n      if (value !== undefined) object[field.name] = recordValue[field.name];\n    });\n    return () => object;\n  }\n\n  static #validateNewRecordId = (modelName, id, records) => {\n    let newRecordId = id;\n    if (!(0,_types__WEBPACK_IMPORTED_MODULE_2__.recordId)(newRecordId)) throw new TypeError(`${modelName} record has invalid id.`);\n    if (records.has(newRecordId)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.DuplicationError(`${modelName} record with id ${newRecordId} already exists.`);\n    return newRecordId;\n  };\n  /*  ======  Utility methods  ======  */\n\n  #getModelName() {\n    return this.#model.name;\n  }\n\n  #getFieldNames() {\n    return [...this.#model[$fields].keys()];\n  }\n\n  #getValidators() {\n    return this.#model[$validators];\n  }\n\n  #isRecordId(property) {\n    return property === 'id';\n  }\n\n  getRecordId(record) {\n    return record[$recordValue].id;\n  }\n\n  #hasField(property) {\n    return this.#model[$fields].has(property);\n  }\n\n  #getField(property) {\n    return this.#model[$fields].get(property);\n  }\n\n  #getFieldValue(record, property) {\n    return record[$recordValue][property];\n  }\n\n  #hasProperty(property) {\n    return this.#model[$properties].has(property);\n  }\n\n  #getProperty(record, property) {\n    if (this.#model[$cachedProperties].has(property)) {\n      if (record[$cachedProperties] && record[$cachedProperties].has(property)) return record[$cachedProperties].get(property);\n      const value = this.#model[$properties].get(property)(record[$wrappedRecordValue]);\n      record[$cachedProperties].set(property, value);\n      return value;\n    }\n\n    return this.#model[$properties].get(property)(record[$wrappedRecordValue]);\n  }\n\n  #hasMethod(method) {\n    return this.#model[$methods].has(method);\n  }\n\n  #getMethod(record, method) {\n    const methodFn = this.#model[$methods].get(method);\n    return (...args) => methodFn(record[$wrappedRecordValue], ...args);\n  }\n\n  #hasRelationshipField(property) {\n    // A relationship field exists if a field with the same name exists and\n    // a relationship exists named `${property}.${property}`. This is due to\n    // relationships being stored as a `.`-delimited tuple of the relationship\n    // name and the field/property name. In the case of the field name, it's the\n    // same as the actual relationship name.\n    if (!this.#hasField(property)) return false;\n    return this.#model[$relationships].has(`${property}.${property}`);\n  }\n\n  #getRelationship(record, property) {\n    // Get the relationship from the field only. The field name matches that of\n    // the relationship, so the relationship key is ${property}.${property}`.\n    return this.#model[$relationships].get(`${property}.${property}`)[$get](this.#getModelName(), property, record[$recordValue]);\n  }\n\n  #isCallToSerialize(property) {\n    return property === 'toObject' || property === 'toJSON';\n  }\n\n  #isCallToString(property) {\n    return property === 'toString';\n  }\n\n  #isKnownSymbol(property) {\n    return [$recordModel, $recordTag, $recordValue, $isRecord].includes(property);\n  }\n\n  #getKnownSymbol(record, property) {\n    if (property === $isRecord) return true;\n    return record[property];\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecordHandler);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/handler.js?");

/***/ }),

/***/ "./src/record/index.js":
/*!*****************************!*\
  !*** ./src/record/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Record\": () => (/* reexport safe */ _record__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"PartialRecord\": () => (/* reexport safe */ _partial__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"RecordFragment\": () => (/* reexport safe */ _fragment__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"RecordGroup\": () => (/* reexport safe */ _group__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"RecordHandler\": () => (/* reexport safe */ _handler__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"RecordSet\": () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./record */ \"./src/record/record.js\");\n/* harmony import */ var _partial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./partial */ \"./src/record/partial.js\");\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragment */ \"./src/record/fragment.js\");\n/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./group */ \"./src/record/group.js\");\n/* harmony import */ var _handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handler */ \"./src/record/handler.js\");\n/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./set */ \"./src/record/set.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/index.js?");

/***/ }),

/***/ "./src/record/partial.js":
/*!*******************************!*\
  !*** ./src/record/partial.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PartialRecord)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\nconst {\n  $recordTag\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nclass PartialRecord {\n  #tag;\n\n  constructor(value, tag) {\n    Object.keys(value).forEach(key => {\n      this[key] = value[key];\n    });\n    this.#tag = tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordTag]() {\n    return this.#tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$recordTag];\n  }\n\n  toObject() {\n    return { ...this\n    };\n  }\n\n  toJSON() {\n    return this.toObject();\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/partial.js?");

/***/ }),

/***/ "./src/record/record.js":
/*!******************************!*\
  !*** ./src/record/record.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\nconst {\n  $recordValue,\n  $wrappedRecordValue,\n  $recordHandler,\n  $recordModel,\n  $recordTag,\n  $cachedProperties\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\nclass Record {\n  #recordValue;\n  #recordHandler;\n  #proxiedRecord;\n  #cachedProperties;\n\n  constructor(value, handler) {\n    this.#recordValue = value;\n    this.#recordHandler = handler;\n    this.#cachedProperties = new Map();\n    this.#proxiedRecord = new Proxy(this, this.#recordHandler);\n    return this.#proxiedRecord;\n  }\n\n  get [$cachedProperties]() {\n    return this.#cachedProperties;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordHandler]() {\n    return this.#recordHandler;\n  }\n\n  get [$recordValue]() {\n    return this.#recordValue;\n  } // This is used to get the record wrapped in the handler proxy. It's useful\n  // for property calls in records, so that they can access relationships and\n  // other properties via the handler proxy.\n\n  /* istanbul ignore next */\n\n\n  get [$wrappedRecordValue]() {\n    return this.#proxiedRecord;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordModel]() {\n    return this.#recordHandler.model;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordTag]() {\n    const model = this[$recordModel];\n    return `${model.name}#${this[$recordValue].id}`;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$recordTag];\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Record);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/record.js?");

/***/ }),

/***/ "./src/record/set.js":
/*!***************************!*\
  !*** ./src/record/set.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\n/* harmony import */ var _partial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./partial */ \"./src/record/partial.js\");\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragment */ \"./src/record/fragment.js\");\n/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./group */ \"./src/record/group.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\nconst {\n  $recordModel,\n  $recordTag,\n  $scopes,\n  $addScope,\n  $removeScope,\n  $isRecord\n} = _symbols__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n/**\n * An extension of the native Map object. Provides the same API, along with\n * additional methods similar to the Array prototype.\n */\n\nclass RecordSet extends Map {\n  #frozen;\n  #scopes; // TODO: V2 enhancements\n  // Add some way to pass the handler to the record set to prevent adding new\n  // values to the record set. Generally speaking calling `.set()` on a record\n  // set should probably be disabled.\n\n  constructor({\n    iterable = [],\n    copyScopesFrom = null\n  } = {}) {\n    super();\n\n    for (const [id, value] of iterable) this.set(id, value);\n\n    this.#scopes = new Map();\n    if (copyScopesFrom) this.#copyScopes(copyScopesFrom);\n    this.#frozen = false;\n  }\n  /**\n   * Freezes a record set, preventing further modification.\n   * @returns {RecordSet} The record set itself.\n   */\n\n\n  freeze() {\n    this.#frozen = true;\n    return this;\n  }\n  /**\n   *\n   * @param {*} id The id of the element to add to the record set.\n   * @param {*} value The value of the element to add to the record set.\n   * @returns {RecordSet} The record set itself.\n   */\n\n\n  set(id, value) {\n    // TODO: V2 Enhancements\n    // Ensure this is only ever called internally (maybe symbolize it?)\n    // Schema[$handleExperimentalAPIMessage](\n    //   'Calling RecordSet.prototype.set() is discouraged as it may cause unexpected behavior. This method may be removed in a future version of the library.'\n    // );\n    if (this.#frozen) throw new TypeError('Cannot modify a frozen RecordSet.');\n    super.set(id, value);\n    return this;\n  }\n  /**\n   * @param {*} id The id of the element to remove from the record set.\n   * @returns {boolean} True if the element was removed, false otherwise.\n   */\n\n\n  delete(id) {\n    if (this.#frozen) throw new TypeError('Cannot modify a frozen RecordSet.');\n    return super.delete(id);\n  }\n  /**\n   * Removes all elements from the record set.\n   */\n\n\n  clear() {\n    if (this.#frozen) throw new TypeError('Cannot modify a frozen RecordSet.');\n    super.clear();\n  }\n  /**\n   * Creates an object populated with the results of calling a provided function\n   * on every element in the calling record set.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Object} An object with each id mapped to the result of the\n   * callback function on the corresponding element.\n   */\n\n\n  map(callbackFn) {\n    return [...this.entries()].reduce((newMap, [id, value]) => {\n      newMap[id] = callbackFn(value, id, this);\n      return newMap;\n    }, {});\n  }\n  /**\n   * Creates an array of values by running each element of the record set\n   * through the provided transformation function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Array} An array with each element being the result of the\n   * callback function on the corresponding element.\n   */\n\n\n  flatMap(callbackFn) {\n    return [...this.entries()].map(([id, value]) => {\n      return callbackFn(value, id, this);\n    });\n  }\n  /**\n   * Executes a user-supplied “reducer” callback function on each element of the\n   * record set, passing in the return value from the calculation on the preceding\n   * element. The final result of running the reducer across all elements of the\n   * record set is a single value.\n   * @param {Function} callbackFn A “reducer” function that takes four arguments:\n   * - `accumulator`: The value returned from the previous iteration of the\n   * reducer.\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @param {*} initialValue The initial value of the accumulator.\n   * @returns {*} The value that results from running the “reducer” callback\n   * function to completion over the entire record set.\n   */\n\n\n  reduce(callbackFn, initialValue) {\n    return [...this.entries()].reduce((acc, [id, value]) => {\n      return callbackFn(acc, value, id, this);\n    }, initialValue);\n  }\n  /**\n   * Creates a new record set with all elements that pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that pass the test.\n   */\n\n\n  filter(callbackFn) {\n    return [...this.entries()].reduce((newMap, [id, value]) => {\n      if (callbackFn(value, id, this)) newMap.set(id, value);\n      return newMap;\n    }, new RecordSet({\n      copyScopesFrom: this\n    })).freeze();\n  }\n  /**\n   * Creates an array with all elements that pass the test implemente by the\n   * provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Array} An array with all elements that pass the test.\n   */\n\n\n  flatFilter(callbackFn) {\n    return [...this.entries()].reduce((arr, [id, value]) => {\n      if (callbackFn(value, id, this)) arr.push(value);\n      return arr;\n    }, []);\n  }\n  /**\n   * Returns the value of the first element in the record set that satisfies\n   * the provided testing function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Record} The value of the first element in the record set that\n   * satisfies the provided testing function or `undefined`.\n   */\n\n\n  find(callbackFn) {\n    for (const [id, value] of this.entries()) {\n      if (callbackFn(value, id, this)) return value;\n    }\n\n    return undefined;\n  }\n  /**\n   * Returns the id of the first element in the record set that satisfies the\n   * provided testing function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {*} The id of the first element in the record set that satisfies\n   * the provided testing function or `undefined`.\n   */\n\n\n  findId(callbackFn) {\n    for (const [id, value] of this.entries()) {\n      if (callbackFn(value, id, this)) return id;\n    }\n\n    return undefined;\n  }\n  /**\n   * Returns all elements in the record set whose ids match the provided\n   * ids/ids in order of appearance in the given ids.\n   * @param  {...any} ids A list of ids to exclude from the record set.\n   * @returns {RecordSet} A new record set with all elements whose ids\n   * match the provided id/ids.\n   */\n\n\n  only(...ids) {\n    return new RecordSet({\n      iterable: ids.reduce((itr, id) => {\n        if (this.has(id)) itr.push([id, this.get(id)]);\n        return itr;\n      }, []),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns all elements in the record set whose ids do not match the provided\n   * id/ids.\n   * @param  {...any} ids A list of ids to exclude from the record set.\n   * @returns {RecordSet} A new record set with all elements whose ids do not\n   * match the provided id/ids.\n   */\n\n\n  except(...ids) {\n    return new RecordSet({\n      iterable: [...this.entries()].filter(([id]) => {\n        return !ids.includes(id);\n      }),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Sorts the elements of the record set and returns a new sorted record set.\n   * @param {Function} callbackFn Function that defined the sort order. The\n   * callback is called with the following arguments:\n   * - `firstValue`: The value of the first element for comparison.\n   * - `secondValue`: The value of the second element for comparison.\n   * - `firstId`: The id of the first element for comparison.\n   * - `secondId`: The id of the second element for comparison.\n   * @returns {RecordSet} A new record set with the elements of the original\n   * record set sorted.\n   */\n\n\n  sort(comparatorFn) {\n    const sorted = [...this.entries()].sort(([id1, value1], [id2, value2]) => comparatorFn(value1, value2, id1, id2));\n    return new RecordSet({\n      iterable: sorted,\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Tests whether all elements in the record set pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Boolean} `true` if all elements in the record set pass the test,\n   * `false` otherwise.\n   */\n\n\n  every(callbackFn) {\n    if (this.size === 0) return true;\n    return [...this.entries()].every(([id, value]) => callbackFn(value, id, this));\n  }\n  /**\n   * Tests whether some elements in the record set pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Boolean} `true` if any elements in the record set pass the test,\n   * `false` otherwise.\n   */\n\n\n  some(callbackFn) {\n    if (this.size === 0) return false;\n    return [...this.entries()].some(([id, value]) => callbackFn(value, id, this));\n  }\n  /**\n   * Returns a new record set with all elements mapped to the keys specified.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {RecordSet} A new record set with all elements mapped to the\n   * keys specified.\n   */\n\n\n  select(...keys) {\n    return new RecordSet({\n      iterable: [...this.entries()].map(([key, value]) => {\n        const obj = {};\n        keys.forEach(key => obj[key] = value[key]);\n        return [key, new _partial__WEBPACK_IMPORTED_MODULE_2__[\"default\"](obj, value[$recordTag])];\n      }),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns an array of objects with all elements mapped to the keys specified.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {Array} An array with all elements mapped to the keys specified.\n   */\n\n\n  flatSelect(...keys) {\n    return [...this.values()].map(value => keys.reduce((obj, key) => ({ ...obj,\n      [key]: value[key]\n    }), {}));\n  }\n  /**\n   * Returns a new record set with records mapped to fragments containing\n   * only the keys specified.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {RecordSet} A new record set with all elements mapped to\n   * fragments containing only the keys specified.\n   */\n\n\n  pluck(...keys) {\n    return new RecordSet({\n      iterable: [...this.entries()].map(([key, value]) => {\n        const values = keys.map(key => value[key]);\n        return [key, new _fragment__WEBPACK_IMPORTED_MODULE_3__[\"default\"](values, value[$recordTag])];\n      }),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns an array with records mapped to arrays containing only the\n   * keys specified. If only one key is specified, the array contains the\n   * value of each element instead.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {RecordSet} A new record set with all elements mapped to\n   * fragments containing only the keys specified.\n   */\n\n\n  flatPluck(...keys) {\n    const isSingleKey = keys.length === 1;\n\n    if (isSingleKey) {\n      const key = keys[0];\n      if (key === 'id') return [...this.ids()];\n      return [...this.values()].map(value => value[key]);\n    }\n\n    return [...this.values()].map(value => keys.map(key => value[key]));\n  }\n  /**\n   * Group the elements of the record set by the specified key.\n   * @param {*} key A key to group the elements by.\n   * @returns {RecordSet} A new record set containing groups of elements.\n   */\n\n\n  groupBy(key) {\n    const res = new RecordSet({\n      copyScopesFrom: this,\n      iterable: []\n    });\n\n    for (const [recordKey, value] of this.entries()) {\n      let keyValue = value[key];\n\n      if (keyValue !== undefined && keyValue !== null && keyValue[$isRecord]) {\n        keyValue = value[key].id;\n      }\n\n      if (!res.has(keyValue)) {\n        res.set(keyValue, new _group__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n          copyScopesFrom: this,\n          iterable: [],\n          groupName: keyValue\n        }));\n      }\n\n      res.get(keyValue).set(recordKey, value);\n    }\n\n    for (const value of res.values()) {\n      value.freeze();\n    }\n\n    return res.freeze();\n  }\n  /**\n   * Duplicates the current record set.\n   * @returns {RecordSet} A new record set with the same elements as the original.\n   */\n\n\n  duplicate() {\n    return new RecordSet({\n      iterable: [...this.entries()],\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Merges one or more record sets into the current record set.\n   * @param {...any} recordSets One or more record sets to merge.\n   * @returns {RecordSet} A new record set with the elements of the original\n   * record sets merged into it.\n   */\n\n\n  merge(...recordSets) {\n    const res = new Map([...this.entries()]);\n\n    for (const recordSet of recordSets) {\n      for (const [id, value] of recordSet.entries()) {\n        if (res.has(id)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.DuplicationError(`Id ${id} already exists in the record set.`);\n        res.set(id, value);\n      }\n    }\n\n    return new RecordSet({\n      iterable: [...res.entries()],\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Merges one or more records into the current record set.\n   * @param  {...any} records One or more records to merge.\n   * @returns {RecordSet} A new record set with the elements of the original\n   * record set and any given records merged into it.\n   */\n\n\n  append(...records) {\n    const res = new RecordSet({\n      iterable: [...this.entries()],\n      copyScopesFrom: this\n    });\n\n    for (const record of records) {\n      res.set(record.id, record);\n    }\n\n    return res.freeze();\n  }\n  /**\n   * Creates a new record set with all elements that pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that pass the test.\n   */\n\n\n  where(callbackFn) {\n    return this.filter(callbackFn);\n  }\n  /**\n   * Creates a new record set with all elements that fail the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that fail the test.\n   */\n\n\n  whereNot(callbackFn) {\n    return this.filter((value, id, map) => !callbackFn(value, id, map));\n  }\n  /**\n   * Iterates over the record set's ids in array batches of the specified size.\n   * @param {Number} batchSize The size of each batch.\n   * @returns {Iterator} An iterator that yields array batches of the specified size.\n   */\n\n\n  *flatBatchIdsIterator(batchSize) {\n    let batch = [];\n\n    for (const id of this.ids()) {\n      batch.push(id);\n\n      if (batch.length === batchSize) {\n        yield batch;\n        batch = [];\n      }\n    }\n\n    if (batch.length) yield batch;\n  }\n  /**\n   * Iterates over the record set in array batches of the specified size.\n   * @param {Number} batchSize The size of each batch.\n   * @returns {Iterator} An iterator that yields array batches of the specified size.\n   */\n\n\n  *flatBatchIterator(batchSize) {\n    let batch = [];\n\n    for (const [, value] of this) {\n      batch.push(value);\n\n      if (batch.length === batchSize) {\n        yield batch;\n        batch = [];\n      }\n    }\n\n    if (batch.length) yield batch;\n  }\n  /**\n   * Iterates over the record set in batches of the specified size.\n   * @param {Number} batchSize The size of each batch.\n   * @returns {Iterator} An iterator that yields batches of the specified size.\n   */\n\n\n  *batchIterator(batchSize) {\n    let batch = [];\n\n    for (const [id, value] of this) {\n      batch.push([id, value]);\n\n      if (batch.length === batchSize) {\n        yield new RecordSet({\n          copyScopesFrom: this,\n          iterable: batch\n        }).freeze();\n        batch = [];\n      }\n    }\n\n    if (batch.length) yield new RecordSet({\n      copyScopesFrom: this,\n      iterable: batch\n    }).freeze();\n  }\n  /**\n   * Returns a new record set with only the first n elements.\n   * @param {Number} n The number of elements to keep.\n   * @returns {RecordSet} A new record set with only the first n elements.\n   */\n\n\n  limit(n) {\n    let records = [];\n\n    for (const [id, value] of this) {\n      records.push([id, value]);\n      if (records.length === n) break;\n    }\n\n    return new RecordSet({\n      iterable: records,\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns a new record set with the first n elements removed.\n   * @param {Number} n The number of elements to remove.\n   * @returns {RecordSet} A new record set with the first n elements removed.\n   */\n\n\n  offset(n) {\n    let counter = 0;\n    let records = [];\n\n    for (const [id, value] of this) {\n      if (counter < n) counter++;else records.push([id, value]);\n    }\n\n    return new RecordSet({\n      iterable: records,\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns a new record set with the elements contained in a portion of the\n   * record set.\n   * @param {Number} start The index of the first element to include.\n   * @param {Number} end The index after the last element to include.\n   * @returns {RecordSet} A new record set with the elements contained in a\n   * portion of the record set.\n   */\n\n\n  slice(start, end) {\n    return new RecordSet({\n      iterable: [...this.entries()].slice(start, end),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns the first element in the record set.\n   */\n\n\n  get first() {\n    for (const [, value] of this) return value;\n\n    return undefined;\n  }\n  /**\n   * Returns the last element in the record set.\n   */\n\n\n  get last() {\n    if (this.size === 0) return undefined;\n    return [...this.entries()].pop()[1];\n  }\n  /**\n   * Returns the number of elements in the record set.\n   */\n\n\n  get count() {\n    return this.size;\n  }\n  /**\n   * Returns the number of elements in the record set.\n   */\n\n\n  get length() {\n    return this.size;\n  }\n  /**\n   * Returns a new Iterator object that contains the ids for each element in the\n   * record set.\n   */\n\n\n  get ids() {\n    return this.keys;\n  }\n  /**\n   * Returns an array of the records contained in the record set.\n   * @returns {Array<Record>} An array of the values contained in the record set.\n   */\n\n\n  toArray() {\n    return [...this.values()];\n  }\n  /**\n   * Returns an array of objects representing the records in the record set.\n   * @returns {Array<Object>} An array of objects representing the records in\n   * the record set.\n   */\n\n\n  toFlatArray() {\n    return [...this.values()].map(value => value instanceof _group__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? value.toFlatArray() : value.toObject());\n  }\n  /**\n   * Returns an object representing the record set.\n   * @returns {Object} An object representing the record set.\n   */\n\n\n  toObject() {\n    return [...this.entries()].reduce((obj, [id, value]) => {\n      obj[id] = value;\n      return obj;\n    }, {});\n  }\n  /**\n   * Returns a flattened object of objects representing the records in the\n   * record set.\n   * @returns {Object} An object representing the records in the record set.\n   */\n\n\n  toFlatObject() {\n    return [...this.entries()].reduce((obj, [id, value]) => {\n      obj[id] = value instanceof _group__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? value.toFlatArray() : value.toObject();\n      return obj;\n    }, {});\n  }\n  /**\n   * Returns the object repeseentation of the record set.\n   * Used by JSON.stringify().\n   * @returns {Object} The object representation of the record set.\n   */\n\n\n  toJSON() {\n    return this.toObject();\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    const records = [...this.values()];\n\n    try {\n      const firstModel = records[0][$recordModel].name;\n      if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.allEqualBy)(records, value => value[$recordModel].name === firstModel)) return firstModel;\n    } catch (e) {\n      return '';\n    }\n\n    return '';\n  }\n  /* istanbul ignore next */\n\n\n  static get [Symbol.species]() {\n    return Map;\n  } // Protected (package internal-use only)\n\n\n  [$addScope](name, scope, sortFn) {\n    RecordSet.#validateProperty('Scope', name, scope, this.#scopes);\n    if (sortFn) RecordSet.#validateFunction('Scope comparator', name, sortFn);\n    if (this[name] || Object.getOwnPropertyNames(RecordSet.prototype).includes(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.NameError(`Scope name ${name} is already in use.`);\n    this.#scopes.set(name, [scope, sortFn]);\n    Object.defineProperty(this, name, {\n      configurable: true,\n      // Allows deletion in $removeScope\n      get: () => {\n        return this.#scopedWhere(name);\n      }\n    });\n  }\n\n  [$removeScope](name) {\n    this.#scopes.delete(RecordSet.#validateContains('Scope', name, this.#scopes));\n    delete this[name];\n  }\n\n  get [$scopes]() {\n    return this.#scopes;\n  } // Private\n\n\n  #copyScopes(otherRecordSet) {\n    otherRecordSet[$scopes].forEach((scope, name) => {\n      // No need to verify that the scope is valid, it must be verified by the\n      // other record set already.\n      this.#scopes.set(name, scope);\n      Object.defineProperty(this, name, {\n        configurable: true,\n        // Allows deletion in $removeScope\n        get: () => {\n          return this.#scopedWhere(name);\n        }\n      });\n    });\n  }\n\n  #scopedWhere(scopeName) {\n    const [matcherFn, comparatorFn] = this.#scopes.get(scopeName);\n    let matches = [];\n\n    for (const [id, value] of this.entries()) if (matcherFn(value, id, this)) matches.push([id, value]);\n\n    if (comparatorFn) matches.sort(([id1, value1], [id2, value2]) => comparatorFn(value1, value2, id1, id2));\n    return new RecordSet({\n      iterable: matches,\n      copyScopesFrom: this\n    }).freeze();\n  }\n\n  static #validateProperty(callbackType, callbackName, callback, callbacks) {\n    if (typeof callback !== 'function') throw new TypeError(`${callbackType} ${callbackName} is not a function.`);\n    if (callbacks.has(callbackName)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.DuplicationError(`${callbackType} ${callbackName} already exists.`);\n    return callback;\n  }\n\n  static #validateFunction(callbackType, callbackName, callback) {\n    if (typeof callback !== 'function') throw new TypeError(`${callbackType} ${callbackName} is not a function.`);\n    return callback;\n  }\n\n  static #validateContains(objectType, objectName, objects) {\n    if (!objects.has(objectName)) throw new ReferenceError(`${objectType} ${objectName} does not exist.`);\n    return objectName;\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecordSet);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/set.js?");

/***/ }),

/***/ "./src/relationship.js":
/*!*****************************!*\
  !*** ./src/relationship.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Relationship\": () => (/* binding */ Relationship)\n/* harmony export */ });\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./field */ \"./src/field.js\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema */ \"./src/schema.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ \"./src/types.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\n\nconst {\n  $recordValue,\n  $fields,\n  $getField,\n  $getProperty,\n  $get,\n  $defaultValue,\n  $instances,\n  $handleExperimentalAPIMessage\n} = _symbols__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\nconst relationshipEnum = {\n  oneToOne: 'oneToOne',\n  oneToMany: 'oneToMany',\n  manyToOne: 'manyToOne',\n  manyToMany: 'manyToMany'\n};\nclass Relationship {\n  #type;\n  #from;\n  #to;\n  #name; // relationship field name in the from table\n\n  #reverseName; // relationship field name in the to table\n\n  #relationshipField; // relationship field in the from model\n\n  #relationshipProperty; // relationship property in the to model\n  // TODO: V2 enhancements\n  // After the API for relationships is stable-ish, figure out a way to add\n  // cascade.\n\n  constructor({\n    from,\n    to,\n    type\n  } = {}) {\n    _schema__WEBPACK_IMPORTED_MODULE_1__.Schema[$handleExperimentalAPIMessage]('Relationships are experimental in the current version. There is neither validation of existence in foreign tables nor guarantee that associations work. Please use with caution.');\n    this.#type = Relationship.#validateType(type);\n    const [fromModel, fromName, toModel, toName] = Relationship.#parseModelsAndNames(from, to, type);\n    this.#from = fromModel;\n    this.#to = toModel;\n    this.#name = fromName;\n    this.#reverseName = toName;\n    if (this.#to === this.#from && Relationship.#isSymmetric(this.#type) && this.#name === this.#reverseName) throw new RangeError('Relationship cannot be symmetric if the from and to models are the same and no name is provided for either one.');\n    this.#relationshipField = Relationship.#createField(this.#name, this.#type);\n\n    this.#relationshipProperty = record => {\n      return this.#getAssociatedRecordsReverse(record);\n    };\n  } // Protected (package internal-use only)\n\n\n  [$getField]() {\n    return {\n      name: this.#name,\n      type: this.#type,\n      fieldName: this.#name,\n      field: this.#relationshipField\n    };\n  }\n\n  [$getProperty]() {\n    return {\n      name: this.#name,\n      type: this.#type,\n      propertyName: this.#reverseName,\n      property: this.#relationshipProperty\n    };\n  }\n\n  [$get](modelName, property, record) {\n    // When from model is specified, apply the relationship as-is\n    if (modelName === this.#from.name && property === this.#name) {\n      return this.#getAssociatedRecords(record);\n    } // When to model is specified, reverse the relationship before applying it\n\n    /* istanbul ignore next */\n\n\n    if (modelName === this.#to.name && property === this.#reverseName) {\n      console.warn('Relationship getter called by the receiver model. This might indicate an issue with the library and should be reported.');\n      return this.#getAssociatedRecordsReverse(record);\n    }\n  } // Private\n\n\n  #getAssociatedRecords(record) {\n    // Use a regular get for toOne relationships for performance\n    if (Relationship.#isToOne(this.#type)) {\n      const associationValue = record[this.#name];\n      return this.#to.records.get(associationValue);\n    } // Use a where query for toMany relationships, safeguard against empty value\n\n\n    const associationValues = record[this.#name] || [];\n    return this.#to.records.only(...associationValues);\n  }\n\n  #getAssociatedRecordsReverse(record) {\n    const associationValue = record.id;\n    const matcher = Relationship.#isToOne(this.#type) ? associatedRecord => associatedRecord[$recordValue][this.#name] === associationValue : associatedRecord => {\n      const associatedRecordValue = associatedRecord[$recordValue][this.#name];\n      if ([undefined, null].includes(associatedRecordValue)) return false;\n      return associatedRecord[$recordValue][this.#name].includes(associationValue);\n    }; // Use a regular get for fromOne relationships for performance\n\n    if (Relationship.#isFromOne(this.#type)) {\n      return this.#from.records.find(matcher);\n    } // Use a where query for fromMany relationships, safeguard against empty value\n\n\n    return this.#from.records.where(matcher);\n  }\n\n  static #isToOne(type) {\n    return [relationshipEnum.oneToOne, relationshipEnum.manyToOne].includes(type);\n  }\n\n  static #isToMany(type) {\n    return [relationshipEnum.oneToMany, relationshipEnum.manyToMany].includes(type);\n  }\n\n  static #isFromOne(type) {\n    return [relationshipEnum.oneToMany, relationshipEnum.oneToOne].includes(type);\n  }\n\n  static #isFromMany(type) {\n    return [relationshipEnum.manyToOne, relationshipEnum.manyToMany].includes(type);\n  }\n\n  static #isSymmetric(type) {\n    return [relationshipEnum.oneToOne, relationshipEnum.manyToMany].includes(type);\n  }\n\n  static #createField(name, relationshipType) {\n    // TODO: V2 enhancements\n    // Potentially add a check if the other model contains the ids(s)?\n    const isSingleSource = Relationship.#isFromOne(relationshipType);\n    const isMultiple = Relationship.#isToMany(relationshipType);\n    const type = isMultiple ? 'stringArray' : 'string'; // TODO: V2 enhancements\n    // Add a custom validator for symmetric relationships to ensure that a\n    // record does not reference itself in the relationship, creating a loop.\n\n    const validators = {\n      minLength: 1\n    }; // oneToOne means that for each record in the to model, there is at most\n    // one record in the from model. No overlap.\n\n    if (isSingleSource && !isMultiple) validators.unique = true; // toMany relationships are not allowed to have duplicate values.\n\n    if (isMultiple) validators.uniqueValues = true;\n    const relationshipField = _field__WEBPACK_IMPORTED_MODULE_0__.Field.create({\n      name,\n      type,\n      defaultValue: isMultiple ? [] : null,\n      ...validators\n    }); // Override the default value to throw an error\n\n    Object.defineProperty(relationshipField, $defaultValue, {\n      get() {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.DefaultValueError('Relationship field does not have a default value.');\n      }\n\n    });\n    return relationshipField;\n  }\n\n  static #validateType(relationshipType) {\n    if (!Object.values(relationshipEnum).includes(relationshipType)) throw new TypeError(`Invalid relationship type: ${relationshipType}.`);\n    return relationshipType;\n  }\n\n  static #validateModel(modelData) {\n    const modelName = typeof modelData === 'string' ? modelData : modelData.model;\n    if (!_model__WEBPACK_IMPORTED_MODULE_3__.Model[$instances].has(modelName)) throw new ReferenceError(`Model ${modelName} does not exist.`);\n    return _model__WEBPACK_IMPORTED_MODULE_3__.Model[$instances].get(modelName);\n  }\n\n  static #createName(type, to) {\n    if (Relationship.#isToOne(type)) return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(to);\n    if (Relationship.#isToMany(type)) return `${(0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(to)}Set`;\n  }\n\n  static #createReverseName = (type, from) => {\n    if (Relationship.#isFromOne(type)) return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(from);\n    if (Relationship.#isFromMany(type)) return `${(0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(from)}Set`;\n  };\n\n  static #validateModelParams(modelData) {\n    const model = Relationship.#validateModel(modelData);\n    const name = typeof modelData === 'string' ? null : (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(modelData.name);\n    if (name !== null && model[$fields].has(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.DuplicationError(`Field ${name} already exists in ${model.name}.`);\n    return [model, name];\n  }\n\n  static #parseModelsAndNames(from, to, type) {\n    let fromModel, fromName, toModel, toName;\n    [fromModel, fromName] = Relationship.#validateModelParams(from);\n    [toModel, toName] = Relationship.#validateModelParams(to);\n    if (fromName === null) fromName = Relationship.#createName(type, toModel.name);\n    if (toName === null) toName = Relationship.#createReverseName(type, fromModel.name);\n    return [fromModel, fromName, toModel, toName];\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/relationship.js?");

/***/ }),

/***/ "./src/schema.js":
/*!***********************!*\
  !*** ./src/schema.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Schema\": () => (/* binding */ Schema),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _relationship__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./relationship */ \"./src/relationship.js\");\n/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serializer */ \"./src/serializer.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\nconst {\n  $addRelationshipAsField,\n  $addRelationshipAsProperty,\n  $handleExperimentalAPIMessage,\n  $instances\n} = _symbols__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n/**\n * A Schema is a collection of models.\n * @param {Object} options Schema options\n * @param {String} options.name The name of the schema\n * @param {Array<Object>} options.models An object containing initial models for\n * the schema.\n */\n\nclass Schema {\n  #name;\n  #models;\n  #serializers;\n  static defaultConfig = {\n    experimentalAPIMessages: 'warn'\n  };\n  static config = { ...Schema.defaultConfig\n  };\n  static #schemas = new Map();\n\n  constructor({\n    name,\n    models = [],\n    relationships = [],\n    serializers = [],\n    config = {}\n  } = {}) {\n    this.#name = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(name);\n    this.#models = new Map();\n    this.#serializers = new Map();\n    Schema.#parseConfig(config);\n    Schema.#schemas.set(this.#name, this);\n    const lazyPropertyMap = {};\n    models.forEach(model => {\n      const {\n        lazyProperties,\n        ...modelData\n      } = Schema.#separateModelProperties(model);\n      if (Object.keys(lazyProperties).length) lazyPropertyMap[modelData.name] = lazyProperties; // Perform name validation for fields, properties and methods here\n      // to evaluate lazy properties early on and exit if something is wrong.\n\n      const {\n        fields = {},\n        properties = {},\n        methods = {}\n      } = modelData;\n      const names = [...Object.keys(fields), ...Object.keys(properties), ...Object.keys(methods)];\n      const uniqueNames = new Set(names);\n      if (uniqueNames.size !== names.length) throw new Error(`Model ${modelData.name} has duplicate field, property or method names.`);\n      names.forEach(name => (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(name));\n      this.createModel(modelData);\n    });\n    relationships.forEach(relationship => this.createRelationship(relationship));\n    serializers.forEach(serializer => this.createSerializer(serializer)); // V2 enhancements: Replace with the getter for `#schemaObject` entirely\n    // Lazy properties, models and serializers require initial set up as they\n    // depend on other models or serializers.\n\n    const schemaData = {\n      models: Object.fromEntries([...this.#models.entries()]),\n      serializers: Object.fromEntries([...this.#serializers.entries()])\n    };\n    models.forEach(model => {\n      const modelRecord = this.getModel(model.name);\n      const lazyProperties = lazyPropertyMap[model.name] || {};\n      if (lazyProperties) Object.entries(lazyProperties).forEach(([propertyName, {\n        body: propertyInitializer,\n        cache\n      }]) => {\n        modelRecord.addProperty({\n          name: propertyName,\n          body: value => propertyInitializer(value, this.#schemaObject),\n          cache\n        });\n      }); // TODO: V2 enhancements\n      // Replace `schemaData` with the getter for `#schemaObject`\n\n      if (model.lazyMethods) Object.entries(model.lazyMethods).forEach(([methodName, methodInitializer]) => {\n        modelRecord.addMethod(methodName, methodInitializer(schemaData));\n      });\n    }); // TODO: V2 enhancements\n    // Replace `schemaData` with the getter for `#schemaObject`\n\n    serializers.forEach(serializer => {\n      const serializerRecord = this.getSerializer(serializer.name);\n\n      if (serializer.lazyMethods) {\n        Object.entries(serializer.lazyMethods).forEach(([methodName, methodInitializer]) => {\n          serializerRecord.addMethod(methodName, methodInitializer(schemaData));\n        });\n      }\n    });\n  }\n  /**\n   * Creates a model and adds it to the schema.\n   * @param {Object} modelData Data for the model to be added.\n   * @returns The newly created model.\n   */\n\n\n  createModel(modelData) {\n    const modelName = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(modelData.name);\n    const model = Schema.#parseModel(this.#name, modelData, this.#models);\n    this.#models.set(modelName, model);\n    return model;\n  }\n  /**\n   * Retrieves a model from the schema.\n   * @param {String} name The name of the model to retrieve.\n   * @returns The model or `undefined` if it does not exist.\n   */\n\n\n  getModel(name) {\n    return this.#models.get(name);\n  }\n  /**\n   * Removes a model from the schema.\n   * @param {String} name The name of the model to remove.\n   */\n\n\n  removeModel(name) {\n    if (!this.#models.has(name)) throw new ReferenceError(`Model ${name} does not exist in schema ${this.#name}.`);\n    this.#models.delete(name);\n    _model__WEBPACK_IMPORTED_MODULE_0__.Model[$instances].delete(name); // TODO: V2 enhancements\n    // Figure out a way to add cascade for relationships\n  }\n  /**\n   * EXPERIMENTAL\n   * Creates a relationship between two models and adds it to the schema.\n   * @param {Object} relationshipData Data for the relationship to be added.\n   * @returns The newly created relationship.\n   */\n\n\n  createRelationship(relationshipData) {\n    const relationship = Schema.#applyRelationship(this.#name, relationshipData, this.#models);\n    return relationship;\n  }\n  /**\n   * Creates a serializer and adds it to the schema.\n   * @param {Object} serializerData Data for the serializer to be added.\n   * @returns The newly created serializer.\n   */\n\n\n  createSerializer(serializerData) {\n    const serializerName = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(serializerData.name);\n    const serializer = Schema.#parseSerializer(this.#name, serializerData, this.#serializers);\n    this.#serializers.set(serializerName, serializer);\n    return serializer;\n  }\n  /**\n   * Retrieves a serializer from the schema.\n   * @param {String} name The name of the serializer to retrieve.\n   * @returns The serializer or `undefined` if it does not exist.\n   */\n\n\n  getSerializer(name) {\n    return this.#serializers.get(name);\n  }\n  /**\n   * Gets the schema's name.\n   */\n\n\n  get name() {\n    return this.#name;\n  }\n  /**\n   * Gets all models in the schema.\n   */\n\n\n  get models() {\n    return this.#models;\n  } // TODO: Make users use this instead of the constructor, using a private flag.\n  // Use another private flag to throw if more than one schema is created\n  // (not supported for this release).\n\n  /**\n   * Creates a new schema with the given name and options.\n   * @param {Object} schemaData Data for the schema to be created.\n   * @returns The newly created schema.\n   */\n\n\n  static create(schemaData) {\n    return new Schema(schemaData);\n  } // TODO: V2 enhancements\n  // Check validity of this. Currently it's not mentioned anywhere in the docs.\n\n\n  static get(name) {\n    return Schema.#schemas.get(name);\n  }\n  /**\n   * Retrieves the data specified by the given pathName\n   * @param {String} pathName A '.'-delimited path to the data.\n   * @returns The value at the specified path.\n   */\n\n\n  get(pathName) {\n    const [modelName, recordId, ...rest] = pathName.split('.');\n    const model = this.getModel(modelName);\n    if (!model) throw new ReferenceError(`Model ${modelName} does not exist in schema ${this.#name}.`);\n    if (recordId === undefined) return model;\n    const record = model.records.get(recordId);\n    if (!rest.length) return record;\n    if (!record) throw new ReferenceError(`Record ${recordId} does not exist in model ${modelName}.`);\n    const result = rest.reduce((acc, key) => acc[key], record);\n    return result;\n  } // Protected (package internal-use only)\n\n  /* istanbul ignore next */\n\n\n  static [$handleExperimentalAPIMessage](message) {\n    const {\n      experimentalAPIMessages\n    } = Schema.config;\n\n    if (experimentalAPIMessages === 'warn') {\n      console.warn(message);\n    } else if (experimentalAPIMessages === 'error') {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ExperimentalAPIUsageError(message);\n    }\n  } // Private\n\n\n  get #schemaObject() {\n    return {\n      models: Object.fromEntries([...this.#models.entries()]),\n      serializers: Object.fromEntries([...this.#serializers.entries()])\n    };\n  }\n\n  static #parseModel(schemaName, modelData, models) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateObjectWithUniqueName)({\n      objectType: 'Model',\n      parentType: 'Schema',\n      parentName: schemaName\n    }, modelData, [...models.keys()]);\n    return new _model__WEBPACK_IMPORTED_MODULE_0__.Model(modelData);\n  }\n\n  static #separateModelProperties(modelData) {\n    const {\n      properties: modelProperties = {},\n      ...model\n    } = modelData;\n    const [properties, lazyProperties] = Object.entries(modelProperties).reduce((acc, [propertyName, property]) => {\n      const isObject = typeof property === 'object';\n      const propertyFn = isObject ? property.body : property;\n      const isLazy = propertyFn.length === 2;\n      acc[isLazy ? 1 : 0][propertyName] = {\n        body: propertyFn,\n        cache: isObject ? Boolean(property.cache) : false\n      };\n      return acc;\n    }, [{}, {}]);\n    return { ...model,\n      properties,\n      lazyProperties\n    };\n  }\n\n  static #applyRelationship(schemName, relationshipData, models) {\n    const {\n      from,\n      to,\n      type\n      /* , cascade */\n\n    } = relationshipData;\n    [from, to].forEach(model => {\n      if (!['string', 'object'].includes(typeof model)) throw new TypeError(`Invalid relationship model: ${model}.`);\n    });\n    const fromModelName = typeof from === 'string' ? from : from.model;\n    const toModelName = typeof to === 'string' ? to : to.model;\n    const fromModel = models.get(fromModelName);\n    const toModel = models.get(toModelName);\n    if (!fromModel) throw new ReferenceError(`Model ${fromModelName} not found in schema ${schemName} when attempting to create a relationship.`);\n    if (!toModel) throw new ReferenceError(`Model ${toModelName} not found in schema ${schemName} when attempting to create a relationship.`);\n    const relationship = new _relationship__WEBPACK_IMPORTED_MODULE_1__.Relationship({\n      from,\n      to,\n      type\n    });\n    fromModel[$addRelationshipAsField](relationship);\n    toModel[$addRelationshipAsProperty](relationship);\n    return relationship;\n  }\n\n  static #parseSerializer(schemaName, serializerData, serializers) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateObjectWithUniqueName)({\n      objectType: 'Serializer',\n      parentType: 'Schema',\n      parentName: schemaName\n    }, serializerData, [...serializers.keys()]);\n    return new _serializer__WEBPACK_IMPORTED_MODULE_2__.Serializer(serializerData);\n  }\n\n  static #parseConfig(config = {}) {\n    if (!config) return;\n    ['experimentalAPIMessages'].forEach(key => {\n      if (config[key] !== undefined) {\n        if (['warn', 'error', 'off'].includes(config[key])) Schema.config[key] = config[key];\n      }\n    });\n  } // TODO: V2 enhancements\n  // Add a mechanism here so that plugins can hook up to the schema via the\n  // event API or other stuff. Generally, the Schema is the de facto entrypoint\n  // of the library, so we should make sure that all plugins interface with it.\n  //\n  // We also need a way to modularize and granularize the logging/erroring. A\n  // wrapper would allow us to specify this across.\n\n\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Schema);\n\n//# sourceURL=webpack://@jsiqle/core/./src/schema.js?");

/***/ }),

/***/ "./src/serializer.js":
/*!***************************!*\
  !*** ./src/serializer.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Serializer\": () => (/* binding */ Serializer)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n\nclass Serializer {\n  #name;\n  #attributes;\n  #methods;\n\n  constructor({\n    name,\n    attributes = [],\n    methods = {}\n  }) {\n    this.#name = name;\n    this.#attributes = new Map();\n    this.#methods = new Map();\n    attributes.forEach(attribute => {\n      const [attributeValue, attributeName] = typeof attribute === 'string' ? [attribute, attribute] : attribute;\n      this.#attributes.set(Serializer.#validateAttribute(attributeName, [...this.#attributes.keys()]), attributeValue);\n    });\n    Object.entries(methods).forEach(([methodName, methodBody]) => {\n      this.addMethod(methodName, methodBody);\n    });\n  }\n\n  addMethod(methodName, methodBody) {\n    const method = Serializer.#validateFunction(methodName, methodBody, [...this.#methods.keys()]);\n    this.#methods.set(methodName, method);\n  }\n\n  serialize(object, options) {\n    // TODO: V2 Enhancements\n    // Add a way to bind the serializer to a specific model. Then add a check\n    // here that validates that the passed object is a record of said model.\n    const serialized = {};\n    this.#attributes.forEach((attributeValue, attributeName) => {\n      const value = this.#methods.has(attributeValue) ? this.#methods.get(attributeValue)(object, options) : object[attributeValue];\n      if (value !== undefined) serialized[attributeName] = value;\n    });\n    return serialized;\n  } // ΝΟΤE: This also handles RecordSets (not by design).\n  // The result is an object with each key mapped to a serialized object.\n  // Hidden feature I guess?\n\n\n  serializeArray(objects, options) {\n    return objects.map(object => this.serialize(object, options));\n  }\n\n  serializeRecordSet(objects, options, keyMapFn) {\n    const serialized = {};\n    objects.forEach((value, key) => {\n      const mappedKey = keyMapFn(key, value);\n      if (mappedKey === undefined) return;\n      serialized[mappedKey] = this.serialize(value, options);\n    });\n    return serialized;\n  }\n\n  get name() {\n    return this.#name;\n  } // Private\n\n\n  static #validateAttribute(attributeName, restrictedNames) {\n    if (typeof attributeName !== 'string') throw new TypeError(`Attribute ${attributeName} is not a string.`);\n    if (restrictedNames.includes(attributeName)) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.DuplicationError(`Attribute ${attributeName} already exists.`);\n    return attributeName;\n  }\n\n  static #validateFunction(callbackName, callback, restrictedNames) {\n    if (typeof callback !== 'function') throw new TypeError(`Method ${callbackName} is not a function.`);\n    if (restrictedNames.includes(callbackName)) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.DuplicationError(`Method ${callbackName} already exists.`);\n    return callback;\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/serializer.js?");

/***/ }),

/***/ "./src/symbols.js":
/*!************************!*\
  !*** ./src/symbols.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Symbolizes any number of strings and return an object\n * @param  {...any} str Array of strings to symbolize\n * @returns {object} Object with symbolized strings\n */\nconst symbolizeAll = (...str) => str.reduce((acc, curr) => {\n  acc[`$${curr}`] = Symbol.for(curr);\n  return acc;\n}, {});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (symbolizeAll('fields', 'properties', 'cachedProperties', 'methods', 'scopes', 'relationships', 'relationshipField', 'validators', 'recordModel', 'recordValue', 'wrappedRecordValue', 'recordHandler', 'recordTag', 'defaultValue', 'addScope', 'addRelationshipAsField', 'addRelationshipAsProperty', 'getField', 'getProperty', 'removeScope', 'instances', 'isRecord', 'groupTag', 'get', 'handleExperimentalAPIMessage'));\n\n//# sourceURL=webpack://@jsiqle/core/./src/symbols.js?");

/***/ }),

/***/ "./src/types.js":
/*!**********************!*\
  !*** ./src/types.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isEnum\": () => (/* binding */ isEnum),\n/* harmony export */   \"isUndefined\": () => (/* binding */ isUndefined),\n/* harmony export */   \"isOptional\": () => (/* binding */ isOptional),\n/* harmony export */   \"standardTypes\": () => (/* binding */ standardTypes),\n/* harmony export */   \"recordId\": () => (/* binding */ recordId),\n/* harmony export */   \"recordIdArray\": () => (/* binding */ recordIdArray)\n/* harmony export */ });\nconst isBoolean = val => typeof val === 'boolean';\n\nconst isNumber = val => typeof val === 'number' && val === val;\n\nconst isString = val => typeof val === 'string';\n\nconst isDate = val => val instanceof Date;\n\nconst and = (...types) => val => types.every(type => type(val));\n\nconst or = (...types) => val => types.some(type => type(val));\n\nconst isArrayOf = type => val => Array.isArray(val) && val.every(type);\n\nconst isEnum = (...values) => val => values.includes(val);\n\nconst isNull = val => val === null;\n\nconst isUndefined = val => val === undefined;\nconst isOptional = type => val => or(isNull, type)(val);\nconst standardTypes = {\n  boolean: {\n    type: isBoolean\n  },\n  number: {\n    type: isNumber\n  },\n  string: {\n    type: isString\n  },\n  date: {\n    type: isDate\n  },\n  booleanArray: {\n    type: isArrayOf(isBoolean)\n  },\n  numberArray: {\n    type: isArrayOf(isNumber)\n  },\n  stringArray: {\n    type: isArrayOf(isString)\n  },\n  dateArray: {\n    type: isArrayOf(isDate)\n  }\n}; // Internal types\n\nconst isNonEmptyString = val => val.trim().length !== 0;\n\nconst recordId = and(isString, isNonEmptyString);\nconst recordIdArray = isArrayOf(recordId);\n\n//# sourceURL=webpack://@jsiqle/core/./src/types.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"validateName\": () => (/* binding */ validateName),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"reverseCapitalize\": () => (/* binding */ reverseCapitalize),\n/* harmony export */   \"deepClone\": () => (/* binding */ deepClone),\n/* harmony export */   \"allEqualBy\": () => (/* binding */ allEqualBy),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"validateObjectWithUniqueName\": () => (/* binding */ validateObjectWithUniqueName)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n // Name validation\n// TODO: 'records' can be a bit of a loose gun here.\n\nconst restrictedNames = ['toString', 'toObject', 'toJSON', 'id'];\n/**\n * Validates the name of a field or model.\n * Restrictiorns:\n * - Must be a string\n * - Must be at least 1 character long\n * - Must not start with a number\n * - Must contain only alphanumeric characters, numbers or underscores\n * @param {string} name The name of the field or model to validate.\n * @returns {boolean} Whether the name is valid.\n */\n\nconst isValidName = name => {\n  if (typeof name !== 'string') return [false, 'must be a string'];\n  if (!name) return [false, 'cannot be empty'];\n  if (/^\\d/.test(name)) return [false, 'cannot start with a number'];\n  if (restrictedNames.includes(name)) return [false, 'is reserved'];\n  return [/^\\w+$/.test(name), 'must contain only alphanumeric characters, numbers or underscores'];\n};\n/**\n * Validates the name of a field or model.\n * Restrictiorns:\n * - Must be a string\n * - Must be at least 1 character long\n * - Must not start with a number\n * - Must contain only alphanumeric characters, numbers or underscores\n * @param {string} name The name of the field or model to validate.\n * @throws {NameError} If the name is invalid.\n * @returns {boolean} Whether the name is valid.\n */\n\n\nconst validateName = name => {\n  const [isValid, message] = isValidName(name);\n  if (!isValid) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NameError(`Name \"${name}\" is invalid - ${message}.`);\n  return name;\n}; // General-purpose utilities\n\nconst capitalize = ([first, ...rest]) => first.toUpperCase() + rest.join('');\nconst reverseCapitalize = ([first, ...rest]) => first.toLowerCase() + rest.join('');\nconst deepClone = obj => {\n  if (obj === null) return null;\n  if (obj instanceof Date) return new Date(obj);\n  let clone = Object.assign({}, obj);\n  Object.entries(clone).forEach(([key, value]) => clone[key] = typeof obj[key] === 'object' ? deepClone(value) : value);\n\n  if (Array.isArray(obj)) {\n    clone.length = obj.length;\n    return Array.from(clone);\n  }\n\n  return clone;\n};\nconst allEqualBy = (arr, fn) => {\n  const eql = fn(arr[0]);\n  return arr.every(val => fn(val) === eql);\n};\nconst isObject = obj => obj && typeof obj === 'object';\nconst contains = (collection, item) => collection.includes(item);\nconst validateObjectWithUniqueName = ({\n  objectType,\n  parentType,\n  parentName\n}, obj, collection) => {\n  if (!isObject(obj)) throw new TypeError(`${objectType} ${obj} is not an object.`);\n  if (contains(collection, obj.name)) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.DuplicationError(`${parentType} ${parentName} already has a ${objectType.toLowerCase()} named ${obj.name}.`);\n  return true;\n};\n\n//# sourceURL=webpack://@jsiqle/core/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});