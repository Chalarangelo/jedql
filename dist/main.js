/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["@jsiqle/core"] = factory();
	else
		root["@jsiqle/core"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NameError\": () => (/* binding */ NameError),\n/* harmony export */   \"ValidationError\": () => (/* binding */ ValidationError),\n/* harmony export */   \"DuplicationError\": () => (/* binding */ DuplicationError),\n/* harmony export */   \"DefaultValueError\": () => (/* binding */ DefaultValueError),\n/* harmony export */   \"ExperimentalAPIUsageError\": () => (/* binding */ ExperimentalAPIUsageError)\n/* harmony export */ });\nclass NameError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NameError';\n  }\n\n}\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n\n}\nclass DuplicationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'DuplicationError';\n  }\n\n}\nclass DefaultValueError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'DefaultValueError';\n  }\n\n}\nclass ExperimentalAPIUsageError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ExperimentalAPIUsageError';\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/errors.js?");

/***/ }),

/***/ "./src/field.js":
/*!**********************!*\
  !*** ./src/field.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Field\": () => (/* binding */ Field)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./validator */ \"./src/validator.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"./src/types.js\");\n\n\n\n\n\nconst {\n  $defaultValue,\n  $validators\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\nclass Field {\n  #name;\n  #defaultValue;\n  #required;\n  #type;\n  #validators;\n\n  constructor({\n    name,\n    type,\n    required = false,\n    defaultValue = null,\n    validators = {}\n  }) {\n    this.#name = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.validateName)('Field', name);\n    this.#required = Field.#validateRequired(required);\n    this.#type = Field.#validateType(type, required);\n    this.#defaultValue = Field.#validateDefaultValue(defaultValue, this.#type, this.#required);\n    this.#validators = new Map();\n    Object.entries(validators).forEach(([validatorName, validator]) => {\n      this.addValidator(validatorName, validator);\n    });\n  }\n\n  addValidator(validatorName, validator) {\n    this.#validators.set(...Field.#parseFieldValidator(this.#name, validatorName, validator));\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get required() {\n    return this.#required;\n  }\n\n  typeCheck(value) {\n    return this.#type(value);\n  } // Protected (package internal-use only)\n\n\n  get [$defaultValue]() {\n    return this.#defaultValue;\n  }\n\n  get [$validators]() {\n    return this.#validators;\n  } // Private\n\n\n  static #validateType(type, required) {\n    if (typeof type !== 'function') {\n      throw new TypeError('Field type must be a function.');\n    }\n\n    return required ? type : _types__WEBPACK_IMPORTED_MODULE_4__[\"default\"].optional(type);\n  }\n\n  static #validateRequired(required) {\n    if (typeof required !== 'boolean') {\n      throw new TypeError('Field required must be a boolean.');\n    }\n\n    return required;\n  }\n\n  static #validateDefaultValue(defaultValue, type, required) {\n    if (required && _types__WEBPACK_IMPORTED_MODULE_4__[\"default\"].nil(defaultValue)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ValidationError('Default value cannot be null or undefined.');\n    if (!type(defaultValue)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ValidationError('Default value must be valid.');\n    return defaultValue;\n  }\n\n  static #parseFieldValidator(fieldName, validatorName, validator) {\n    if (_validator__WEBPACK_IMPORTED_MODULE_2__.Validator[validatorName] !== undefined) return [`${fieldName}${(0,_utils__WEBPACK_IMPORTED_MODULE_3__.capitalize)(validatorName)}`, _validator__WEBPACK_IMPORTED_MODULE_2__.Validator[validatorName](fieldName, validator)];\n    if (typeof validator !== 'function') throw new TypeError(`Validator ${validatorName} is not defined.`);\n    return [`${fieldName}${(0,_utils__WEBPACK_IMPORTED_MODULE_3__.capitalize)(validatorName)}`, _validator__WEBPACK_IMPORTED_MODULE_2__.Validator.custom(fieldName, validator)];\n  }\n\n} // Create convenience static methods on the Field class\n\n\nObject.entries(_types__WEBPACK_IMPORTED_MODULE_4__.standardTypes).forEach(([typeName, standardType]) => {\n  const {\n    type,\n    defaultValue: typeDefaultValue\n  } = standardType;\n\n  Field[typeName] = options => {\n    if (typeof options === 'string') return new Field({\n      name: options,\n      type\n    });\n    return new Field({ ...options,\n      type\n    });\n  };\n\n  Field[`${typeName}Required`] = options => {\n    if (typeof options === 'string') return new Field({\n      name: options,\n      type,\n      required: true,\n      defaultValue: typeDefaultValue\n    });\n    const defaultValue = options.defaultValue || typeDefaultValue;\n    return new Field({ ...options,\n      type,\n      required: true,\n      defaultValue\n    });\n  };\n}); // Enum is special, handle it separately\n\nField.enum = ({\n  name,\n  values\n}) => new Field({\n  name,\n  type: _types__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"enum\"](...values)\n});\n\nField.enumRequired = ({\n  name,\n  values,\n  defaultValue = values[0]\n}) => new Field({\n  name,\n  type: _types__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"enum\"](...values),\n  required: true,\n  defaultValue\n}); // Auto-field is special, handle it separately\n\n\nField.auto = options => {\n  const name = typeof options === 'string' ? options : options.name; // Generator function to generate a new value each time\n\n  function* autoGenerator() {\n    let i = 0;\n\n    while (true) yield i++;\n  }\n\n  const generator = autoGenerator();\n  let currentValue = 0; // Create the field\n\n  const autoField = new Field({\n    name,\n    type: value => value === currentValue,\n    required: true,\n    defaultValue: currentValue\n  }); // Override the default value to be the next value in the sequence\n\n  Object.defineProperty(autoField, $defaultValue, {\n    get() {\n      const value = generator.next().value;\n      currentValue = value;\n      return value;\n    }\n\n  });\n  return autoField;\n};\n\n\n\n//# sourceURL=webpack://@jsiqle/core/./src/field.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema */ \"./src/schema.js\");\n // This is the public API, be extra careful not to add anything internal here.\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);\n\n//# sourceURL=webpack://@jsiqle/core/./src/index.js?");

/***/ }),

/***/ "./src/model.js":
/*!**********************!*\
  !*** ./src/model.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Model\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema */ \"./src/schema.js\");\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./field */ \"./src/field.js\");\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./record */ \"./src/record/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types */ \"./src/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n\n\n\n\n\n\nconst {\n  $fields,\n  $defaultValue,\n  $key,\n  $keyType,\n  $properties,\n  $scopes,\n  $relationships,\n  $validators,\n  $recordHandler,\n  $addScope,\n  $addRelationshipAsField,\n  $addRelationshipAsProperty,\n  $getField,\n  $getProperty,\n  $removeScope,\n  $instances,\n  $handleExperimentalAPIMessage\n} = _symbols__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\nconst allStandardTypes = [...Object.keys(_types__WEBPACK_IMPORTED_MODULE_6__.standardTypes), ...Object.keys(_types__WEBPACK_IMPORTED_MODULE_6__.standardTypes).map(type => `${type}Required`), 'enum', 'enumRequired', 'auto'];\nclass Model extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {\n  #records;\n  #recordHandler;\n  #fields;\n  #key;\n  #properties;\n  #relationships;\n  #validators;\n  #updatingField = false;\n  static #instances = new Map();\n\n  constructor({\n    name,\n    fields = [],\n    key = 'id',\n    properties = {},\n    scopes = {},\n    validators = {} // TODO: V2 Enhancements\n    // Adding a hooks parameter would be an interesting idea. There's a blind\n    // spot currently where we can't listen for events on model creation.\n\n  } = {}) {\n    super();\n    this.name = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.validateName)('Model', name);\n    if (Model.#instances.has(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_4__.DuplicationError(`A model named ${name} already exists.`); // Create the record storage and handler\n    // This needs to be initialized before fields to allow for retrofilling\n\n    this.#records = new _record__WEBPACK_IMPORTED_MODULE_3__.RecordSet();\n    this.#recordHandler = new _record__WEBPACK_IMPORTED_MODULE_3__.RecordHandler(this); // Check and create the key field, no need to check for duplicate fields\n\n    this.#key = Model.#parseKey(this.name, key); // Initialize private fields\n\n    this.#fields = new Map();\n    this.#properties = new Map();\n    this.#relationships = new Map();\n    this.#validators = new Map(); // Add fields, checking for duplicates and invalids\n\n    fields.forEach(field => this.addField(field)); // Add properties, checking for duplicates and invalids\n\n    Object.entries(properties).forEach(([propertyName, property]) => {\n      this.addProperty(propertyName, property);\n    }); // Add scopes, checking for duplicates and invalids\n\n    Object.entries(scopes).forEach(([scopeName, scope]) => {\n      this.addScope(scopeName, scope);\n    }); // Add validators, checking for duplicates and invalids\n\n    Object.entries(validators).forEach(([validatorName, validator]) => {\n      this.addValidator(validatorName, validator);\n    }); // Add the model to the instances map\n\n    Model.#instances.set(this.name, this);\n  }\n\n  addField(fieldOptions, retrofill) {\n    if (!this.#updatingField) this.emit('beforeAddField', {\n      field: fieldOptions,\n      model: this\n    });\n    const field = Model.#parseField(this.name, fieldOptions, [...this.#fields.keys(), this.#key.name, ...this.#properties.keys()]);\n    this.#fields.set(fieldOptions.name, field);\n    if (!this.#updatingField) this.emit('fieldAdded', {\n      field,\n      model: this\n    }); // Retrofill records with new fields\n    // TODO: V2 enhancements\n    // This before might be erroneous if the retrofill is non-existent. We could\n    // check for that and skip emitting the event if it's not there.\n\n    this.emit('beforeRetrofillField', {\n      field,\n      retrofill,\n      model: this\n    });\n    Model.#applyFieldRetrofill(field, this.#records, retrofill);\n    this.emit('fieldRetrofilled', {\n      field,\n      retrofill,\n      model: this\n    });\n    if (!this.#updatingField) this.emit('change', {\n      type: 'fieldAdded',\n      field,\n      model: this\n    });\n    return field;\n  }\n\n  removeField(name) {\n    if (!Model.#validateContains(this.name, 'Field', name, this.#fields)) return false;\n    const field = this.#fields.get(name);\n    if (!this.#updatingField) this.emit('beforeRemoveField', {\n      field,\n      model: this\n    });\n    this.#fields.delete(name);\n\n    if (!this.#updatingField) {\n      this.emit('fieldRemoved', {\n        field: {\n          name\n        },\n        model: this\n      });\n      this.emit('change', {\n        type: 'fieldRemoved',\n        field,\n        model: this\n      });\n    }\n\n    return true;\n  }\n\n  updateField(name, field, retrofill) {\n    if (field.name !== name) throw new _errors__WEBPACK_IMPORTED_MODULE_4__.NameError(`Field name ${field.name} does not match ${name}.`);\n    if (!Model.#validateContains(this.name, 'Field', name, this.#fields)) throw new ReferenceError(`Field ${name} does not exist.`);\n    const prevField = this.#fields.get(name); // Ensure that only update events are emitted, not add/remove ones.\n\n    this.#updatingField = true;\n    this.emit('beforeUpdateField', {\n      prevField,\n      field,\n      model: this\n    });\n    this.removeField(name);\n    const newField = this.addField(field, retrofill);\n    this.emit('fieldUpdated', {\n      field: newField,\n      model: this\n    });\n    this.#updatingField = false;\n    this.emit('change', {\n      type: 'fieldUpdated',\n      field: newField,\n      model: this\n    });\n  }\n\n  addProperty(name, property) {\n    this.emit('beforeAddProperty', {\n      property: {\n        name,\n        body: property\n      },\n      model: this\n    });\n    const propertyName = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.validateName)('Property', name);\n    this.#properties.set(propertyName, Model.#validateProperty('Property', name, property, [...this.#fields.keys(), this.#key.name, ...this.#properties.keys()]));\n    this.emit('propertyAdded', {\n      property: {\n        name: propertyName,\n        body: property\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'propertyAdded',\n      property: {\n        name: propertyName,\n        body: property\n      },\n      model: this\n    });\n  }\n\n  removeProperty(name) {\n    if (!Model.#validateContains(this.name, 'Property', name, this.#properties)) return false;\n    const property = this.#properties.get(name);\n    this.emit('beforeRemoveProperty', {\n      property: {\n        name,\n        body: property\n      },\n      model: this\n    });\n    this.#properties.delete(name);\n    this.emit('propertyRemoved', {\n      property: {\n        name\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'propertyRemoved',\n      property: {\n        name,\n        body: property\n      },\n      model: this\n    });\n    return true;\n  }\n\n  addScope(name, scope) {\n    this.emit('beforeAddScope', {\n      scope: {\n        name,\n        body: scope\n      },\n      model: this\n    });\n    const scopeName = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.validateName)('Scope', name);\n    this.#records[$addScope](scopeName, scope);\n    this.emit('scopeAdded', {\n      scope: {\n        name: scopeName,\n        body: scope\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'scopeAdded',\n      scope: {\n        name: scopeName,\n        body: scope\n      },\n      model: this\n    });\n  }\n\n  removeScope(name) {\n    if (!Model.#validateContains(this.name, 'Scope', name, this.#records[$scopes])) return false;\n    const scope = this.#records[$scopes].get(name);\n    this.emit('beforeRemoveScope', {\n      scope: {\n        name,\n        body: scope\n      },\n      model: this\n    });\n    this.#records[$removeScope](name);\n    this.emit('scopeRemoved', {\n      scope: {\n        name\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'scopeRemoved',\n      scope: {\n        name,\n        body: scope\n      },\n      model: this\n    });\n    return true;\n  }\n\n  addValidator(name, validator) {\n    this.emit('beforeAddValidator', {\n      validator: {\n        name,\n        body: validator\n      },\n      model: this\n    }); // Validators are not name-validated by design.\n\n    this.#validators.set(name, Model.#validateProperty('Validator', name, validator, [...this.#validators.keys()]));\n    this.emit('validatorAdded', {\n      validator: {\n        name,\n        body: validator\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'validatorAdded',\n      validator: {\n        name,\n        body: validator\n      },\n      model: this\n    });\n  }\n\n  removeValidator(name) {\n    if (!Model.#validateContains(this.name, 'Validator', name, this.#validators)) return false;\n    const validator = this.#validators.get(name);\n    this.emit('beforeRemoveValidator', {\n      validator: {\n        name,\n        body: validator\n      },\n      model: this\n    });\n    this.#validators.delete(name);\n    this.emit('validatorRemoved', {\n      validator: {\n        name\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'validatorRemoved',\n      validator: {\n        name,\n        body: validator\n      },\n      model: this\n    });\n    return true;\n  } // TODO: V2 Enhancements\n  // If loading records from a storage, the key is already populated. This will\n  // cause problems when validating auto-incrementing key values and could\n  // result in random keys for the same object between runs.\n  //\n  // Record operations do not emit 'change' events by design\n\n\n  createRecord(record) {\n    this.emit('beforeCreateRecord', {\n      record,\n      model: this\n    });\n    const [newRecordKey, newRecord] = this.#recordHandler.createRecord(record);\n    this.#records.set(newRecordKey, newRecord);\n    this.emit('recordCreated', {\n      newRecord,\n      model: this\n    });\n    return newRecord;\n  }\n\n  removeRecord(recordKey) {\n    if (!this.#records.has(recordKey)) {\n      console.warn(`Record ${recordKey} does not exist.`);\n      return false;\n    }\n\n    const record = this.#records.get(recordKey);\n    this.emit('beforeRemoveRecord', {\n      record,\n      model: this\n    });\n    this.#records.delete(recordKey);\n    this.emit('recordRemoved', {\n      record: {\n        [this.#key.name]: recordKey\n      },\n      model: this\n    });\n    return true;\n  }\n\n  updateRecord(recordKey, record) {\n    if (typeof record !== 'object') throw new TypeError('Record data must be an object.');\n    if (!this.#records.has(recordKey)) throw new ReferenceError(`Record ${recordKey} does not exist.`);\n    const oldRecord = this.#records.get(recordKey);\n    this.emit('beforeUpdateRecord', {\n      record: oldRecord,\n      newRecord: {\n        [this.#key.name]: recordKey,\n        ...record\n      },\n      model: this\n    });\n    Object.entries(record).forEach(([fieldName, fieldValue]) => {\n      oldRecord[fieldName] = fieldValue;\n    });\n    this.emit('recordUpdated', {\n      record: oldRecord,\n      model: this\n    });\n    return oldRecord;\n  }\n\n  get records() {\n    return this.#records;\n  } // Protected (package internal-use only)\n\n\n  static get [$instances]() {\n    return Model.#instances;\n  }\n\n  get [$recordHandler]() {\n    return this.#recordHandler;\n  }\n\n  get [$fields]() {\n    return this.#fields;\n  }\n\n  get [$key]() {\n    return this.#key;\n  }\n\n  get [$properties]() {\n    return this.#properties;\n  }\n\n  get [$relationships]() {\n    return this.#relationships;\n  }\n\n  get [$validators]() {\n    return this.#validators;\n  }\n\n  [$addRelationshipAsField](relationship) {\n    const {\n      name,\n      type,\n      fieldName,\n      field\n    } = relationship[$getField]();\n    const relationshipName = `${name}.${fieldName}`;\n    this.emit('beforeAddRelationship', {\n      relationship: {\n        name,\n        type\n      },\n      model: this\n    });\n    if ([...this.#fields.keys(), this.#key.name, ...this.#properties.keys()].includes(fieldName)) throw new _errors__WEBPACK_IMPORTED_MODULE_4__.NameError(`Relationship field ${fieldName} is already in use.`);\n    if (this.#relationships.has(relationshipName)) throw new _errors__WEBPACK_IMPORTED_MODULE_4__.NameError(`Relationship ${relationshipName} is already in use.`);\n    this.#fields.set(fieldName, field);\n    this.#relationships.set(relationshipName, relationship);\n    this.emit('relationshipAdded', {\n      relationship: {\n        name,\n        type\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'relationshipAdded',\n      relationship: {\n        relationship: {\n          name,\n          type\n        },\n        model: this\n      },\n      model: this\n    });\n  }\n\n  [$addRelationshipAsProperty](relationship) {\n    const {\n      name,\n      type,\n      propertyName,\n      property\n    } = relationship[$getProperty]();\n    const relationshipName = `${name}.${propertyName}`;\n    this.emit('beforeAddRelationship', {\n      relationship: {\n        name,\n        type\n      },\n      model: this\n    });\n    if ([...this.#fields.keys(), this.#key.name, ...this.#properties.keys()].includes(propertyName)) throw new _errors__WEBPACK_IMPORTED_MODULE_4__.NameError(`Relationship property ${propertyName} is already in use.`);\n    if (this.#relationships.has(relationshipName)) throw new _errors__WEBPACK_IMPORTED_MODULE_4__.NameError(`Relationship ${name} is already in use.`);\n    this.#properties.set(propertyName, property);\n    this.#relationships.set(relationshipName, relationship);\n    this.emit('relationshipAdded', {\n      relationship: {\n        name,\n        type\n      },\n      model: this\n    });\n    this.emit('change', {\n      type: 'relationshipAdded',\n      relationship: {\n        relationship: {\n          name,\n          type\n        },\n        model: this\n      },\n      model: this\n    });\n  } // Private\n\n\n  static #createKey(options) {\n    let name = 'id';\n    let type = 'string';\n    if (typeof options === 'string') name = options;else if (typeof options === 'object') {\n      // Don't worry about these two being uncovered, they are a safeguard\n      // that should never be reached under normal circumstances.\n      name = options.name || name;\n      type = options.type || type;\n    }\n    let keyField;\n\n    if (type === 'string') {\n      keyField = new _field__WEBPACK_IMPORTED_MODULE_2__.Field({\n        name,\n        type: _types__WEBPACK_IMPORTED_MODULE_6__.key,\n        required: true,\n        defaultValue: '__emptyKey__'\n      }); // Override the default value to throw an error\n\n      Object.defineProperty(keyField, $defaultValue, {\n        /* istanbul ignore next */\n        get() {\n          throw new _errors__WEBPACK_IMPORTED_MODULE_4__.DefaultValueError(`Key field ${name} does not have a default value.`);\n        }\n\n      });\n    } else if (type === 'auto') keyField = _field__WEBPACK_IMPORTED_MODULE_2__.Field.auto(name); // Additional property to get the type from the model\n\n\n    Object.defineProperty(keyField, $keyType, {\n      get() {\n        return type;\n      }\n\n    });\n    return keyField;\n  }\n\n  static #parseKey(modelName, key) {\n    if (typeof key !== 'string' && typeof key !== 'object') throw new TypeError(`${modelName} key ${key} is not a string or object.`);\n    if (typeof key === 'object' && !key.name) throw new TypeError(`${modelName} key ${key} is missing a name.`);\n    if (typeof key === 'object' && !['auto', 'string'].includes(key.type)) throw new TypeError(`${modelName} key ${key} type must be either \"string\" or \"auto\".`);\n\n    const _key = Model.#createKey(key);\n\n    return _key;\n  }\n\n  static #parseField(modelName, field, restrictedNames) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_7__.validateObjectWithUniqueName)({\n      objectType: 'Field',\n      parentType: 'Model',\n      parentName: modelName\n    }, field, restrictedNames);\n    const isStandardType = allStandardTypes.includes(field.type);\n    if (isStandardType) return _field__WEBPACK_IMPORTED_MODULE_2__.Field[field.type](field);else if (typeof field.type === 'function') {\n      _schema__WEBPACK_IMPORTED_MODULE_1__.Schema[$handleExperimentalAPIMessage](`The provided type for ${field.name} is not part of the standard types. Function types are experimental and may go away in a later release.`);\n    }\n    return new _field__WEBPACK_IMPORTED_MODULE_2__.Field(field);\n  }\n\n  static #validateProperty(callbackType, callbackName, callback, restrictedNames) {\n    if (typeof callback !== 'function') throw new TypeError(`${callbackType} ${callbackName} is not a function.`);\n    if (restrictedNames.includes(callbackName)) throw new _errors__WEBPACK_IMPORTED_MODULE_4__.DuplicationError(`${callbackType} ${callbackName} already exists.`);\n    return callback;\n  }\n\n  static #validateContains(modelName, objectType, objectName, objects) {\n    if (!objects.has(objectName)) {\n      console.warn(`Model ${modelName} does not contain a ${objectType.toLowerCase()} named ${objectName}.`);\n      return false;\n    }\n\n    return true;\n  }\n\n  static #applyFieldRetrofill(field, records, retrofill) {\n    if (!field.required && retrofill === undefined) return;\n    const retrofillFunction = retrofill !== undefined ? typeof retrofill === 'function' ? retrofill : () => retrofill : record => record[field.name] ? record[field.name] : field[$defaultValue];\n    records.forEach(record => {\n      record[field.name] = retrofillFunction(record);\n    });\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/model.js?");

/***/ }),

/***/ "./src/record/fragment.js":
/*!********************************!*\
  !*** ./src/record/fragment.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RecordFragment)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\nconst {\n  $recordTag\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nclass RecordFragment extends Array {\n  #tag;\n\n  constructor(values, tag) {\n    super();\n    values.forEach(value => {\n      this.push(value);\n    });\n    this.#tag = tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordTag]() {\n    return this.#tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$recordTag];\n  }\n\n  toObject() {\n    return [...this];\n  }\n\n  toJSON() {\n    return this.toObject();\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/fragment.js?");

/***/ }),

/***/ "./src/record/group.js":
/*!*****************************!*\
  !*** ./src/record/group.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RecordGroup)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set */ \"./src/record/set.js\");\n\n\nconst {\n  $groupTag\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nclass RecordGroup extends _set__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  #groupName;\n\n  constructor({\n    iterable = [],\n    copyScopesFrom = null,\n    groupName = ''\n  } = {}) {\n    super({\n      iterable,\n      copyScopesFrom\n    });\n    this.#groupName = groupName;\n  }\n  /* istanbul ignore next */\n\n\n  get [$groupTag]() {\n    return this.#groupName;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$groupTag];\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/group.js?");

/***/ }),

/***/ "./src/record/handler.js":
/*!*******************************!*\
  !*** ./src/record/handler.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./record */ \"./src/record/record.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types */ \"./src/types.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\n\n\n\n\nconst {\n  $fields,\n  $defaultValue,\n  $key,\n  $keyType,\n  $properties,\n  $relationships,\n  $validators,\n  $recordValue,\n  $wrappedRecordValue,\n  $recordModel,\n  $recordTag,\n  $isRecord,\n  $get\n} = _symbols__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n\nclass RecordHandler {\n  #model;\n\n  constructor(model) {\n    this.#model = model;\n  }\n\n  get model() {\n    return this.#model;\n  }\n\n  createRecord(recordData) {\n    if (!recordData) throw new TypeError('Record data cannot be empty.');\n    if (typeof recordData !== 'object') throw new TypeError('Record data must be an object.');\n    const modelName = this.#getModelName(); // Validate record key\n\n    const newRecordKey = RecordHandler.#validateNewRecordKey(modelName, this.#getKey(), recordData[this.#getKey().name], this.#model.records); // Clone record data, check for extra properties\n\n    const clonedRecord = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.deepClone)(recordData);\n    const extraProperties = Object.keys(clonedRecord).filter(property => !this.#hasField(property) && !this.#isModelKey(property));\n\n    if (extraProperties.length > 0) {\n      console.warn(`${modelName} record has extra fields: ${extraProperties.join(', ')}.`);\n    } // Create record with key and extra properties only\n\n\n    const newRecord = new _record__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      [this.#getKey().name]: newRecordKey,\n      ...extraProperties.reduce((obj, property) => ({ ...obj,\n        [property]: clonedRecord[property]\n      }), {})\n    }, this); // Set fields and skip validation\n\n    this.#getFieldNames().forEach(field => {\n      this.set(newRecord, field, clonedRecord[field], newRecord, true);\n    }); // Validate record just once\n\n    this.#getValidators().forEach((validator, validatorName) => {\n      if (!validator(newRecord, this.#model.records)) throw new RangeError(`${modelName} record with key ${newRecordKey} failed validation for ${validatorName}.`);\n    });\n    return [newRecordKey, newRecord];\n  }\n  /*  ======  Trap definitions  ======  */\n\n\n  get(record, property) {\n    // Check relationships first to avoid matching them as fields\n    if (this.#hasRelationshipField(property)) return this.#getRelationship(record, property); // Key or field, return as-is\n\n    if (this.#isModelKey(property) || this.#hasField(property)) return this.#getFieldValue(record, property); // Property, get and call, this also matches relationship reverses (properties)\n\n    if (this.#hasProperty(property)) return this.#getProperty(record, property); // Serialize method, call and return\n\n    if (this.#isCallToSerialize(property)) return RecordHandler.#recordToObject(record, this.#model, this); // Call toString method, return key value\n\n    if (this.#isCallToString(property)) return () => this.#getKeyValue(record); // Known symbol, handle as required\n\n    if (this.#isKnownSymbol(property)) return this.#getKnownSymbol(record, property); // Unknown property, return undefined\n\n    return undefined;\n  }\n\n  set(record, property, value, receiver, skipValidation) {\n    // Receiver is the same as record but never used (API compatibility)\n    const recordValue = record[$recordValue];\n    const recordKey = this.#getKeyValue(record);\n    const otherRecords = this.#model.records.except(recordKey); // Throw an error when trying to set a property, also catches\n    // relationship reverses, safeguarding against issues there.\n\n    if (this.#hasProperty(property)) throw new TypeError(`${this.#getModelName()} record ${recordKey} cannot set property ${property}.`); // Validate and set field, warn if field is not defined\n\n    /* istanbul ignore else*/\n\n    if (this.#hasField(property)) {\n      const field = this.#getField(property);\n      RecordHandler.#setRecordField(this.#model.name, recordValue, field, value); // Never skip individual field validation\n\n      field[$validators].forEach((validator, validatorName) => {\n        if (![null, undefined].includes(recordValue[property]) && !validator(recordValue, otherRecords)) throw new RangeError(`${this.#getModelName()} record with key ${recordKey} failed validation for ${validatorName}.`);\n      });\n    } else {\n      console.warn(`${this.#model.name} record has extra field: ${property}.`);\n      recordValue[property] = value;\n    } // Perform model validations\n    // The last argument, `skipValidation`, is used to skip validation\n    // and should only ever be set to `true` by the by the handler itself.\n\n\n    if (!skipValidation) {\n      this.#getValidators().forEach((validator, validatorName) => {\n        if (!validator(recordValue, otherRecords)) throw new RangeError(`${this.#getModelName()} record with key ${recordKey} failed validation for ${validatorName}.`);\n      });\n    }\n\n    return true;\n  } // Private methods\n\n\n  static #setRecordField(modelName, record, field, value) {\n    // Set the default value if the field is null or undefined\n    const recordValue = field.required && _types__WEBPACK_IMPORTED_MODULE_2__[\"default\"].nil(value) ? field[$defaultValue] : value;\n    if (!field.typeCheck(recordValue)) // Throw an error if the field value is invalid\n      throw new TypeError(`${modelName} record has invalid value for field ${field.name}.`);\n    record[field.name] = recordValue;\n  }\n\n  static #recordToObject(record, model, handler) {\n    const recordValue = record[$recordValue];\n    const fields = model[$fields];\n    const properties = model[$properties];\n    const key = model[$key].name;\n    const object = {\n      [key]: recordValue[key]\n    };\n    fields.forEach(field => {\n      const value = recordValue[field.name];\n      if (value !== undefined) object[field.name] = recordValue[field.name];\n    }); // TODO: V2 enhancements\n    // If we end up keeping this API, we might be interested in adding\n    // nesting that works correctly with relationships. Currently, you can\n    // only specify the relationship name, and it will serialize the\n    // full object. Examples like ['category', 'siblings.category'] should\n    // work eventually.\n    // We also need to account for nested arrays and objects etc.\n\n    const toObject = ({\n      include = []\n    } = {}) => {\n      let result = object;\n      const included = include.map(name => {\n        const [field, ...props] = name.split('.');\n        return [field, props.join('.')];\n      });\n      included.forEach(([includedField, props]) => {\n        if (object[includedField]) {\n          if (Array.isArray(object[includedField])) {\n            const records = handler.get(record, includedField);\n            object[includedField] = records.map(record => record.toObject({\n              include: [props]\n            }));\n          } else {\n            object[includedField] = handler.get(record, includedField).toObject({\n              include: [props]\n            });\n          }\n        } else if (properties.has(includedField)) {\n          object[includedField] = handler.get(record, includedField);\n        }\n      });\n      return result;\n    };\n\n    return toObject;\n  }\n\n  static #validateNewRecordKey = (modelName, modelKey, recordKey, records) => {\n    let newRecordKey = recordKey;\n    if (modelKey[$keyType] === 'string' && !modelKey.typeCheck(newRecordKey)) throw new TypeError(`${modelName} record has invalid value for key ${modelKey.name}.`);\n    if (modelKey[$keyType] === 'auto') newRecordKey = modelKey[$defaultValue];\n    if (records.has(newRecordKey)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.DuplicationError(`${modelName} record with key ${newRecordKey} already exists.`);\n    return newRecordKey;\n  };\n  /*  ======  Utility methods  ======  */\n\n  #getModelName() {\n    return this.#model.name;\n  }\n\n  #getFieldNames() {\n    return [...this.#model[$fields].keys()];\n  }\n\n  #getValidators() {\n    return this.#model[$validators];\n  }\n\n  #isModelKey(property) {\n    return this.#model[$key].name === property;\n  }\n\n  #getKey() {\n    return this.#model[$key];\n  }\n\n  #getKeyValue(record) {\n    return record[$recordValue][this.#model[$key].name];\n  }\n\n  #hasField(property) {\n    return this.#model[$fields].has(property);\n  }\n\n  #getField(property) {\n    return this.#model[$fields].get(property);\n  }\n\n  #getFieldValue(record, property) {\n    return record[$recordValue][property];\n  }\n\n  #hasProperty(property) {\n    return this.#model[$properties].has(property);\n  }\n\n  #getProperty(record, property) {\n    return this.#model[$properties].get(property)(record[$wrappedRecordValue]);\n  }\n\n  #hasRelationshipField(property) {\n    // A relationship field exists if a field with the same name exists and\n    // a relationship exists named `${property}.${property}`. This is due to\n    // relationships being stored as a `.`-delimited tuple of the relationship\n    // name and the field/property name. In the case of the field name, it's the\n    // same as the actual relationship name.\n    if (!this.#hasField(property)) return false;\n    return this.#model[$relationships].has(`${property}.${property}`);\n  }\n\n  #getRelationship(record, property) {\n    // Get the relationship from the field only. The field name matches that of\n    // the relationship, so the relationship key is ${property}.${property}`.\n    return this.#model[$relationships].get(`${property}.${property}`)[$get](this.#getModelName(), property, record[$recordValue]);\n  }\n\n  #isCallToSerialize(property) {\n    return property === 'toObject' || property === 'toJSON';\n  }\n\n  #isCallToString(property) {\n    return property === 'toString';\n  }\n\n  #isKnownSymbol(property) {\n    return [$recordModel, $recordTag, $recordValue, $isRecord, $key].includes(property);\n  }\n\n  #getKnownSymbol(record, property) {\n    if (property === $isRecord) return true;\n    if (property === $key) this.#getKey();\n    return record[property];\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecordHandler);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/handler.js?");

/***/ }),

/***/ "./src/record/index.js":
/*!*****************************!*\
  !*** ./src/record/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Record\": () => (/* reexport safe */ _record__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"PartialRecord\": () => (/* reexport safe */ _partial__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"RecordFragment\": () => (/* reexport safe */ _fragment__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"RecordGroup\": () => (/* reexport safe */ _group__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"RecordHandler\": () => (/* reexport safe */ _handler__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"RecordSet\": () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./record */ \"./src/record/record.js\");\n/* harmony import */ var _partial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./partial */ \"./src/record/partial.js\");\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragment */ \"./src/record/fragment.js\");\n/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./group */ \"./src/record/group.js\");\n/* harmony import */ var _handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handler */ \"./src/record/handler.js\");\n/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./set */ \"./src/record/set.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/index.js?");

/***/ }),

/***/ "./src/record/partial.js":
/*!*******************************!*\
  !*** ./src/record/partial.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PartialRecord)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\nconst {\n  $recordTag\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nclass PartialRecord {\n  #tag;\n\n  constructor(value, tag) {\n    Object.keys(value).forEach(key => {\n      this[key] = value[key];\n    });\n    this.#tag = tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordTag]() {\n    return this.#tag;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$recordTag];\n  }\n\n  toObject() {\n    return { ...this\n    };\n  }\n\n  toJSON() {\n    return this.toObject();\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/partial.js?");

/***/ }),

/***/ "./src/record/record.js":
/*!******************************!*\
  !*** ./src/record/record.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\nconst {\n  $recordValue,\n  $wrappedRecordValue,\n  $recordHandler,\n  $recordModel,\n  $recordTag,\n  $key\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\nclass Record {\n  #recordValue;\n  #recordHandler;\n  #proxiedRecord;\n\n  constructor(value, handler) {\n    this.#recordValue = value;\n    this.#recordHandler = handler;\n    this.#proxiedRecord = new Proxy(this, this.#recordHandler);\n    return this.#proxiedRecord;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordHandler]() {\n    return this.#recordHandler;\n  }\n\n  get [$recordValue]() {\n    return this.#recordValue;\n  } // This is used to get the record wrapped in the handler proxy. It's useful\n  // for property calls in records, so that they can access relationships and\n  // other properties via the handler proxy.\n\n  /* istanbul ignore next */\n\n\n  get [$wrappedRecordValue]() {\n    return this.#proxiedRecord;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordModel]() {\n    return this.#recordHandler.model;\n  }\n  /* istanbul ignore next */\n\n\n  get [$recordTag]() {\n    const model = this[$recordModel];\n    const key = model[$key].name;\n    return `${model.name}#${this[$recordValue][key]}`;\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return this[$recordTag];\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Record);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/record.js?");

/***/ }),

/***/ "./src/record/set.js":
/*!***************************!*\
  !*** ./src/record/set.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\n/* harmony import */ var _partial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./partial */ \"./src/record/partial.js\");\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragment */ \"./src/record/fragment.js\");\n/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./group */ \"./src/record/group.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\nconst {\n  $recordModel,\n  $recordTag,\n  $scopes,\n  $addScope,\n  $removeScope,\n  $copyScopes,\n  $isRecord,\n  $key\n} = _symbols__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n/**\n * An extension of the native Map object. Provides the same API, along with\n * additional methods similar to the Array prototype.\n */\n\nclass RecordSet extends Map {\n  #frozen;\n  #scopes; // TODO: V2 enhancements\n  // Add some way to pass the handler to the record set to prevent adding new\n  // values to the record set. Generally speaking calling `.set()` on a record\n  // set should probably be disabled.\n\n  constructor({\n    iterable = [],\n    copyScopesFrom = null\n  } = {}) {\n    super();\n\n    for (const [key, value] of iterable) this.set(key, value);\n\n    this.#scopes = new Map();\n    if (copyScopesFrom) this[$copyScopes](copyScopesFrom);\n    this.#frozen = false;\n  }\n  /**\n   * Freezes a record set, preventing further modification.\n   * @returns {RecordSet} The record set itself.\n   */\n\n\n  freeze() {\n    this.#frozen = true;\n    return this;\n  }\n  /**\n   *\n   * @param {*} key The key of the element to add to the record set.\n   * @param {*} value The value of the element to add to the record set.\n   * @returns {RecordSet} The record set itself.\n   */\n\n\n  set(key, value) {\n    // TODO: V2 Enhancements\n    // Ensure this is only ever called internally (maybe symbolize it?)\n    // Schema[$handleExperimentalAPIMessage](\n    //   'Calling RecordSet.prototype.set() is discouraged as it may cause unexpected behavior. This method may be removed in a future version of the library.'\n    // );\n    if (this.#frozen) throw new TypeError('Cannot modify a frozen RecordSet.');\n    super.set(key, value);\n    return this;\n  }\n  /**\n   * @param {*} key The key of the element to remove from the record set.\n   * @returns {boolean} True if the element was removed, false otherwise.\n   */\n\n\n  delete(key) {\n    if (this.#frozen) throw new TypeError('Cannot modify a frozen RecordSet.');\n    return super.delete(key);\n  }\n  /**\n   * Removes all elements from the record set.\n   */\n\n\n  clear() {\n    if (this.#frozen) throw new TypeError('Cannot modify a frozen RecordSet.');\n    super.clear();\n  }\n  /**\n   * Creates an object populated with the results of calling a provided function\n   * on every element in the calling record set.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Object} An object with each key mapped to the result of the\n   * callback function on the corresponding element.\n   */\n\n\n  map(callbackFn) {\n    return [...this.entries()].reduce((newMap, [key, value]) => {\n      newMap[key] = callbackFn(value, key, this);\n      return newMap;\n    }, {});\n  }\n  /**\n   * Creates an array of values by running each element of the record set\n   * through the provided transformation function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Array} An array with each element being the result of the\n   * callback function on the corresponding element.\n   */\n\n\n  flatMap(callbackFn) {\n    return [...this.entries()].map(([key, value]) => {\n      return callbackFn(value, key, this);\n    });\n  }\n  /**\n   * Executes a user-supplied “reducer” callback function on each element of the\n   * record set, passing in the return value from the calculation on the preceding\n   * element. The final result of running the reducer across all elements of the\n   * record set is a single value.\n   * @param {Function} callbackFn A “reducer” function that takes four arguments:\n   * - `accumulator`: The value returned from the previous iteration of the\n   * reducer.\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @param {*} initialValue The initial value of the accumulator.\n   * @returns {*} The value that results from running the “reducer” callback\n   * function to completion over the entire record set.\n   */\n\n\n  reduce(callbackFn, initialValue) {\n    return [...this.entries()].reduce((acc, [key, value]) => {\n      return callbackFn(acc, value, key, this);\n    }, initialValue);\n  }\n  /**\n   * Creates a new record set with all elements that pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that pass the test.\n   */\n\n\n  filter(callbackFn) {\n    return [...this.entries()].reduce((newMap, [key, value]) => {\n      if (callbackFn(value, key, this)) newMap.set(key, value);\n      return newMap;\n    }, new RecordSet({\n      copyScopesFrom: this\n    })).freeze();\n  }\n  /**\n   * Creates an array with all elements that pass the test implemente by the\n   * provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Array} An array with all elements that pass the test.\n   */\n\n\n  flatFilter(callbackFn) {\n    return [...this.entries()].reduce((arr, [key, value]) => {\n      if (callbackFn(value, key, this)) arr.push(value);\n      return arr;\n    }, []);\n  }\n  /**\n   * Returns the value of the first element in the record set that satisfies\n   * the provided testing function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Record} The value of the first element in the record set that\n   * satisfies the provided testing function or `undefined`.\n   */\n\n\n  find(callbackFn) {\n    const match = [...this.entries()].find(([key, value]) => callbackFn(value, key, this));\n    if (match) return match[1];\n    return undefined;\n  }\n  /**\n   * Returns the key of the first element in the record set that satisfies the\n   * provided testing function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {*} The key of the first element in the record set that satisfies\n   * the provided testing function or `undefined`.\n   */\n\n\n  findKey(callbackFn) {\n    const match = [...this.entries()].find(([key, value]) => callbackFn(value, key, this));\n    if (match) return match[0];\n    return undefined;\n  }\n  /**\n   * Returns all elements in the record set whose keys  match the provided\n   * key/keys.\n   * @param  {...any} keys A list of keys to exclude from the record set.\n   * @returns {RecordSet} A new record set with all elements whose keys\n   * match the provided key/keys.\n   */\n\n\n  only(...keys) {\n    return new RecordSet({\n      iterable: [...this.entries()].filter(([key]) => {\n        return keys.includes(key);\n      }),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns all elements in the record set whose keys do not match the provided\n   * key/keys.\n   * @param  {...any} keys A list of keys to exclude from the record set.\n   * @returns {RecordSet} A new record set with all elements whose keys do not\n   * match the provided key/keys.\n   */\n\n\n  except(...keys) {\n    return new RecordSet({\n      iterable: [...this.entries()].filter(([key]) => {\n        return !keys.includes(key);\n      }),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Sorts the elements of the record set and returns a new sorted record set.\n   * @param {Function} callbackFn Function that defined the sort order. The\n   * callback is called with the following arguments:\n   * - `firstValue`: The value of the first element for comparison.\n   * - `secondValue`: The value of the second element for comparison.\n   * - `firstKey`: The key of the first element for comparison.\n   * - `secondKey`: The key of the second element for comparison.\n   * @returns {RecordSet} A new record set with the elements of the original\n   * record set sorted.\n   */\n\n\n  sort(comparatorFn) {\n    const sorted = [...this.entries()].sort(([key1, value1], [key2, value2]) => comparatorFn(value1, value2, key1, key2));\n    return new RecordSet({\n      iterable: sorted,\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Tests whether all elements in the record set pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Boolean} `true` if all elements in the record set pass the test,\n   * `false` otherwise.\n   */\n\n\n  every(callbackFn) {\n    if (this.size === 0) return true;\n    return [...this.entries()].every(([key, value]) => callbackFn(value, key, this));\n  }\n  /**\n   * Tests whether some elements in the record set pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Boolean} `true` if any elements in the record set pass the test,\n   * `false` otherwise.\n   */\n\n\n  some(callbackFn) {\n    if (this.size === 0) return false;\n    return [...this.entries()].some(([key, value]) => callbackFn(value, key, this));\n  }\n  /**\n   * Returns a new record set with all elements mapped to the keys specified.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {RecordSet} A new record set with all elements mapped to the\n   * keys specified.\n   */\n\n\n  select(...keys) {\n    return new RecordSet({\n      iterable: [...this.entries()].map(([key, value]) => {\n        const obj = {};\n        keys.forEach(key => obj[key] = value[key]);\n        return [key, new _partial__WEBPACK_IMPORTED_MODULE_2__[\"default\"](obj, value[$recordTag])];\n      }),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns an array of objects with all elements mapped to the keys specified.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {Array} An array with all elements mapped to the keys specified.\n   */\n\n\n  flatSelect(...keys) {\n    return [...this.values()].map(value => keys.reduce((obj, key) => ({ ...obj,\n      [key]: value[key]\n    }), {}));\n  }\n  /**\n   * Returns a new record set with records mapped to fragments containing\n   * only the keys specified.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {RecordSet} A new record set with all elements mapped to\n   * fragments containing only the keys specified.\n   */\n\n\n  pluck(...keys) {\n    return new RecordSet({\n      iterable: [...this.entries()].map(([key, value]) => {\n        const values = keys.map(key => value[key]);\n        return [key, new _fragment__WEBPACK_IMPORTED_MODULE_3__[\"default\"](values, value[$recordTag])];\n      }),\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns an array with records mapped to arrays containing only the\n   * keys specified. If only one key is specified, the array contains the\n   * value of each element instead.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {RecordSet} A new record set with all elements mapped to\n   * fragments containing only the keys specified.\n   */\n\n\n  flatPluck(...keys) {\n    const isSingleKey = keys.length === 1;\n    return [...this.values()].map(value => isSingleKey ? value[keys[0]] : keys.map(key => value[key]));\n  }\n  /**\n   * Group the elements of the record set by the specified key.\n   * @param {*} key A key to group the elements by.\n   * @returns {RecordSet} A new record set containing groups of elements.\n   */\n\n\n  groupBy(key) {\n    const res = new RecordSet({\n      copyScopesFrom: this,\n      iterable: []\n    });\n\n    for (const [recordKey, value] of this.entries()) {\n      let keyValue = value[key];\n\n      if (keyValue !== undefined && keyValue !== null && keyValue[$isRecord]) {\n        keyValue = value[key][$key];\n      }\n\n      if (!res.has(keyValue)) {\n        res.set(keyValue, new _group__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n          copyScopesFrom: this,\n          iterable: [],\n          groupName: keyValue\n        }));\n      }\n\n      res.get(keyValue).set(recordKey, value);\n    }\n\n    for (const value of res.values()) {\n      value.freeze();\n    }\n\n    return res.freeze();\n  }\n  /**\n   * Creates a new record set with all elements that pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that pass the test.\n   */\n\n\n  where(callbackFn) {\n    return this.filter(callbackFn);\n  }\n  /**\n   * Creates a new record set with all elements that fail the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `key`: The key of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that fail the test.\n   */\n\n\n  whereNot(callbackFn) {\n    return this.filter((value, key, map) => !callbackFn(value, key, map));\n  }\n  /**\n   * Iterates over the record set in batches of the specified size.\n   * @param {Number} batchSize The size of each batch.\n   * @returns {Iterator} An iterator that yields batches of the specified size.\n   */\n\n\n  *batchIterator(batchSize) {\n    let batch = [];\n\n    for (const [, value] of this) {\n      batch.push(value);\n\n      if (batch.length === batchSize) {\n        yield batch;\n        batch = [];\n      }\n    }\n\n    if (batch.length) yield batch;\n  }\n  /**\n   * Returns a new record set with only the first n elements.\n   * @param {Number} n The number of elements to keep.\n   * @returns {RecordSet} A new record set with only the first n elements.\n   */\n\n\n  limit(n) {\n    let records = [];\n\n    for (const [key, value] of this) {\n      records.push([key, value]);\n      if (records.length === n) break;\n    }\n\n    return new RecordSet({\n      iterable: records,\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns a new record set with the first n elements removed.\n   * @param {Number} n The number of elements to remove.\n   * @returns {RecordSet} A new record set with the first n elements removed.\n   */\n\n\n  offset(n) {\n    let counter = 0;\n    let records = [];\n\n    for (const [key, value] of this) {\n      if (counter < n) counter++;else records.push([key, value]);\n    }\n\n    return new RecordSet({\n      iterable: records,\n      copyScopesFrom: this\n    }).freeze();\n  }\n  /**\n   * Returns the first element in the record set.\n   */\n\n\n  get first() {\n    for (const [, value] of this) return value;\n\n    return undefined;\n  }\n  /**\n   * Returns the last element in the record set.\n   */\n\n\n  get last() {\n    if (this.size === 0) return undefined;\n    return [...this.entries()].pop()[1];\n  }\n  /**\n   * Returns the number of elements in the record set.\n   */\n\n\n  get count() {\n    return this.size;\n  }\n  /**\n   * Returns an array of the records contained in the record set.\n   * @returns {Array<Record>} An array of the values contained in the record set.\n   */\n\n\n  toArray() {\n    return [...this.values()];\n  }\n  /**\n   * Returns an array of objects representing the records in the record set.\n   * @returns {Array<Object>} An array of objects representing the records in\n   * the record set.\n   */\n\n\n  toFlatArray() {\n    return [...this.values()].map(value => value instanceof _group__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? value.toFlatArray() : value.toObject());\n  }\n  /**\n   * Returns an object representing the record set.\n   * @returns {Object} An object representing the record set.\n   */\n\n\n  toObject() {\n    return [...this.entries()].reduce((obj, [key, value]) => {\n      obj[key] = value;\n      return obj;\n    }, {});\n  }\n  /**\n   * Returns a flattened object of objects representing the records in the\n   * record set.\n   * @returns {Object} An object representing the records in the record set.\n   */\n\n\n  toFlatObject() {\n    return [...this.entries()].reduce((obj, [key, value]) => {\n      obj[key] = value instanceof _group__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? value.toFlatArray() : value.toObject();\n      return obj;\n    }, {});\n  }\n  /**\n   * Returns the object repeseentation of the record set.\n   * Used by JSON.stringify().\n   * @returns {Object} The object representation of the record set.\n   */\n\n\n  toJSON() {\n    return this.toObject();\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    const records = [...this.values()];\n\n    try {\n      const firstModel = records[0][$recordModel].name;\n      if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.allEqualBy)(records, value => value[$recordModel].name === firstModel)) return firstModel;\n    } catch (e) {\n      return '';\n    }\n\n    return '';\n  }\n  /* istanbul ignore next */\n\n\n  static get [Symbol.species]() {\n    return Map;\n  } // Protected (package internal-use only)\n\n\n  [$addScope](name, scope) {\n    RecordSet.#validateProperty('Scope', name, scope, this.#scopes);\n    if (this[name] || Object.getOwnPropertyNames(RecordSet.prototype).includes(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.NameError(`Scope name ${name} is already in use.`);\n    this.#scopes.set(name, scope);\n    Object.defineProperty(this, name, {\n      configurable: true,\n      // Allows deletion in $removeScope\n      get: () => {\n        return this.where(this.#scopes.get(name));\n      }\n    });\n  }\n\n  [$removeScope](name) {\n    this.#scopes.delete(RecordSet.#validateContains('Scope', name, this.#scopes));\n    delete this[name];\n  }\n\n  [$copyScopes](otherRecordSet) {\n    otherRecordSet[$scopes].forEach((scope, name) => {\n      this[$addScope](name, scope);\n    });\n  }\n\n  get [$scopes]() {\n    return this.#scopes;\n  } // Private\n\n\n  static #validateProperty(callbackType, callbackName, callback, callbacks) {\n    if (typeof callback !== 'function') throw new TypeError(`${callbackType} ${callbackName} is not a function.`);\n    if (callbacks.has(callbackName)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__.DuplicationError(`${callbackType} ${callbackName} already exists.`);\n    return callback;\n  }\n\n  static #validateContains(objectType, objectName, objects) {\n    if (!objects.has(objectName)) throw new ReferenceError(`${objectType} ${objectName} does not exist.`);\n    return objectName;\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecordSet);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/set.js?");

/***/ }),

/***/ "./src/relationship.js":
/*!*****************************!*\
  !*** ./src/relationship.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Relationship\": () => (/* binding */ Relationship)\n/* harmony export */ });\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./field */ \"./src/field.js\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema */ \"./src/schema.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ \"./src/types.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\n\nconst {\n  $key,\n  $recordValue,\n  $fields,\n  $getField,\n  $getProperty,\n  $get,\n  $defaultValue,\n  $instances,\n  $handleExperimentalAPIMessage\n} = _symbols__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\nconst relationshipEnum = {\n  oneToOne: 'oneToOne',\n  oneToMany: 'oneToMany',\n  manyToOne: 'manyToOne',\n  manyToMany: 'manyToMany'\n};\nclass Relationship {\n  #type;\n  #from;\n  #to;\n  #name; // relationship field name in the from table\n\n  #reverseName; // relationship field name in the to table\n\n  #relationshipField; // relationship field in the from model\n\n  #relationshipProperty; // relationship property in the to model\n  // TODO: V2 enhancements\n  // After the API for relationships is stable-ish, figure out a way to add\n  // cascade.\n\n  constructor({\n    from,\n    to,\n    type\n  } = {}) {\n    _schema__WEBPACK_IMPORTED_MODULE_1__.Schema[$handleExperimentalAPIMessage]('Relationships are experimental in the current version. There is neither validation of existence in foreign tables nor guarantee that associations work. Please use with caution.');\n    this.#type = Relationship.#validateType(type);\n    const [fromModel, fromName, toModel, toName] = Relationship.#parseModelsAndNames(from, to, type);\n    this.#from = fromModel;\n    this.#to = toModel;\n    this.#name = fromName;\n    this.#reverseName = toName;\n    if (this.#to === this.#from && Relationship.#isSymmetric(this.#type) && this.#name === this.#reverseName) throw new RangeError('Relationship cannot be symmetric if the from and to models are the same and no name is provided for either one.');\n    this.#relationshipField = Relationship.#createField(this.#name, this.#type, this.#to[$key]);\n\n    this.#relationshipProperty = record => {\n      return this.#getAssociatedRecordsReverse(record);\n    };\n  } // Protected (package internal-use only)\n\n\n  [$getField]() {\n    return {\n      name: this.#name,\n      type: this.#type,\n      fieldName: this.#name,\n      field: this.#relationshipField\n    };\n  }\n\n  [$getProperty]() {\n    return {\n      name: this.#name,\n      type: this.#type,\n      propertyName: this.#reverseName,\n      property: this.#relationshipProperty\n    };\n  }\n\n  [$get](modelName, property, record) {\n    // When from model is specified, apply the relationship as-is\n    if (modelName === this.#from.name && property === this.#name) {\n      return this.#getAssociatedRecords(record);\n    } // When to model is specified, reverse the relationship before applying it\n\n    /* istanbul ignore next */\n\n\n    if (modelName === this.#to.name && property === this.#reverseName) {\n      console.warn('Relationship getter called by the receiver model. This might indicate an issue with the library and should be reported.');\n      return this.#getAssociatedRecordsReverse(record);\n    }\n  } // Private\n\n\n  #getAssociatedRecords(record) {\n    // Use a regular get for toOne relationships for performance\n    if (Relationship.#isToOne(this.#type)) {\n      const associationValue = record[this.#name];\n      return this.#to.records.get(associationValue);\n    } // Use a where query for toMany relationships, safeguard against empty value\n\n\n    const associationValues = record[this.#name] || [];\n    const associatedRecordsKeyName = this.#to[$key].name;\n    return this.#to.records.where(associatedRecord => {\n      return associationValues.includes(associatedRecord[associatedRecordsKeyName]);\n    });\n  }\n\n  #getAssociatedRecordsReverse(record) {\n    const associationValue = record[this.#to[$key].name];\n    const matcher = Relationship.#isToOne(this.#type) ? associatedRecord => associatedRecord[$recordValue][this.#name] === associationValue : associatedRecord => {\n      const associatedRecordValue = associatedRecord[$recordValue][this.#name];\n      if ([undefined, null].includes(associatedRecordValue)) return false;\n      return associatedRecord[$recordValue][this.#name].includes(associationValue);\n    }; // Use a regular get for fromOne relationships for performance\n\n    if (Relationship.#isFromOne(this.#type)) {\n      return this.#from.records.find(matcher);\n    } // Use a where query for fromMany relationships, safeguard against empty value\n\n\n    return this.#from.records.where(matcher);\n  }\n\n  static #isToOne(type) {\n    return [relationshipEnum.oneToOne, relationshipEnum.manyToOne].includes(type);\n  }\n\n  static #isToMany(type) {\n    return [relationshipEnum.oneToMany, relationshipEnum.manyToMany].includes(type);\n  }\n\n  static #isFromOne(type) {\n    return [relationshipEnum.oneToMany, relationshipEnum.oneToOne].includes(type);\n  }\n\n  static #isFromMany(type) {\n    return [relationshipEnum.manyToOne, relationshipEnum.manyToMany].includes(type);\n  }\n\n  static #isSymmetric(type) {\n    return [relationshipEnum.oneToOne, relationshipEnum.manyToMany].includes(type);\n  }\n\n  static #createField(name, relationshipType, foreignField) {\n    // TODO: V2 enhancements\n    // Potentially add a check if the other model contains the key(s)?\n    const isSingleSource = Relationship.#isFromOne(relationshipType);\n    const isMultiple = Relationship.#isToMany(relationshipType);\n    const type = isMultiple ? _types__WEBPACK_IMPORTED_MODULE_5__[\"default\"].arrayOf(value => foreignField.typeCheck(value)) : value => foreignField.typeCheck(value); // TODO: V2 enhancements\n    // Add a custom validator for symmetric relationships to ensure that a\n    // record does not reference itself in the relationship, creating a loop.\n\n    const validators = {}; // oneToOne means that for each record in the to model, there is at most\n    // one record in the from model. No overlap.\n\n    if (isSingleSource && !isMultiple) validators.unique = true; // toMany relationships are not allowed to have duplicate values.\n\n    if (isMultiple) validators.uniqueValues = true;\n    const relationshipField = new _field__WEBPACK_IMPORTED_MODULE_0__.Field({\n      name,\n      type,\n      required: false,\n      defaultValue: isMultiple ? [] : null,\n      validators\n    }); // Override the default value to throw an error\n\n    Object.defineProperty(relationshipField, $defaultValue, {\n      get() {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.DefaultValueError('Relationship field does not have a default value.');\n      }\n\n    });\n    return relationshipField;\n  }\n\n  static #validateType(relationshipType) {\n    if (!Object.values(relationshipEnum).includes(relationshipType)) throw new TypeError(`Invalid relationship type: ${relationshipType}.`);\n    return relationshipType;\n  }\n\n  static #validateModel(modelData) {\n    const modelName = typeof modelData === 'string' ? modelData : modelData.model;\n    if (!_model__WEBPACK_IMPORTED_MODULE_3__.Model[$instances].has(modelName)) throw new ReferenceError(`Model ${modelName} does not exist.`);\n    return _model__WEBPACK_IMPORTED_MODULE_3__.Model[$instances].get(modelName);\n  }\n\n  static #createName(type, to) {\n    if (Relationship.#isToOne(type)) return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(to);\n    if (Relationship.#isToMany(type)) return `${(0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(to)}Set`;\n  }\n\n  static #createReverseName = (type, from) => {\n    if (Relationship.#isFromOne(type)) return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(from);\n    if (Relationship.#isFromMany(type)) return `${(0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(from)}Set`;\n  };\n\n  static #validateModelParams(modelData) {\n    const model = Relationship.#validateModel(modelData);\n    const name = typeof modelData === 'string' ? null : (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)('Field', modelData.name);\n    if (name !== null && model[$fields].has(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.DuplicationError(`Field ${name} already exists in ${model.name}.`);\n    return [model, name];\n  }\n\n  static #parseModelsAndNames(from, to, type) {\n    let fromModel, fromName, toModel, toName;\n    [fromModel, fromName] = Relationship.#validateModelParams(from);\n    [toModel, toName] = Relationship.#validateModelParams(to);\n    if (fromName === null) fromName = Relationship.#createName(type, toModel.name);\n    if (toName === null) toName = Relationship.#createReverseName(type, fromModel.name);\n    return [fromModel, fromName, toModel, toName];\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/relationship.js?");

/***/ }),

/***/ "./src/schema.js":
/*!***********************!*\
  !*** ./src/schema.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Schema\": () => (/* binding */ Schema),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _relationship__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./relationship */ \"./src/relationship.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\nconst {\n  $addRelationshipAsField,\n  $addRelationshipAsProperty,\n  $handleExperimentalAPIMessage,\n  $key,\n  $keyType\n} = _symbols__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n/**\n * A Schema is a collection of models.\n * @extends EventEmitter\n * @param {Object} options Schema options\n * @param {String} options.name The name of the schema\n * @param {Array<Object>} options.models An object containing initial models for\n * the schema.\n */\n\nclass Schema extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {\n  #name;\n  #models;\n  static defaultConfig = {\n    experimentalAPIMessages: 'warn'\n  };\n  static config = { ...Schema.defaultConfig\n  };\n  static #schemas = new Map();\n\n  constructor({\n    name,\n    models = [],\n    relationships = [],\n    config = {}\n  } = {}) {\n    super();\n    this.#name = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)('Schema', name);\n    this.#models = new Map();\n    Schema.#parseConfig(config);\n    Schema.#schemas.set(this.#name, this);\n    models.forEach(model => this.createModel(model));\n    relationships.forEach(relationship => this.createRelationship(relationship));\n  }\n  /**\n   * Creates a model and adds it to the schema.\n   * @param {Object} modelData Data for the model to be added.\n   * @returns The newly created model.\n   */\n\n\n  createModel(modelData) {\n    this.emit('beforeCreateModel', {\n      model: modelData,\n      schema: this\n    });\n    const model = Schema.#parseModel(this.#name, modelData, this.#models);\n    this.#models.set(model.name, model);\n    model.on('change', ({\n      type,\n      ...eventData\n    }) => {\n      this.emit('change', {\n        type: `model${(0,_utils__WEBPACK_IMPORTED_MODULE_4__.capitalize)(type)}`,\n        ...eventData,\n        schema: this\n      });\n    });\n    this.emit('modelCreated', {\n      model,\n      schema: this\n    });\n    this.emit('change', {\n      type: 'modelCreated',\n      model,\n      schema: this\n    });\n    return model;\n  }\n  /**\n   * Retrieves a model from the schema.\n   * @param {String} name The name of the model to retrieve.\n   * @returns The model or `undefined` if it does not exist.\n   */\n\n\n  getModel(name) {\n    return this.#models.get(name);\n  }\n  /**\n   * Removes a model from the schema.\n   * @param {String} name The name of the model to remove.\n   */\n\n\n  removeModel(name) {\n    const model = this.getModel(name);\n    this.emit('beforeRemoveModel', {\n      model,\n      schema: this\n    });\n    if (!this.#models.has(name)) throw new ReferenceError(`Model ${name} does not exist in schema ${this.#name}.`);\n    this.#models.delete(name); // TODO: V2 enhancements\n    // Figure out a way to add cascade for relationships\n\n    this.emit('modelRemoved', {\n      model: {\n        name\n      },\n      schema: this\n    });\n    this.emit('change', {\n      type: 'modelRemoved',\n      model,\n      schema: this\n    });\n  }\n  /**\n   * EXPERIMENTAL\n   * Creates a relationship between two models and adds it to the schema.\n   * @param {Object} relationshipData Data for the relationship to be added.\n   * @returns The newly created relationship.\n   */\n\n\n  createRelationship(relationshipData) {\n    this.emit('beforeCreateRelationship', {\n      relationship: relationshipData,\n      schema: this\n    });\n    const relationship = Schema.#applyRelationship(this.#name, relationshipData, this.#models);\n    this.emit('relationshipCreated', {\n      relationship,\n      schema: this\n    });\n    this.emit('change', {\n      type: 'relationshipCreated',\n      relationship,\n      schema: this\n    });\n    return relationship;\n  }\n  /**\n   * Gets the schema's name.\n   */\n\n\n  get name() {\n    return this.#name;\n  }\n  /**\n   * Gets all models in the schema.\n   */\n\n\n  get models() {\n    return this.#models;\n  } // TODO: Make users use this instead of the constructor, using a private flag.\n  // Use another private flag to throw if more than one schema is created\n  // (not supported for this release).\n\n  /**\n   * Creates a new schema with the given name and options.\n   * @param {Object} schemaData Data for the schema to be created.\n   * @returns The newly created schema.\n   */\n\n\n  static create(schemaData) {\n    return new Schema(schemaData);\n  } // TODO: V2 enhancements\n  // Check validity of this. Currently it's not mentioned anywhere in the docs.\n\n\n  static get(name) {\n    return Schema.#schemas.get(name);\n  }\n  /**\n   * Retrieves the data specified by the given pathName\n   * @param {String} pathName A '.'-delimited path to the data.\n   * @returns The value at the specified path.\n   */\n\n\n  get(pathName) {\n    this.emit('beforeGet', {\n      pathName,\n      schema: this\n    });\n    const [modelName, recordKey, ...rest] = pathName.split('.');\n    const model = this.getModel(modelName);\n    if (!model) throw new ReferenceError(`Model ${modelName} does not exist in schema ${this.#name}.`);\n    if (recordKey === undefined) return model;\n    const keyType = model[$key][$keyType];\n    const record = model.records.get(keyType === 'string' ? recordKey : Number.parseInt(recordKey));\n    if (!rest.length) return record;\n    if (!record) throw new ReferenceError(`Record ${recordKey} does not exist in model ${modelName}.`);\n    const result = rest.reduce((acc, key) => acc[key], record);\n    this.emit('got', {\n      pathName,\n      result,\n      schema: this\n    });\n    return result;\n  } // Protected (package internal-use only)\n\n  /* istanbul ignore next */\n\n\n  static [$handleExperimentalAPIMessage](message) {\n    const {\n      experimentalAPIMessages\n    } = Schema.config;\n\n    if (experimentalAPIMessages === 'warn') {\n      console.warn(message);\n    } else if (experimentalAPIMessages === 'error') {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ExperimentalAPIUsageError(message);\n    }\n  } // Private\n\n\n  static #parseModel(schemaName, modelData, models) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateObjectWithUniqueName)({\n      objectType: 'Model',\n      parentType: 'Schema',\n      parentName: schemaName\n    }, modelData, [...models.keys()]);\n    return new _model__WEBPACK_IMPORTED_MODULE_1__.Model(modelData);\n  }\n\n  static #applyRelationship(schemName, relationshipData, models) {\n    const {\n      from,\n      to,\n      type\n      /* , cascade */\n\n    } = relationshipData;\n    [from, to].forEach(model => {\n      if (!['string', 'object'].includes(typeof model)) throw new TypeError(`Invalid relationship model: ${model}.`);\n    });\n    const fromModelName = typeof from === 'string' ? from : from.model;\n    const toModelName = typeof to === 'string' ? to : to.model;\n    const fromModel = models.get(fromModelName);\n    const toModel = models.get(toModelName);\n    if (!fromModel) throw new ReferenceError(`Model ${fromModelName} not found in schema ${schemName} when attempting to create a relationship.`);\n    if (!toModel) throw new ReferenceError(`Model ${toModelName} not found in schema ${schemName} when attempting to create a relationship.`);\n    const relationship = new _relationship__WEBPACK_IMPORTED_MODULE_2__.Relationship({\n      from,\n      to,\n      type\n    });\n    fromModel[$addRelationshipAsField](relationship);\n    toModel[$addRelationshipAsProperty](relationship);\n    return relationship;\n  }\n\n  static #parseConfig(config = {}) {\n    if (!config) return;\n    ['experimentalAPIMessages'].forEach(key => {\n      if (config[key] !== undefined) {\n        if (['warn', 'error', 'off'].includes(config[key])) Schema.config[key] = config[key];\n      }\n    });\n  } // TODO: V2 enhancements\n  // Add a mechanism here so that plugins can hook up to the schema via the\n  // event API or other stuff. Generally, the Schema is the de facto entrypoint\n  // of the library, so we should make sure that all plugins interface with it.\n  //\n  // Alternatively, we could have a wrapper around the Schema, which might be\n  // preferable as we can have multiple schemas and hook up events more easily.\n  //\n  // We also need a way to modularize and granularize the logging/erroring. A\n  // wrapper would allow us to specify this across.\n\n\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Schema);\n\n//# sourceURL=webpack://@jsiqle/core/./src/schema.js?");

/***/ }),

/***/ "./src/symbols.js":
/*!************************!*\
  !*** ./src/symbols.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Symbolizes any number of strings and return an object\n * @param  {...any} str Array of strings to symbolize\n * @returns {object} Object with symbolized strings\n */\nconst symbolizeAll = (...str) => str.reduce((acc, curr) => {\n  acc[`$${curr}`] = Symbol.for(curr);\n  return acc;\n}, {});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (symbolizeAll('fields', 'key', 'keyType', 'properties', 'scopes', 'relationships', 'relationshipField', 'validators', 'recordModel', 'recordValue', 'wrappedRecordValue', 'recordHandler', 'recordTag', 'defaultValue', 'addScope', 'addRelationshipAsField', 'addRelationshipAsProperty', 'getField', 'getProperty', 'removeScope', 'copyScopes', 'instances', 'isRecord', 'groupTag', 'get', 'handleExperimentalAPIMessage'));\n\n//# sourceURL=webpack://@jsiqle/core/./src/symbols.js?");

/***/ }),

/***/ "./src/types.js":
/*!**********************!*\
  !*** ./src/types.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"standardTypes\": () => (/* binding */ standardTypes),\n/* harmony export */   \"key\": () => (/* binding */ key)\n/* harmony export */ });\nconst isBoolean = val => typeof val === 'boolean';\n\nconst isNumber = val => typeof val === 'number' && val === val;\n\nconst isString = val => typeof val === 'string';\n\nconst isDate = val => val instanceof Date;\n\nconst and = (...types) => val => types.every(type => type(val));\n\nconst or = (...types) => val => types.some(type => type(val));\n\nconst isPositive = val => val >= 0;\n\nconst isArrayOf = type => val => Array.isArray(val) && val.every(type);\n\nconst isOrIsArrayOf = type => val => or(isArrayOf(type), type)(val);\n\nconst isObject = shape => {\n  const props = Object.keys(shape);\n  return val => {\n    if (val === null || val === undefined || typeof val !== 'object') return false;\n    if (props.length === 0) return true;\n    const valProps = Object.keys(val);\n    if (valProps.length !== props.length) return false;\n    return props.every(prop => shape[prop](val[prop]));\n  };\n};\n\nconst isObjectOf = type => val => {\n  if (val === null || val === undefined || typeof val !== 'object') return false;\n  return Object.keys(val).every(prop => type(val[prop]));\n};\n\nconst isEnum = (...values) => val => values.includes(val);\n\nconst isNull = val => val === null;\n\nconst isUndefined = val => val === undefined;\n\nconst isNil = or(isNull, isUndefined);\n\nconst isOptional = type => val => or(isNil, type)(val);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  // Primitive types\n  bool: isBoolean,\n  number: isNumber,\n  positiveNumber: and(isNumber, isPositive),\n  string: isString,\n  date: isDate,\n  // Special types\n  stringOrNumber: or(isString, isNumber),\n  numberOrString: or(isString, isNumber),\n  enum: isEnum,\n  boolArray: isArrayOf(isBoolean),\n  numberArray: isArrayOf(isNumber),\n  stringArray: isArrayOf(isString),\n  dateArray: isArrayOf(isDate),\n  // Composition types\n  oneOf: or,\n  arrayOf: isArrayOf,\n  oneOrArrayOf: isOrIsArrayOf,\n  object: isObject,\n  objectOf: isObjectOf,\n  optional: isOptional,\n  // Empty types\n  null: isNull,\n  undefined: isUndefined,\n  nil: isNil\n});\nconst standardTypes = {\n  boolean: {\n    type: isBoolean,\n    defaultValue: false\n  },\n  number: {\n    type: isNumber,\n    defaultValue: 0\n  },\n  positiveNumber: {\n    type: and(isNumber, isPositive),\n    defaultValue: 0\n  },\n  string: {\n    type: isString,\n    defaultValue: ''\n  },\n  date: {\n    type: isDate,\n    defaultValue: new Date()\n  },\n  stringOrNumber: {\n    type: or(isString, isNumber),\n    defaultValue: ''\n  },\n  numberOrString: {\n    type: or(isString, isNumber),\n    defaultValue: 0\n  },\n  booleanArray: {\n    type: isArrayOf(isBoolean),\n    defaultValue: []\n  },\n  numberArray: {\n    type: isArrayOf(isNumber),\n    defaultValue: []\n  },\n  stringArray: {\n    type: isArrayOf(isString),\n    defaultValue: []\n  },\n  dateArray: {\n    type: isArrayOf(isDate),\n    defaultValue: []\n  },\n  object: {\n    type: isObject({}),\n    defaultValue: {}\n  },\n  booleanObject: {\n    type: isObjectOf(isBoolean),\n    defaultValue: {\n      a: true\n    }\n  },\n  numberObject: {\n    type: isObjectOf(isNumber),\n    defaultValue: {}\n  },\n  stringObject: {\n    type: isObjectOf(isString),\n    defaultValue: {}\n  },\n  dateObject: {\n    type: isObjectOf(isDate),\n    defaultValue: {}\n  },\n  objectArray: {\n    type: isArrayOf(isObject({})),\n    defaultValue: []\n  }\n}; // Internal types\n\nconst isNonEmptyString = val => val.trim().length !== 0;\n\nconst key = and(isString, isNonEmptyString);\n\n//# sourceURL=webpack://@jsiqle/core/./src/types.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"validateName\": () => (/* binding */ validateName),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"reverseCapitalize\": () => (/* binding */ reverseCapitalize),\n/* harmony export */   \"deepClone\": () => (/* binding */ deepClone),\n/* harmony export */   \"allEqualBy\": () => (/* binding */ allEqualBy),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"validateObjectWithUniqueName\": () => (/* binding */ validateObjectWithUniqueName)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n // Name validation\n\nconst restrictedNames = {\n  Model: ['toString', 'toObject', 'toJSON'],\n  Field: ['toString', 'toObject', 'toJSON'],\n  Relationship: ['toString', 'toObject', 'toJSON']\n};\n/**\n * Validates the name of a field or model.\n * Restrictiorns:\n * - Must be a string\n * - Must be at least 1 character long\n * - Must not start with a number\n * - Must contain only alphanumeric characters, numbers or underscores\n * @param {string} name The name of the field or model to validate.\n * @param {Array<string>} restrictedNames An array of restricted names.\n * @returns {boolean} Whether the name is valid.\n */\n\nconst isValidName = (name, restrictedNames = []) => {\n  if (typeof name !== 'string') return [false, 'must be a string'];\n  if (!name) return [false, 'is required'];\n  if (/^\\d/.test(name)) return [false, 'cannot start with a number'];\n  if (restrictedNames.includes(name)) return [false, 'is reserved'];\n  return [/^\\w+$/.test(name), 'must contain only alphanumeric characters, numbers or underscores'];\n};\n/**\n * Validates the name of a field or model.\n * Restrictiorns:\n * - Must be a string\n * - Must be at least 1 character long\n * - Must not start with a number\n * - Must contain only alphanumeric characters, numbers or underscores\n * @param {string} objectType The type of object to validate.\n * @param {string} name The name of the field or model to validate.\n * @throws {NameError} If the name is invalid.\n * @returns {boolean} Whether the name is valid.\n */\n\n\nconst validateName = (objectType, name) => {\n  const [isValid, message] = isValidName(name, restrictedNames[objectType]);\n  if (!isValid) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NameError(`${objectType} name ${message}.`);\n  return name;\n}; // General-purpose utilities\n\nconst capitalize = ([first, ...rest]) => first.toUpperCase() + rest.join('');\nconst reverseCapitalize = ([first, ...rest]) => first.toLowerCase() + rest.join('');\nconst deepClone = obj => {\n  if (obj === null) return null;\n  if (obj instanceof Date) return new Date(obj);\n  let clone = Object.assign({}, obj);\n  Object.entries(clone).forEach(([key, value]) => clone[key] = typeof obj[key] === 'object' ? deepClone(value) : value);\n\n  if (Array.isArray(obj)) {\n    clone.length = obj.length;\n    return Array.from(clone);\n  }\n\n  return clone;\n};\nconst allEqualBy = (arr, fn) => {\n  const eql = fn(arr[0]);\n  return arr.every(val => fn(val) === eql);\n};\nconst isObject = obj => obj && typeof obj === 'object';\nconst contains = (collection, item) => collection.includes(item);\nconst validateObjectWithUniqueName = ({\n  objectType,\n  parentType,\n  parentName\n}, obj, collection) => {\n  if (!isObject(obj)) throw new TypeError(`${objectType} ${obj} is not an object.`);\n  if (contains(collection, obj.name)) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.DuplicationError(`${parentType} ${parentName} already has a ${objectType.toLowerCase()} named ${obj.name}.`);\n  return true;\n};\n\n//# sourceURL=webpack://@jsiqle/core/./src/utils.js?");

/***/ }),

/***/ "./src/validator.js":
/*!**************************!*\
  !*** ./src/validator.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Validator\": () => (/* binding */ Validator)\n/* harmony export */ });\nclass Validator {\n  static unique(field) {\n    return (value, data) => data.every(item => item[field] !== value[field]);\n  }\n\n  static length(field, [min, max]) {\n    return value => value[field].length >= min && value[field].length <= max;\n  }\n\n  static minLength(field, min) {\n    return value => value[field].length >= min;\n  }\n\n  static maxLength(field, max) {\n    return value => value[field].length <= max;\n  }\n\n  static range(field, [min, max]) {\n    return value => value[field] >= min && value[field] <= max;\n  }\n\n  static min(field, min) {\n    return value => value[field] >= min;\n  }\n\n  static max(field, max) {\n    return value => value[field] <= max;\n  }\n\n  static integer(field) {\n    return value => Number.isInteger(value[field]);\n  }\n\n  static regex(field, regex) {\n    return value => regex.test(value[field]);\n  }\n\n  static uniqueValues(field) {\n    return value => new Set(value[field]).size === value[field].length;\n  }\n\n  static sortedAscending(field) {\n    return value => value[field].every((item, index) => index === 0 || item >= value[field][index - 1]);\n  }\n\n  static sortedDescending(field) {\n    return value => value[field].every((item, index) => index === 0 || item <= value[field][index - 1]);\n  }\n\n  static custom(field, fn) {\n    return (value, data) => fn(value[field], data.map(item => item[field]));\n  }\n\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/validator.js?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});