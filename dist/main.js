!function(root,factory){"object"==typeof exports&&"object"==typeof module?module.exports=factory():"function"==typeof define&&define.amd?define([],factory):"object"==typeof exports?exports["@jsiqle/core"]=factory():root["@jsiqle/core"]=factory()}(global,(()=>(()=>{"use strict";var __webpack_require__={d:(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})},o:(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),r:exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})}},__webpack_exports__={};__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>src});const isBoolean=val=>"boolean"==typeof val,isNumber=val=>"number"==typeof val&&val==val,isString=val=>"string"==typeof val,isDate=val=>val instanceof Date,and=(...types)=>val=>types.every((type=>type(val))),isArrayOf=type=>val=>Array.isArray(val)&&val.every(type),isNull=val=>null===val,standardTypes={boolean:{type:isBoolean},number:{type:isNumber},string:{type:isString},date:{type:isDate},booleanArray:{type:isArrayOf(isBoolean)},numberArray:{type:isArrayOf(isNumber)},stringArray:{type:isArrayOf(isString)},dateArray:{type:isArrayOf(isDate)},object:{type:val=>"object"==typeof val}},recordId=and(isString,(val=>0!==val.trim().length)),recordIdArray=and(isArrayOf(recordId),(arr=>new Set(arr).size===arr.length)),symbols=((...str)=>str.reduce(((acc,curr)=>(acc[`$${curr}`]=Symbol.for(curr),acc)),{}))("fields","properties","cachedProperties","methods","scopes","relationships","relationshipField","recordModel","recordValue","wrappedRecordValue","recordHandler","recordTag","emptyRecordTemplate","addScope","addRelationshipAsField","addRelationshipAsProperty","getField","getProperty","isDateField","instances","isRecord","groupTag","set","delete","get","handleExperimentalAPIMessage","clearSchemaForTesting","clearCachedProperties","clearRecordSetForTesting","schemaObject"),{$isDateField}=symbols;class Field{#name;#type;#isDateField=!1;constructor({name,type}){this.#name=name,this.#type=(type=>val=>((...types)=>val=>types.some((type=>type(val))))(isNull,type)(val))(type)}get name(){return this.#name}typeCheck(value){return this.#type(value)}get[$isDateField](){return this.#isDateField}set[$isDateField](value){this.#isDateField=value}}Object.entries(standardTypes).forEach((([typeName,standardType])=>{const{type}=standardType;Field[typeName]="date"===typeName?name=>{const field=new Field({name,type});return field[$isDateField]=!0,field}:name=>new Field({name,type})}));const{$recordValue,$wrappedRecordValue,$recordHandler,$recordModel,$recordTag,$cachedProperties}=symbols;class Record{#recordValue;#recordHandler;#proxiedRecord;#cachedProperties;constructor(value,handler){return this.#recordValue=value,this.#recordHandler=handler,this.#cachedProperties=new Map,this.#proxiedRecord=new Proxy(this,this.#recordHandler),this.#proxiedRecord}get[$cachedProperties](){return this.#cachedProperties}get[$recordHandler](){return this.#recordHandler}get[$recordValue](){return this.#recordValue}get[$wrappedRecordValue](){return this.#proxiedRecord}get[$recordModel](){return this.#recordHandler.model}get[$recordTag](){return`${this[$recordModel].name}#${this[$recordValue].id}`}get[Symbol.toStringTag](){return this[$recordTag]}}const record=Record;class NameError extends Error{constructor(message){super(message),this.name="NameError"}}class DuplicationError extends Error{constructor(message){super(message),this.name="DuplicationError"}}class ExperimentalAPIUsageError extends Error{constructor(message){super(message),this.name="ExperimentalAPIUsageError"}}const restrictedNames=["toString","toObject","toJSON","id"],validateName=name=>{const[isValid,message]=(name=>"string"!=typeof name?[!1,"must be a string"]:name?/^\d/.test(name)?[!1,"cannot start with a number"]:restrictedNames.includes(name)?[!1,"is reserved"]:[/^\w+$/.test(name),"must contain only alphanumeric characters, numbers or underscores"]:[!1,"cannot be empty"])(name);if(!isValid)throw new NameError(`Name "${name}" is invalid - ${message}.`);return name},reverseCapitalize=([first,...rest])=>first.toLowerCase()+rest.join(""),deepClone=obj=>{if("object"!=typeof obj)return obj;if(null===obj)return null;if(obj instanceof Date)return new Date(obj);let clone=Object.assign({},obj);return Object.entries(clone).forEach((([key,value])=>clone[key]="object"==typeof obj[key]?deepClone(value):value)),Array.isArray(obj)?(clone.length=obj.length,Array.from(clone)):clone},validateObjectWithUniqueName=({objectType,parentType,parentName},obj,collection)=>{if(!(obj=>obj&&"object"==typeof obj)(obj))throw new TypeError(`${objectType} ${obj} is not an object.`);if(collection.includes(obj.name)){throw new DuplicationError(`${parentName?`${parentType} ${parentName}`:parentType} already has a ${objectType.toLowerCase()} named ${obj.name}.`)}return!0},{$fields,$properties,$cachedProperties:handler_$cachedProperties,$methods,$relationships,$recordValue:handler_$recordValue,$wrappedRecordValue:handler_$wrappedRecordValue,$emptyRecordTemplate,$recordModel:handler_$recordModel,$recordTag:handler_$recordTag,$isRecord,$isDateField:handler_$isDateField,$get,$schemaObject}=symbols;class RecordHandler{#model;constructor(model){this.#model=model}get model(){return this.#model}createRecord(recordData){if(!recordData)throw new TypeError("Record data cannot be empty.");if("object"!=typeof recordData)throw new TypeError("Record data must be an object.");const modelName=this.#getModelName(),newRecordId=RecordHandler.#validateNewRecordId(modelName,recordData.id,this.#model.records),newRecord=new record({id:newRecordId,...this.#getEmptyRecordTemplate()},this);return this.#getFieldNames().forEach((field=>{void 0!==recordData[field]&&this.set(newRecord,field,deepClone(recordData[field]),newRecord)})),[newRecordId,newRecord]}get(record,property){return this.#hasRelationshipField(property)?this.#getRelationship(record,property):this.#isRecordId(property)||this.#hasField(property)?this.#getFieldValue(record,property):this.#hasProperty(property)?this.#getProperty(record,property):this.#hasMethod(property)?this.#getMethod(record,property):this.#isCallToSerialize(property)?RecordHandler.#recordToObject(record,this.#model,this):this.#isCallToString(property)?()=>this.getRecordId(record):this.#isKnownSymbol(property)?this.#getKnownSymbol(record,property):void 0}set(record,property,value){const recordId=this.getRecordId(record);if(this.#hasProperty(property))throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set property ${property}.`);if(this.#hasMethod(property))throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set method ${property}.`);if(this.#hasField(property)){const field=this.#getField(property);RecordHandler.#setRecordField(this.#model.name,record,field,value,this.#hasRelationshipField(property))}return!0}static#setRecordField(modelName,record,field,value,isRelationship){const recordValue=isRelationship||void 0!==value?field[handler_$isDateField]?new Date(value):value:null;if(!isRelationship&&!field.typeCheck(recordValue))throw new TypeError(`${modelName} record has invalid value for field ${field.name}.`);record[handler_$wrappedRecordValue]&&record[handler_$cachedProperties].clear(),record[handler_$recordValue][field.name]=recordValue}static#recordToObject(record,model){const recordValue=record[handler_$recordValue],fields=model[$fields],object={id:recordValue.id};return fields.forEach((field=>{void 0!==recordValue[field.name]&&(object[field.name]=recordValue[field.name])})),()=>object}static#validateNewRecordId=(modelName,id,records)=>{let newRecordId=id;if(!recordId(newRecordId))throw new TypeError(`${modelName} record has invalid id.`);if(records.has(newRecordId))throw new DuplicationError(`${modelName} record with id ${newRecordId} already exists.`);return newRecordId};#getModelName(){return this.#model.name}#getFieldNames(){return[...this.#model[$fields].keys()]}#getEmptyRecordTemplate(){return this.#model[$emptyRecordTemplate]}#isRecordId(property){return"id"===property}getRecordId(record){return record[handler_$recordValue].id}#hasField(property){return this.#model[$fields].has(property)}#getField(property){return this.#model[$fields].get(property)}#getFieldValue(record,property){return record[handler_$recordValue][property]}#hasProperty(property){return this.#model[$properties].has(property)}#getProperty(record,property){if(this.#model[handler_$cachedProperties].has(property)){if(record[handler_$cachedProperties]&&record[handler_$cachedProperties].has(property))return record[handler_$cachedProperties].get(property);const value=this.#model[$properties].get(property)(record[handler_$wrappedRecordValue],schema[$schemaObject]);return record[handler_$cachedProperties].set(property,value),value}return this.#model[$properties].get(property)(record[handler_$wrappedRecordValue],schema[$schemaObject])}#hasMethod(method){return this.#model[$methods].has(method)}#getMethod(record,method){const methodFn=this.#model[$methods].get(method);return(...args)=>methodFn(record[handler_$wrappedRecordValue],...args,schema[$schemaObject])}#hasRelationshipField(property){return!!this.#hasField(property)&&this.#model[$relationships].has(`${property}.${property}`)}#getRelationship(record,property){return this.#model[$relationships].get(`${property}.${property}`)[$get](this.#getModelName(),property,record[handler_$recordValue])}#isCallToSerialize(property){return"toObject"===property||"toJSON"===property}#isCallToString(property){return"toString"===property}#isKnownSymbol(property){return[handler_$recordModel,handler_$recordTag,handler_$recordValue,$isRecord].includes(property)}#getKnownSymbol(record,property){return property===$isRecord||record[property]}}const handler=RecordHandler,{$scopes,$addScope,$isRecord:set_$isRecord,$set,$delete,$clearRecordSetForTesting}=symbols;class RecordSet extends Map{#model;constructor({iterable=[],model=null}={}){if(super(),!model)throw new TypeError("Model cannot be empty.");this.#model=model;for(const[id,value]of iterable)this[$set](id,value);this.#copyScopesFromModel()}set(){throw new TypeError("You cannot directly modify a RecordSet. Please use `Model.prototype.createRecord()` instead.")}delete(){throw new TypeError("You cannot directly modify a RecordSet. Please use `Model.prototype.deleteRecord()` instead.")}clear(){throw new TypeError("You cannot directly modify a RecordSet Please use `Model.prototype.deleteRecord()` instead.")}map(callbackFn,{flat=!1}={}){return flat?[...this.entries()].map((([id,value])=>callbackFn(value,id,this))):[...this.entries()].reduce(((newMap,[id,value])=>(newMap[id]=callbackFn(value,id,this),newMap)),{})}reduce(callbackFn,initialValue){return[...this.entries()].reduce(((acc,[id,value])=>callbackFn(acc,value,id,this)),initialValue)}filter(callbackFn,{flat=!1}={}){return flat?[...this.entries()].reduce(((arr,[id,value])=>(callbackFn(value,id,this)&&arr.push(value),arr)),[]):[...this.entries()].reduce(((newRecordSet,[id,record])=>(callbackFn(record,id,this)&&newRecordSet[$set](id,record),newRecordSet)),new RecordSet({model:this.#model}))}find(callbackFn){for(const[id,record]of this)if(callbackFn(record,id,this))return record}findId(callbackFn){for(const[id,value]of this)if(callbackFn(value,id,this))return id}only(...ids){return ids.reduce(((newRecordSet,id)=>(this.has(id)&&newRecordSet[$set](id,this.get(id)),newRecordSet)),new RecordSet({model:this.#model}))}except(...ids){const newRecordSet=new RecordSet({model:this.#model});for(const[id,record]of this)ids.includes(id)||newRecordSet[$set](id,record);return newRecordSet}sort(comparatorFn){const newRecordSet=new RecordSet({model:this.#model}),sorted=[...this.entries()].sort((([id1,value1],[id2,value2])=>comparatorFn(value1,value2,id1,id2)));for(const[id,record]of sorted)newRecordSet[$set](id,record);return newRecordSet}every(callbackFn){return 0===this.size||[...this.entries()].every((([id,value])=>callbackFn(value,id,this)))}some(callbackFn){return 0!==this.size&&[...this.entries()].some((([id,value])=>callbackFn(value,id,this)))}select(...keys){return[...this.values()].map((value=>keys.reduce(((obj,key)=>({...obj,[key]:value[key]})),{})))}pluck(...keys){if(1===keys.length){const key=keys[0];return"id"===key?[...this.ids()]:[...this.values()].map((value=>value[key]))}return[...this.values()].map((value=>keys.map((key=>value[key]))))}groupBy(key){const res={};for(const[id,record]of this){let keyValue=record[key];null!=keyValue&&keyValue[set_$isRecord]&&(keyValue=record[key].id),res[keyValue]||(res[keyValue]=new RecordSet({model:this.#model})),res[keyValue][$set](id,record)}return res}where(callbackFn){return this.filter(callbackFn)}whereNot(callbackFn){return this.filter(((value,id,map)=>!callbackFn(value,id,map)))}*batchIterator(batchSize,{flat=!1}={}){if(flat){let batch=[];for(const[id,record]of this)batch.push(flat?record:[id,record]),batch.length===batchSize&&(yield batch,batch=[]);batch.length&&(yield batch)}else{let newRecordSet=new RecordSet({model:this.#model});for(const[id,record]of this)newRecordSet[$set](id,record),newRecordSet.size===batchSize&&(yield newRecordSet,newRecordSet=new RecordSet({model:this.#model}));newRecordSet.size&&(yield newRecordSet)}}limit(n){const newRecordSet=new RecordSet({model:this.#model});for(const[id,record]of this)if(newRecordSet[$set](id,record),newRecordSet.size===n)break;return newRecordSet}offset(n){const newRecordSet=new RecordSet({model:this.#model});let counter=0;for(const[id,record]of this)counter<n?counter++:newRecordSet[$set](id,record);return newRecordSet}slice(start,end){return[...this.entries()].slice(start,end).reduce(((newRecordSet,[id,record])=>(newRecordSet[$set](id,record),newRecordSet)),new RecordSet({model:this.#model}))}get first(){for(const[,record]of this)return record}get last(){if(0!==this.size)return[...this.entries()].pop()[1]}get count(){return this.size}get length(){return this.size}get ids(){return this.keys}toArray({flat=!1}={}){const values=[...this.values()];return flat?values.map((value=>value.toObject())):values}toObject({flat=!1}={}){return flat?[...this.entries()].reduce(((obj,[id,value])=>(obj[id]=value.toObject(),obj)),{}):[...this.entries()].reduce(((obj,[id,value])=>(obj[id]=value,obj)),{})}toJSON(){return this.toObject()}get[Symbol.toStringTag](){return this.#model.name}static get[Symbol.species](){return Map}[$set](id,value){return super.set(id,value),this}[$delete](id){return super.delete(id),this}[$addScope](name){Object.defineProperty(this,name,{configurable:!1,get:()=>this.#scopedWhere(name)})}[$clearRecordSetForTesting](){super.clear()}#copyScopesFromModel(){this.#model[$scopes].forEach(((scope,name)=>{this[name]||Object.defineProperty(this,name,{configurable:!1,get:()=>this.#scopedWhere(name)})}))}#scopedWhere(scopeName){const[matcherFn,comparatorFn]=this.#model[$scopes].get(scopeName),newRecordSet=new RecordSet({model:this.#model});if(comparatorFn){let matches=[];for(const[id,record]of this)matcherFn(record,id,this)&&matches.push([id,record]);comparatorFn&&matches.sort((([id1,value1],[id2,value2])=>comparatorFn(value1,value2,id1,id2)));for(const[id,record]of matches)newRecordSet[$set](id,record)}else for(const[id,record]of this)matcherFn(record,id,this)&&newRecordSet[$set](id,record);return newRecordSet}}const set=RecordSet,{$fields:model_$fields,$properties:model_$properties,$cachedProperties:model_$cachedProperties,$clearCachedProperties,$methods:model_$methods,$relationships:model_$relationships,$scopes:model_$scopes,$recordHandler:model_$recordHandler,$emptyRecordTemplate:model_$emptyRecordTemplate,$addScope:model_$addScope,$addRelationshipAsField,$addRelationshipAsProperty,$getField,$getProperty,$instances,$set:model_$set,$delete:model_$delete}=symbols,allStandardTypes=Object.keys(standardTypes);class Model{#records;#recordHandler;#fields;#properties;#methods;#relationships;#cachedProperties;#scopes;#emptyRecordTemplate;static#instances=new Map;constructor({name,fields={},properties={},methods={},scopes={}}={}){if(this.name=name,Model.#instances.has(name))throw new DuplicationError(`A model named ${name} already exists.`);this.#scopes=new Map,this.#records=new set({model:this}),this.#recordHandler=new handler(this),this.#fields=new Map,this.#properties=new Map,this.#methods=new Map,this.#relationships=new Map,this.#cachedProperties=new Set,Object.entries(fields).forEach((([fieldName,fieldType])=>{this.#addField(fieldType,fieldName)})),this.#emptyRecordTemplate=this.#generateEmptyRecordTemplate(),Object.entries(properties).forEach((([propertyName,property])=>{"object"==typeof property?this.#addProperty({name:propertyName,...property}):this.#addProperty({name:propertyName,body:property})})),Object.entries(methods).forEach((([methodName,method])=>{this.#addMethod(methodName,method)})),Object.entries(scopes).forEach((([scopeName,scope])=>{this.#addScope(scopeName,...Model.#parseScope(scope))})),Model.#instances.set(this.name,this)}createRecord(record){const[newRecordId,newRecord]=this.#recordHandler.createRecord(record);return this.#records[model_$set](newRecordId,newRecord),newRecord}removeRecord(recordId){return this.#records.has(recordId)?(this.#records[model_$delete](recordId),!0):(console.warn(`Record ${recordId} does not exist.`),!1)}updateRecord(recordId,record){if("object"!=typeof record)throw new TypeError("Record data must be an object.");if(!this.#records.has(recordId))throw new ReferenceError(`Record ${recordId} does not exist.`);const oldRecord=this.#records.get(recordId);return Object.entries(record).forEach((([fieldName,fieldValue])=>{oldRecord[fieldName]=fieldValue})),oldRecord}get records(){return this.#records}static get[$instances](){return Model.#instances}get[model_$recordHandler](){return this.#recordHandler}get[model_$fields](){return this.#fields}get[model_$properties](){return this.#properties}get[model_$cachedProperties](){return this.#cachedProperties}get[model_$methods](){return this.#methods}get[model_$relationships](){return this.#relationships}get[model_$scopes](){return this.#scopes}get[model_$emptyRecordTemplate](){return this.#emptyRecordTemplate}[$addRelationshipAsField](relationship){const{name,fieldName,field}=relationship[$getField](),relationshipName=`${name}.${fieldName}`;if(["id",...this.#fields.keys(),...this.#properties.keys(),...this.#methods.keys()].includes(fieldName))throw new NameError(`Relationship field ${fieldName} is already in use.`);if(this.#relationships.has(relationshipName))throw new NameError(`Relationship ${relationshipName} is already in use.`);this.#fields.set(fieldName,field),this.#relationships.set(relationshipName,relationship),this.#emptyRecordTemplate[fieldName]=void 0}[$addRelationshipAsProperty](relationship){const{name,propertyName,property}=relationship[$getProperty](),relationshipName=`${name}.${propertyName}`;if(["id",...this.#fields.keys(),...this.#properties.keys(),...this.#methods.keys()].includes(propertyName))throw new NameError(`Relationship property ${propertyName} is already in use.`);if(this.#relationships.has(relationshipName))throw new NameError(`Relationship ${name} is already in use.`);this.#properties.set(propertyName,property),this.#relationships.set(relationshipName,relationship)}[$clearCachedProperties](){this.#cachedProperties.clear()}#addField(type,name){const isStandardType=allStandardTypes.includes(type);if("string"!=typeof type||!isStandardType)throw new TypeError(`Field ${name} is not a standard type.`);this.#fields.set(name,Field[type](name))}#addProperty({name,body,cache=!1,inverse=null}){if("function"!=typeof body)throw new TypeError(`Property ${name} is not a function.`);this.#properties.set(name,body);const hasInverse="string"==typeof inverse&&inverse.length>0;if(hasInverse){if(this.#properties.has(inverse))throw new NameError(`Property ${inverse} is already in use.`);const inverseBody=(...args)=>!body(...args);this.#properties.set(inverse,inverseBody)}cache&&(this.#cachedProperties.add(name),hasInverse&&this.#cachedProperties.add(inverse))}#addMethod(name,method){if("function"!=typeof method)throw new TypeError(`Method ${name} is not a function.`);this.#methods.set(name,method)}#addScope(name,scope,sortFn){if("function"!=typeof scope)throw new TypeError(`Scope ${name} is not a function.`);if(sortFn&&"function"!=typeof sortFn)throw new TypeError(`Scope ${name} comparator function is not a function.`);const scopeName=validateName(name);if(this.#records[scopeName]||Object.getOwnPropertyNames(set.prototype).includes(scopeName))throw new NameError(`Scope name ${scopeName} is already in use.`);this.#scopes.set(name,[scope,sortFn]),this.#records[model_$addScope](scopeName)}#generateEmptyRecordTemplate(){const emptyRecordTemplate={};return this.#fields.forEach((field=>{emptyRecordTemplate[field.name]=null})),emptyRecordTemplate}static#parseScope(scope){if("function"==typeof scope)return[scope];if("object"==typeof scope){const{matcher,sorter}=scope;if("function"!=typeof matcher)throw new TypeError("The provided matcher for the scope is not a function.");if(sorter&&"function"!=typeof sorter)throw new TypeError("The provided sorter for the scope is not a function.");return[matcher,sorter]}throw new TypeError("The provided scope is not a function or valid object.")}}const{$recordValue:relationship_$recordValue,$fields:relationship_$fields,$getField:relationship_$getField,$getProperty:relationship_$getProperty,$get:relationship_$get,$instances:relationship_$instances,$handleExperimentalAPIMessage}=symbols,relationshipEnum={oneToOne:"oneToOne",oneToMany:"oneToMany",manyToOne:"manyToOne",manyToMany:"manyToMany"};class Relationship{#type;#from;#to;#name;#reverseName;#relationshipField;#relationshipProperty;constructor({from,to,type}={}){Schema[$handleExperimentalAPIMessage]("Relationships are experimental in the current version. There is neither validation of existence in foreign tables nor guarantee that associations work. Please use with caution."),this.#type=Relationship.#validateType(type);const[fromModel,fromName,toModel,toName]=Relationship.#parseModelsAndNames(from,to,type);if(this.#from=fromModel,this.#to=toModel,this.#name=fromName,this.#reverseName=toName,this.#to===this.#from&&Relationship.#isSymmetric(this.#type)&&this.#name===this.#reverseName)throw new RangeError("Relationship cannot be symmetric if the from and to models are the same and no name is provided for either one.");this.#relationshipField=Relationship.#createField(this.#name,this.#type),this.#relationshipProperty=record=>this.#getAssociatedRecordsReverse(record)}[relationship_$getField](){return{name:this.#name,type:this.#type,fieldName:this.#name,field:this.#relationshipField}}[relationship_$getProperty](){return{name:this.#name,type:this.#type,propertyName:this.#reverseName,property:this.#relationshipProperty}}[relationship_$get](modelName,property,record){return modelName===this.#from.name&&property===this.#name?this.#getAssociatedRecords(record):modelName===this.#to.name&&property===this.#reverseName?(console.warn("Relationship getter called by the receiver model. This might indicate an issue with the library and should be reported."),this.#getAssociatedRecordsReverse(record)):void 0}#getAssociatedRecords(record){if(Relationship.#isToOne(this.#type)){const associationValue=record[this.#name];return this.#to.records.get(associationValue)}const associationValues=record[this.#name]||[];return this.#to.records.only(...associationValues)}#getAssociatedRecordsReverse(record){const associationValue=record.id,matcher=Relationship.#isToOne(this.#type)?associatedRecord=>associatedRecord[relationship_$recordValue][this.#name]===associationValue:associatedRecord=>{const associatedRecordValue=associatedRecord[relationship_$recordValue][this.#name];return![void 0,null].includes(associatedRecordValue)&&associatedRecord[relationship_$recordValue][this.#name].includes(associationValue)};return Relationship.#isFromOne(this.#type)?this.#from.records.find(matcher):this.#from.records.where(matcher)}static#isToOne(type){return[relationshipEnum.oneToOne,relationshipEnum.manyToOne].includes(type)}static#isToMany(type){return[relationshipEnum.oneToMany,relationshipEnum.manyToMany].includes(type)}static#isFromOne(type){return[relationshipEnum.oneToMany,relationshipEnum.oneToOne].includes(type)}static#isFromMany(type){return[relationshipEnum.manyToOne,relationshipEnum.manyToMany].includes(type)}static#isSymmetric(type){return[relationshipEnum.oneToOne,relationshipEnum.manyToMany].includes(type)}static#createField(name,relationshipType){const isMultiple=Relationship.#isToMany(relationshipType);return new Field({name,type:isMultiple?recordIdArray:recordId})}static#validateType(relationshipType){if(!Object.values(relationshipEnum).includes(relationshipType))throw new TypeError(`Invalid relationship type: ${relationshipType}.`);return relationshipType}static#validateModel(modelData){const modelName="string"==typeof modelData?modelData:modelData.model;if(!Model[relationship_$instances].has(modelName))throw new ReferenceError(`Model ${modelName} does not exist.`);return Model[relationship_$instances].get(modelName)}static#createName(type,to){return Relationship.#isToOne(type)?reverseCapitalize(to):Relationship.#isToMany(type)?`${reverseCapitalize(to)}Set`:void 0}static#createReverseName=(type,from)=>Relationship.#isFromOne(type)?reverseCapitalize(from):Relationship.#isFromMany(type)?`${reverseCapitalize(from)}Set`:void 0;static#validateModelParams(modelData){const model=Relationship.#validateModel(modelData),name="string"==typeof modelData?null:validateName(modelData.name);if(null!==name&&model[relationship_$fields].has(name))throw new DuplicationError(`Field ${name} already exists in ${model.name}.`);return[model,name]}static#parseModelsAndNames(from,to,type){let fromModel,fromName,toModel,toName;return[fromModel,fromName]=Relationship.#validateModelParams(from),[toModel,toName]=Relationship.#validateModelParams(to),null===fromName&&(fromName=Relationship.#createName(type,toModel.name)),null===toName&&(toName=Relationship.#createReverseName(type,fromModel.name)),[fromModel,fromName,toModel,toName]}}class Serializer{#name;#attributes;#methods;constructor({name,attributes=[],methods={}}){this.#name=name,this.#attributes=new Map,this.#methods=new Map,attributes.forEach((attribute=>{const[attributeValue,attributeName]="string"==typeof attribute?[attribute,attribute]:attribute;this.#attributes.set(Serializer.#validateAttribute(attributeName,[...this.#attributes.keys()]),attributeValue)})),Object.entries(methods).forEach((([methodName,methodBody])=>{this.#addMethod(methodName,methodBody)}))}serialize(object,options){const serialized={};return this.#attributes.forEach(((attributeValue,attributeName)=>{const value=this.#methods.has(attributeValue)?this.#methods.get(attributeValue)(object,options):object[attributeValue];void 0!==value&&(serialized[attributeName]=value)})),serialized}serializeArray(objects,options){return objects.map((object=>this.serialize(object,options)))}serializeRecordSet(objects,options,keyMapFn){const serialized={};return objects.forEach(((value,key)=>{const mappedKey=keyMapFn(key,value);void 0!==mappedKey&&(serialized[mappedKey]=this.serialize(value,options))})),serialized}get name(){return this.#name}#addMethod(methodName,methodBody){const method=Serializer.#validateFunction(methodName,methodBody,[...this.#methods.keys()]);this.#methods.set(methodName,method)}static#validateAttribute(attributeName,restrictedNames){if("string"!=typeof attributeName)throw new TypeError(`Attribute ${attributeName} is not a string.`);if(restrictedNames.includes(attributeName))throw new DuplicationError(`Attribute ${attributeName} already exists.`);return attributeName}static#validateFunction(callbackName,callback,restrictedNames){if("function"!=typeof callback)throw new TypeError(`Method ${callbackName} is not a function.`);if(restrictedNames.includes(callbackName))throw new DuplicationError(`Method ${callbackName} already exists.`);return callback}}const{$addRelationshipAsField:schema_$addRelationshipAsField,$addRelationshipAsProperty:schema_$addRelationshipAsProperty,$handleExperimentalAPIMessage:schema_$handleExperimentalAPIMessage,$clearCachedProperties:schema_$clearCachedProperties,$clearSchemaForTesting,$schemaObject:schema_$schemaObject}=symbols;class Schema{static#models=new Map;static#serializers=new Map;static#schemaObject={};static#instantiated=!1;static defaultConfig={experimentalAPIMessages:"warn"};static config={...Schema.defaultConfig};static create({models=[],relationships=[],serializers=[],config={}}={}){if(Schema.#instantiated)throw new Error("Only one schema can be created.");return Schema.#parseConfig(config),models.forEach((modelData=>{const{fields={},properties={},methods={}}=modelData,names=[...Object.keys(fields),...Object.keys(properties),...Object.keys(methods)];if(new Set(names).size!==names.length)throw new Error(`Model ${modelData.name} has duplicate field, property or method names.`);names.forEach((name=>validateName(name))),Schema.#createModel(modelData)})),relationships.forEach((relationship=>Schema.#createRelationship(relationship))),serializers.forEach((serializer=>Schema.#createSerializer(serializer))),Schema.#schemaObject={models:Object.fromEntries([...Schema.#models.entries()]),serializers:Object.fromEntries([...Schema.#serializers.entries()])},Schema.#instantiated=!0,Schema}static clearPropertyCache(){return Schema[schema_$handleExperimentalAPIMessage]("Clearing the property cache of all models should only be done if something is known to have caused the cache to contain stale data. Please use with caution."),Schema.#models.forEach((model=>model[schema_$clearCachedProperties]())),Schema}static getModel(name){return Schema.#models.get(name)}static getSerializer(name){return Schema.#serializers.get(name)}static get models(){return Schema.#models}static get[schema_$schemaObject](){return Schema.#schemaObject}static get(pathName){const[modelName,recordId,...rest]=pathName.split("."),model=Schema.getModel(modelName);if(!model)throw new ReferenceError(`Model ${modelName} does not exist in the schema.`);if(void 0===recordId)return model;const record=model.records.get(recordId);if(!rest.length)return record;if(!record)throw new ReferenceError(`Record ${recordId} does not exist in model ${modelName}.`);return rest.reduce(((acc,key)=>acc[key]),record)}static[schema_$handleExperimentalAPIMessage](message){const{experimentalAPIMessages}=Schema.config;if("warn"===experimentalAPIMessages)console.warn(message);else if("error"===experimentalAPIMessages)throw new ExperimentalAPIUsageError(message)}static[$clearSchemaForTesting](){Schema.#models.clear(),Schema.#serializers.clear(),Schema.#schemaObject={},Schema.#instantiated=!1}static#createModel(modelData){const modelName=validateName(modelData.name);validateObjectWithUniqueName({objectType:"Model",parentType:"Schema"},modelData,[...Schema.#models.keys()]);const model=new Model(modelData);Schema.#models.set(modelName,model)}static#createSerializer(serializerData){const serializerName=validateName(serializerData.name);validateObjectWithUniqueName({objectType:"Serializer",parentType:"Schema"},serializerData,[...Schema.#serializers.keys()]);const serializer=new Serializer(serializerData);Schema.#serializers.set(serializerName,serializer)}static#createRelationship(relationshipData){const{from,to,type}=relationshipData;[from,to].forEach((model=>{if(!["string","object"].includes(typeof model))throw new TypeError(`Invalid relationship model: ${model}.`)}));const fromModelName="string"==typeof from?from:from.model,toModelName="string"==typeof to?to:to.model,fromModel=Schema.#models.get(fromModelName),toModel=Schema.#models.get(toModelName);if(!fromModel)throw new ReferenceError(`Model ${fromModelName} not found in schema when attempting to create a relationship.`);if(!toModel)throw new ReferenceError(`Model ${toModelName} not found in schema when attempting to create a relationship.`);const relationship=new Relationship({from,to,type});fromModel[schema_$addRelationshipAsField](relationship),toModel[schema_$addRelationshipAsProperty](relationship)}static#parseConfig(config={}){config&&["experimentalAPIMessages"].forEach((key=>{void 0!==config[key]&&["warn","error","off"].includes(config[key])&&(Schema.config[key]=config[key])}))}}const schema=Schema,src=Schema;return __webpack_exports__})()));