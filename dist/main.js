/*! For license information please see main.js.LICENSE.txt */
!function(root,factory){"object"==typeof exports&&"object"==typeof module?module.exports=factory():"function"==typeof define&&define.amd?define([],factory):"object"==typeof exports?exports["@jsiqle/core"]=factory():root["@jsiqle/core"]=factory()}(global,(()=>(()=>{"use strict";var __webpack_modules__={"./src/errors.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DuplicationError: () => (/* binding */ DuplicationError),\n/* harmony export */   ExperimentalAPIUsageError: () => (/* binding */ ExperimentalAPIUsageError),\n/* harmony export */   NameError: () => (/* binding */ NameError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError)\n/* harmony export */ });\nclass NameError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NameError';\n  }\n}\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\nclass DuplicationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'DuplicationError';\n  }\n}\nclass ExperimentalAPIUsageError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ExperimentalAPIUsageError';\n  }\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/errors.js?")},"./src/field.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./src/types.js");\n\nclass Field {\n  #name;\n  #type;\n  constructor({\n    name,\n    type\n  }) {\n    this.#name = name;\n    this.#type = (0,_types__WEBPACK_IMPORTED_MODULE_0__.isOptional)(type);\n  }\n  get name() {\n    return this.#name;\n  }\n  typeCheck(value) {\n    return this.#type(value);\n  }\n}\n\n// Create convenience static methods on the Field class\nObject.entries(_types__WEBPACK_IMPORTED_MODULE_0__.standardTypes).forEach(([typeName, standardType]) => {\n  const {\n    type\n  } = standardType;\n  Field[typeName] = name => new Field({\n    name,\n    type\n  });\n});\n\n\n//# sourceURL=webpack://@jsiqle/core/./src/field.js?')},"./src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema */ "./src/schema.js");\n\n\n// This is the public API, be extra careful not to add anything internal here.\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_schema__WEBPACK_IMPORTED_MODULE_0__.Schema);\n\n//# sourceURL=webpack://@jsiqle/core/./src/index.js?')},"./src/model.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./field */ \"./src/field.js\");\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./record */ \"./src/record/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"./src/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n\n\n\n\nconst {\n  $fields,\n  $properties,\n  $cachedProperties,\n  $clearCachedProperties,\n  $methods,\n  $relationships,\n  $scopes,\n  $recordHandler,\n  $emptyRecordTemplate,\n  $addScope,\n  $addRelationshipAsField,\n  $addRelationshipAsProperty,\n  $getField,\n  $getProperty,\n  $instances,\n  $set,\n  $delete\n} = _symbols__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\nconst allStandardTypes = Object.keys(_types__WEBPACK_IMPORTED_MODULE_4__.standardTypes);\nclass Model {\n  #records;\n  #recordHandler;\n  #fields;\n  #properties;\n  #methods;\n  #relationships;\n  #cachedProperties;\n  #scopes;\n  #emptyRecordTemplate;\n  static #instances = new Map();\n  constructor({\n    name,\n    fields = {},\n    properties = {},\n    methods = {},\n    scopes = {}\n  } = {}) {\n    this.name = name;\n    if (Model.#instances.has(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.DuplicationError(`A model named ${name} already exists.`);\n\n    // Instantiate this before the record storage, so it can be\n    // queried if needed.\n    this.#scopes = new Map();\n\n    // Create the record storage and handler\n    this.#records = new _record__WEBPACK_IMPORTED_MODULE_1__.RecordSet({\n      model: this\n    });\n    this.#recordHandler = new _record__WEBPACK_IMPORTED_MODULE_1__.RecordHandler(this);\n\n    // Initialize private fields\n    this.#fields = new Map();\n    this.#properties = new Map();\n    this.#methods = new Map();\n    this.#relationships = new Map();\n    this.#cachedProperties = new Set();\n\n    // Add fields, checking for duplicates and invalids\n    Object.entries(fields).forEach(([fieldName, fieldType]) => {\n      this.#addField(fieldType, fieldName);\n    });\n    this.#emptyRecordTemplate = this.#generateEmptyRecordTemplate();\n\n    // Add properties, checking for duplicates and invalids\n    Object.entries(properties).forEach(([propertyName, property]) => {\n      if (typeof property === 'object') this.#addProperty({\n        name: propertyName,\n        ...property\n      });else this.#addProperty({\n        name: propertyName,\n        body: property\n      });\n    });\n\n    // Add methods, checking for duplicates and invalids\n    Object.entries(methods).forEach(([methodName, method]) => {\n      this.#addMethod(methodName, method);\n    });\n\n    // Add scopes, checking for duplicates and invalids\n    Object.entries(scopes).forEach(([scopeName, scope]) => {\n      this.#addScope(scopeName, ...Model.#parseScope(scope));\n    });\n\n    // Add the model to the instances map\n    Model.#instances.set(this.name, this);\n  }\n  createRecord(record) {\n    const [newRecordId, newRecord] = this.#recordHandler.createRecord(record);\n    this.#records[$set](newRecordId, newRecord);\n    return newRecord;\n  }\n  removeRecord(recordId) {\n    if (!this.#records.has(recordId)) {\n      console.warn(`Record ${recordId} does not exist.`);\n      return false;\n    }\n    this.#records[$delete](recordId);\n    return true;\n  }\n  updateRecord(recordId, record) {\n    if (typeof record !== 'object') throw new TypeError('Record data must be an object.');\n    if (!this.#records.has(recordId)) throw new ReferenceError(`Record ${recordId} does not exist.`);\n    const oldRecord = this.#records.get(recordId);\n    Object.entries(record).forEach(([fieldName, fieldValue]) => {\n      oldRecord[fieldName] = fieldValue;\n    });\n    return oldRecord;\n  }\n  get records() {\n    return this.#records;\n  }\n\n  // Protected (package internal-use only)\n\n  static get [$instances]() {\n    return Model.#instances;\n  }\n  get [$recordHandler]() {\n    return this.#recordHandler;\n  }\n  get [$fields]() {\n    return this.#fields;\n  }\n  get [$properties]() {\n    return this.#properties;\n  }\n  get [$cachedProperties]() {\n    return this.#cachedProperties;\n  }\n  get [$methods]() {\n    return this.#methods;\n  }\n  get [$relationships]() {\n    return this.#relationships;\n  }\n  get [$scopes]() {\n    return this.#scopes;\n  }\n  get [$emptyRecordTemplate]() {\n    return this.#emptyRecordTemplate;\n  }\n  [$addRelationshipAsField](relationship) {\n    const {\n      name,\n      fieldName,\n      field\n    } = relationship[$getField]();\n    const relationshipName = `${name}.${fieldName}`;\n    if (['id', ...this.#fields.keys(), ...this.#properties.keys(), ...this.#methods.keys()].includes(fieldName)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.NameError(`Relationship field ${fieldName} is already in use.`);\n    if (this.#relationships.has(relationshipName)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.NameError(`Relationship ${relationshipName} is already in use.`);\n    this.#fields.set(fieldName, field);\n    this.#relationships.set(relationshipName, relationship);\n    this.#emptyRecordTemplate[fieldName] = undefined;\n  }\n  [$addRelationshipAsProperty](relationship) {\n    const {\n      name,\n      propertyName,\n      property\n    } = relationship[$getProperty]();\n    const relationshipName = `${name}.${propertyName}`;\n    if (['id', ...this.#fields.keys(), ...this.#properties.keys(), ...this.#methods.keys()].includes(propertyName)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.NameError(`Relationship property ${propertyName} is already in use.`);\n    if (this.#relationships.has(relationshipName)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.NameError(`Relationship ${name} is already in use.`);\n    this.#properties.set(propertyName, property);\n    this.#relationships.set(relationshipName, relationship);\n  }\n  [$clearCachedProperties]() {\n    this.#cachedProperties.clear();\n  }\n\n  // Private\n\n  #addField(type, name) {\n    const isStandardType = allStandardTypes.includes(type);\n    if (typeof type !== 'string' || !isStandardType) throw new TypeError(`Field ${name} is not a standard type.`);\n    this.#fields.set(name, _field__WEBPACK_IMPORTED_MODULE_0__.Field[type](name));\n  }\n  #addProperty({\n    name,\n    body,\n    cache = false\n  }) {\n    if (typeof body !== 'function') throw new TypeError(`Property ${name} is not a function.`);\n    this.#properties.set(name, body);\n    if (cache) this.#cachedProperties.add(name);\n  }\n  #addMethod(name, method) {\n    if (typeof method !== 'function') throw new TypeError(`Method ${name} is not a function.`);\n    this.#methods.set(name, method);\n  }\n  #addScope(name, scope, sortFn) {\n    if (typeof scope !== 'function') throw new TypeError(`Scope ${name} is not a function.`);\n    if (sortFn && typeof sortFn !== 'function') throw new TypeError(`Scope ${name} comparator function is not a function.`);\n    const scopeName = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.validateName)(name);\n    if (this.#records[scopeName] || Object.getOwnPropertyNames(_record__WEBPACK_IMPORTED_MODULE_1__.RecordSet.prototype).includes(scopeName)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.NameError(`Scope name ${scopeName} is already in use.`);\n    this.#scopes.set(name, [scope, sortFn]);\n    this.#records[$addScope](scopeName);\n  }\n  #generateEmptyRecordTemplate() {\n    const emptyRecordTemplate = {};\n    this.#fields.forEach(field => {\n      emptyRecordTemplate[field.name] = null;\n    });\n    return emptyRecordTemplate;\n  }\n  static #parseScope(scope) {\n    if (typeof scope === 'function') return [scope];\n    if (typeof scope === 'object') {\n      const {\n        matcher,\n        sorter\n      } = scope;\n      if (typeof matcher !== 'function') throw new TypeError(`The provided matcher for the scope is not a function.`);\n      if (sorter && typeof sorter !== 'function') throw new TypeError(`The provided sorter for the scope is not a function.`);\n      return [matcher, sorter];\n    }\n    throw new TypeError(`The provided scope is not a function or valid object.`);\n  }\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/model.js?")},"./src/record/handler.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./record */ "./src/record/record.js");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../schema */ "./src/schema.js");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors */ "./src/errors.js");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ "./src/types.js");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../symbols */ "./src/symbols.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils */ "./src/utils.js");\n\n\n\n\n\n\nconst {\n  $fields,\n  $properties,\n  $cachedProperties,\n  $methods,\n  $relationships,\n  $recordValue,\n  $wrappedRecordValue,\n  $emptyRecordTemplate,\n  $recordModel,\n  $recordTag,\n  $isRecord,\n  $get,\n  $schemaObject\n} = _symbols__WEBPACK_IMPORTED_MODULE_4__["default"];\nclass RecordHandler {\n  #model;\n  constructor(model) {\n    this.#model = model;\n  }\n  get model() {\n    return this.#model;\n  }\n  createRecord(recordData) {\n    if (!recordData) throw new TypeError(\'Record data cannot be empty.\');\n    if (typeof recordData !== \'object\') throw new TypeError(\'Record data must be an object.\');\n    const modelName = this.#getModelName();\n    // Validate record id\n    const newRecordId = RecordHandler.#validateNewRecordId(modelName, recordData.id, this.#model.records);\n\n    // Create a new record from the template with the new id\n    const newRecord = new _record__WEBPACK_IMPORTED_MODULE_0__["default"]({\n      id: newRecordId,\n      ...this.#getEmptyRecordTemplate()\n    }, this);\n\n    // Set fields and skip validation\n    this.#getFieldNames().forEach(field => {\n      if (recordData[field] === undefined) return;\n      this.set(newRecord, field, (0,_utils__WEBPACK_IMPORTED_MODULE_5__.deepClone)(recordData[field]), newRecord);\n    });\n    return [newRecordId, newRecord];\n  }\n\n  /*  ======  Trap definitions  ======  */\n\n  get(record, property) {\n    // Check relationships first to avoid matching them as fields\n    if (this.#hasRelationshipField(property)) return this.#getRelationship(record, property);\n    // Id or field, return as-is\n    if (this.#isRecordId(property) || this.#hasField(property)) return this.#getFieldValue(record, property);\n    // Property, get and call, this also matches relationship reverses (properties)\n    if (this.#hasProperty(property)) return this.#getProperty(record, property);\n    // Method, get and call\n    if (this.#hasMethod(property)) return this.#getMethod(record, property);\n    // Serialize method, call and return\n    if (this.#isCallToSerialize(property)) return RecordHandler.#recordToObject(record, this.#model, this);\n    // Call toString method, return key value\n    if (this.#isCallToString(property)) return () => this.getRecordId(record);\n    // Known symbol, handle as required\n    if (this.#isKnownSymbol(property)) return this.#getKnownSymbol(record, property);\n    // Unknown property, return undefined\n    return undefined;\n  }\n  set(record, property, value) {\n    // Receiver is the same as record but never used (API compatibility)\n    const recordId = this.getRecordId(record);\n    // Throw an error when trying to set a property, also catches\n    // relationship reverses, safeguarding against issues there.\n    if (this.#hasProperty(property)) throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set property ${property}.`);\n    // Throw an error when trying to set a method.\n    if (this.#hasMethod(property)) throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set method ${property}.`);\n    // Validate and set field, warn if field is not defined\n    /* istanbul ignore else*/\n    if (this.#hasField(property)) {\n      const field = this.#getField(property);\n      RecordHandler.#setRecordField(this.#model.name, record, field, value, this.#hasRelationshipField(property));\n    }\n    return true;\n  }\n\n  // Private methods\n\n  static #setRecordField(modelName, record, field, value, isRelationship) {\n    // Set the default value if the field is null or undefined\n    const recordValue = !isRelationship && (0,_types__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(value) ? null : value;\n    if (!isRelationship && !field.typeCheck(recordValue))\n      // Throw an error if the field value is invalid\n      throw new TypeError(`${modelName} record has invalid value for field ${field.name}.`);\n    // We check for $wrappedRecordValue to ensure the record is wrapped in a\n    // handler (i.e. initialized) and not a plain object (i.e. initializing).\n    if (record[$wrappedRecordValue]) record[$cachedProperties].clear();\n    record[$recordValue][field.name] = recordValue;\n  }\n  static #recordToObject(record, model) {\n    const recordValue = record[$recordValue];\n    const fields = model[$fields];\n    const object = {\n      id: recordValue.id\n    };\n    fields.forEach(field => {\n      const value = recordValue[field.name];\n      if (value !== undefined) object[field.name] = recordValue[field.name];\n    });\n    return () => object;\n  }\n  static #validateNewRecordId = (modelName, id, records) => {\n    let newRecordId = id;\n    if (!(0,_types__WEBPACK_IMPORTED_MODULE_3__.recordId)(newRecordId)) throw new TypeError(`${modelName} record has invalid id.`);\n    if (records.has(newRecordId)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.DuplicationError(`${modelName} record with id ${newRecordId} already exists.`);\n    return newRecordId;\n  };\n\n  /*  ======  Utility methods  ======  */\n\n  #getModelName() {\n    return this.#model.name;\n  }\n  #getFieldNames() {\n    return [...this.#model[$fields].keys()];\n  }\n  #getEmptyRecordTemplate() {\n    return this.#model[$emptyRecordTemplate];\n  }\n  #isRecordId(property) {\n    return property === \'id\';\n  }\n  getRecordId(record) {\n    return record[$recordValue].id;\n  }\n  #hasField(property) {\n    return this.#model[$fields].has(property);\n  }\n  #getField(property) {\n    return this.#model[$fields].get(property);\n  }\n  #getFieldValue(record, property) {\n    return record[$recordValue][property];\n  }\n  #hasProperty(property) {\n    return this.#model[$properties].has(property);\n  }\n  #getProperty(record, property) {\n    if (this.#model[$cachedProperties].has(property)) {\n      if (record[$cachedProperties] && record[$cachedProperties].has(property)) return record[$cachedProperties].get(property);\n      const value = this.#model[$properties].get(property)(record[$wrappedRecordValue], _schema__WEBPACK_IMPORTED_MODULE_1__["default"][$schemaObject]);\n      record[$cachedProperties].set(property, value);\n      return value;\n    }\n    return this.#model[$properties].get(property)(record[$wrappedRecordValue], _schema__WEBPACK_IMPORTED_MODULE_1__["default"][$schemaObject]);\n  }\n  #hasMethod(method) {\n    return this.#model[$methods].has(method);\n  }\n  #getMethod(record, method) {\n    const methodFn = this.#model[$methods].get(method);\n    return (...args) => methodFn(record[$wrappedRecordValue], ...args, _schema__WEBPACK_IMPORTED_MODULE_1__["default"][$schemaObject]);\n  }\n  #hasRelationshipField(property) {\n    // A relationship field exists if a field with the same name exists and\n    // a relationship exists named `${property}.${property}`. This is due to\n    // relationships being stored as a `.`-delimited tuple of the relationship\n    // name and the field/property name. In the case of the field name, it\'s the\n    // same as the actual relationship name.\n    if (!this.#hasField(property)) return false;\n    return this.#model[$relationships].has(`${property}.${property}`);\n  }\n  #getRelationship(record, property) {\n    // Get the relationship from the field only. The field name matches that of\n    // the relationship, so the relationship key is ${property}.${property}`.\n    return this.#model[$relationships].get(`${property}.${property}`)[$get](this.#getModelName(), property, record[$recordValue]);\n  }\n  #isCallToSerialize(property) {\n    return property === \'toObject\' || property === \'toJSON\';\n  }\n  #isCallToString(property) {\n    return property === \'toString\';\n  }\n  #isKnownSymbol(property) {\n    return [$recordModel, $recordTag, $recordValue, $isRecord].includes(property);\n  }\n  #getKnownSymbol(record, property) {\n    if (property === $isRecord) return true;\n    return record[property];\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecordHandler);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/handler.js?')},"./src/record/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Record: () => (/* reexport safe */ _record__WEBPACK_IMPORTED_MODULE_0__["default"]),\n/* harmony export */   RecordHandler: () => (/* reexport safe */ _handler__WEBPACK_IMPORTED_MODULE_1__["default"]),\n/* harmony export */   RecordSet: () => (/* reexport safe */ _set__WEBPACK_IMPORTED_MODULE_2__["default"])\n/* harmony export */ });\n/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./record */ "./src/record/record.js");\n/* harmony import */ var _handler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./handler */ "./src/record/handler.js");\n/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./set */ "./src/record/set.js");\n\n\n\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/index.js?')},"./src/record/record.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ "./src/symbols.js");\n\nconst {\n  $recordValue,\n  $wrappedRecordValue,\n  $recordHandler,\n  $recordModel,\n  $recordTag,\n  $cachedProperties\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__["default"];\nclass Record {\n  #recordValue;\n  #recordHandler;\n  #proxiedRecord;\n  #cachedProperties;\n  constructor(value, handler) {\n    this.#recordValue = value;\n    this.#recordHandler = handler;\n    this.#cachedProperties = new Map();\n    this.#proxiedRecord = new Proxy(this, this.#recordHandler);\n    return this.#proxiedRecord;\n  }\n  get [$cachedProperties]() {\n    return this.#cachedProperties;\n  }\n\n  /* istanbul ignore next */\n  get [$recordHandler]() {\n    return this.#recordHandler;\n  }\n  get [$recordValue]() {\n    return this.#recordValue;\n  }\n\n  // This is used to get the record wrapped in the handler proxy. It\'s useful\n  // for property calls in records, so that they can access relationships and\n  // other properties via the handler proxy.\n  /* istanbul ignore next */\n  get [$wrappedRecordValue]() {\n    return this.#proxiedRecord;\n  }\n\n  /* istanbul ignore next */\n  get [$recordModel]() {\n    return this.#recordHandler.model;\n  }\n\n  /* istanbul ignore next */\n  get [$recordTag]() {\n    const model = this[$recordModel];\n    return `${model.name}#${this[$recordValue].id}`;\n  }\n\n  /* istanbul ignore next */\n  get [Symbol.toStringTag]() {\n    return this[$recordTag];\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Record);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/record.js?')},"./src/record/set.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbols */ \"./src/symbols.js\");\n\nconst {\n  $scopes,\n  $addScope,\n  $isRecord,\n  $set,\n  $delete,\n  $clearRecordSetForTesting\n} = _symbols__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\n/**\n * An extension of the native Map object. Provides the same API, along with\n * additional methods similar to the Array prototype.\n */\nclass RecordSet extends Map {\n  #model;\n  constructor({\n    iterable = [],\n    model = null\n  } = {}) {\n    super();\n    if (!model) throw new TypeError('Model cannot be empty.');\n    this.#model = model;\n    for (const [id, value] of iterable) this[$set](id, value);\n    this.#copyScopesFromModel();\n  }\n  set() {\n    throw new TypeError('You cannot directly modify a RecordSet. Please use `Model.prototype.createRecord()` instead.');\n  }\n  delete() {\n    throw new TypeError('You cannot directly modify a RecordSet. Please use `Model.prototype.deleteRecord()` instead.');\n  }\n  clear() {\n    throw new TypeError('You cannot directly modify a RecordSet Please use `Model.prototype.deleteRecord()` instead.');\n  }\n\n  /**\n   * Creates an array or object populated with the results of calling a provided\n   * function on every element in the calling record set.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @param {Object} options An object with options for the map operation.\n   * @param {Boolean} options.flat Whether to return an array or object.\n   * @returns {Array/Object} An array or object with the results of the callback\n   * function on each element.\n   */\n  map(callbackFn, {\n    flat = false\n  } = {}) {\n    if (flat) return [...this.entries()].map(([id, value]) => {\n      return callbackFn(value, id, this);\n    });\n    return [...this.entries()].reduce((newMap, [id, value]) => {\n      newMap[id] = callbackFn(value, id, this);\n      return newMap;\n    }, {});\n  }\n\n  /**\n   * Executes a user-supplied “reducer” callback function on each element of the\n   * record set, passing in the return value from the calculation on the preceding\n   * element. The final result of running the reducer across all elements of the\n   * record set is a single value.\n   * @param {Function} callbackFn A “reducer” function that takes four arguments:\n   * - `accumulator`: The value returned from the previous iteration of the\n   * reducer.\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @param {*} initialValue The initial value of the accumulator.\n   * @returns {*} The value that results from running the “reducer” callback\n   * function to completion over the entire record set.\n   */\n  reduce(callbackFn, initialValue) {\n    return [...this.entries()].reduce((acc, [id, value]) => {\n      return callbackFn(acc, value, id, this);\n    }, initialValue);\n  }\n\n  /**\n   * Creates a new record set or array with all elements that pass the test\n   * implemented by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @param {Boolean} options.flat Whether to return an array or object.\n   * @returns {Array/RecordSet} An array or record set with all elements that\n   * pass the test.\n   */\n  filter(callbackFn, {\n    flat = false\n  } = {}) {\n    if (flat) return [...this.entries()].reduce((arr, [id, value]) => {\n      if (callbackFn(value, id, this)) arr.push(value);\n      return arr;\n    }, []);\n    return [...this.entries()].reduce((newMap, [id, value]) => {\n      if (callbackFn(value, id, this)) newMap[$set](id, value);\n      return newMap;\n    }, new RecordSet({\n      model: this.#model\n    }));\n  }\n\n  /**\n   * Returns the value of the first element in the record set that satisfies\n   * the provided testing function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Record} The value of the first element in the record set that\n   * satisfies the provided testing function or `undefined`.\n   */\n  find(callbackFn) {\n    for (const [id, value] of this.entries()) {\n      if (callbackFn(value, id, this)) return value;\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the id of the first element in the record set that satisfies the\n   * provided testing function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {*} The id of the first element in the record set that satisfies\n   * the provided testing function or `undefined`.\n   */\n  findId(callbackFn) {\n    for (const [id, value] of this.entries()) {\n      if (callbackFn(value, id, this)) return id;\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns all elements in the record set whose ids match the provided\n   * ids/ids in order of appearance in the given ids.\n   * @param  {...any} ids A list of ids to exclude from the record set.\n   * @returns {RecordSet} A new record set with all elements whose ids\n   * match the provided id/ids.\n   */\n  only(...ids) {\n    return new RecordSet({\n      iterable: ids.reduce((itr, id) => {\n        if (this.has(id)) itr.push([id, this.get(id)]);\n        return itr;\n      }, []),\n      model: this.#model\n    });\n  }\n\n  /**\n   * Returns all elements in the record set whose ids do not match the provided\n   * id/ids.\n   * @param  {...any} ids A list of ids to exclude from the record set.\n   * @returns {RecordSet} A new record set with all elements whose ids do not\n   * match the provided id/ids.\n   */\n  except(...ids) {\n    return new RecordSet({\n      iterable: [...this.entries()].filter(([id]) => {\n        return !ids.includes(id);\n      }),\n      model: this.#model\n    });\n  }\n\n  /**\n   * Sorts the elements of the record set and returns a new sorted record set.\n   * @param {Function} callbackFn Function that defined the sort order. The\n   * callback is called with the following arguments:\n   * - `firstValue`: The value of the first element for comparison.\n   * - `secondValue`: The value of the second element for comparison.\n   * - `firstId`: The id of the first element for comparison.\n   * - `secondId`: The id of the second element for comparison.\n   * @returns {RecordSet} A new record set with the elements of the original\n   * record set sorted.\n   */\n  sort(comparatorFn) {\n    const sorted = [...this.entries()].sort(([id1, value1], [id2, value2]) => comparatorFn(value1, value2, id1, id2));\n    return new RecordSet({\n      iterable: sorted,\n      model: this.#model\n    });\n  }\n\n  /**\n   * Tests whether all elements in the record set pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Boolean} `true` if all elements in the record set pass the test,\n   * `false` otherwise.\n   */\n  every(callbackFn) {\n    if (this.size === 0) return true;\n    return [...this.entries()].every(([id, value]) => callbackFn(value, id, this));\n  }\n\n  /**\n   * Tests whether some elements in the record set pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {Boolean} `true` if any elements in the record set pass the test,\n   * `false` otherwise.\n   */\n  some(callbackFn) {\n    if (this.size === 0) return false;\n    return [...this.entries()].some(([id, value]) => callbackFn(value, id, this));\n  }\n\n  /**\n   * Returns an array of objects with all elements mapped to the keys specified.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {Array} An array with all elements mapped to the keys specified.\n   */\n  select(...keys) {\n    return [...this.values()].map(value => keys.reduce((obj, key) => ({\n      ...obj,\n      [key]: value[key]\n    }), {}));\n  }\n\n  /**\n   * Returns an array with records mapped to arrays containing only the\n   * keys specified. If only one key is specified, the array contains the\n   * value of each element instead.\n   * @param  {...any} keys A list of keys to map each record to.\n   * @returns {Array} An array of arrays with records mapped to the values\n   * of the keys specified. If only one key is specified, the array contains\n   * the value of each element instead.\n   */\n  pluck(...keys) {\n    const isSingleKey = keys.length === 1;\n    if (isSingleKey) {\n      const key = keys[0];\n      if (key === 'id') return [...this.ids()];\n      return [...this.values()].map(value => value[key]);\n    }\n    return [...this.values()].map(value => keys.map(key => value[key]));\n  }\n\n  /**\n   * Group the elements of the record set by the specified key.\n   * @param {*} key A key to group the elements by.\n   * @returns {Object} An object with the keys being the values of the\n   * specified key and the values being record sets containing the elements\n   * of the original record set that have the same value for the specified key.\n   */\n  groupBy(key) {\n    const res = {};\n    for (const [recordKey, value] of this.entries()) {\n      let keyValue = value[key];\n      if (keyValue !== undefined && keyValue !== null && keyValue[$isRecord]) {\n        keyValue = value[key].id;\n      }\n      if (!res[keyValue]) {\n        res[keyValue] = new RecordSet({\n          iterable: [],\n          model: this.#model\n        });\n      }\n      res[keyValue][$set](recordKey, value);\n    }\n    return res;\n  }\n\n  /**\n   * Creates a new record set with all elements that pass the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that pass the test.\n   */\n  where(callbackFn) {\n    return this.filter(callbackFn);\n  }\n\n  /**\n   * Creates a new record set with all elements that fail the test implemented\n   * by the provided function.\n   * @param {Function} callbackFn Function that is called for every element of\n   * the record set. The callback is called with the following arguments:\n   * - `value`: The value of the current element.\n   * - `id`: The id of the current element.\n   * - `recordSet`: The record set itself.\n   * @returns {RecordSet} A new record set with all elements that fail the test.\n   */\n  whereNot(callbackFn) {\n    return this.filter((value, id, map) => !callbackFn(value, id, map));\n  }\n\n  /**\n   * Iterates over the record set in batches of the specified size.\n   * @param {Number} batchSize The size of each batch.\n   * @param {Object} options An object with options for the operation.\n   * @param {Boolean} options.flat Whether to yield record set or array batches.\n   * @returns {Iterator} An iterator that yields record set or array batches of\n   * the specified size.\n   */\n  *batchIterator(batchSize, {\n    flat = false\n  } = {}) {\n    let batch = [];\n    for (const [id, value] of this) {\n      batch.push(flat ? value : [id, value]);\n      if (batch.length === batchSize) {\n        yield flat ? batch : new RecordSet({\n          iterable: batch,\n          model: this.#model\n        });\n        batch = [];\n      }\n    }\n    if (batch.length) yield flat ? batch : new RecordSet({\n      iterable: batch,\n      model: this.#model\n    });\n  }\n\n  /**\n   * Returns a new record set with only the first n elements.\n   * @param {Number} n The number of elements to keep.\n   * @returns {RecordSet} A new record set with only the first n elements.\n   */\n  limit(n) {\n    let records = [];\n    for (const [id, value] of this) {\n      records.push([id, value]);\n      if (records.length === n) break;\n    }\n    return new RecordSet({\n      iterable: records,\n      model: this.#model\n    });\n  }\n\n  /**\n   * Returns a new record set with the first n elements removed.\n   * @param {Number} n The number of elements to remove.\n   * @returns {RecordSet} A new record set with the first n elements removed.\n   */\n  offset(n) {\n    let counter = 0;\n    let records = [];\n    for (const [id, value] of this) {\n      if (counter < n) counter++;else records.push([id, value]);\n    }\n    return new RecordSet({\n      iterable: records,\n      model: this.#model\n    });\n  }\n\n  /**\n   * Returns a new record set with the elements contained in a portion of the\n   * record set.\n   * @param {Number} start The index of the first element to include.\n   * @param {Number} end The index after the last element to include.\n   * @returns {RecordSet} A new record set with the elements contained in a\n   * portion of the record set.\n   */\n  slice(start, end) {\n    return new RecordSet({\n      iterable: [...this.entries()].slice(start, end),\n      model: this.#model\n    });\n  }\n\n  /**\n   * Returns the first element in the record set.\n   */\n  get first() {\n    for (const [, value] of this) return value;\n    return undefined;\n  }\n\n  /**\n   * Returns the last element in the record set.\n   */\n  get last() {\n    if (this.size === 0) return undefined;\n    return [...this.entries()].pop()[1];\n  }\n\n  /**\n   * Returns the number of elements in the record set.\n   */\n  get count() {\n    return this.size;\n  }\n\n  /**\n   * Returns the number of elements in the record set.\n   */\n  get length() {\n    return this.size;\n  }\n\n  /**\n   * Returns a new Iterator object that contains the ids for each element in the\n   * record set.\n   */\n  get ids() {\n    return this.keys;\n  }\n\n  /**\n   * Returns an array of the records contained in the record set.\n   * @param {Object} options An object with options for the operation.\n   * @param {Boolean} options.flat Whether to convert the records to objects.\n   * @returns {Array<Record>/Array{Object}} An array of the values contained in\n   * the record set.\n   */\n  toArray({\n    flat = false\n  } = {}) {\n    const values = [...this.values()];\n    if (flat) return values.map(value => value.toObject());\n    return values;\n  }\n\n  /**\n   * Returns an object representing the record set.\n   * @param {Object} options An object with options for the operation.\n   * @param {Boolean} options.flat Whether to convert the records to objects.\n   * @returns {Object} An object representing the record set.\n   */\n  toObject({\n    flat = false\n  } = {}) {\n    if (flat) return [...this.entries()].reduce((obj, [id, value]) => {\n      obj[id] = value.toObject();\n      return obj;\n    }, {});\n    return [...this.entries()].reduce((obj, [id, value]) => {\n      obj[id] = value;\n      return obj;\n    }, {});\n  }\n\n  /**\n   * Returns the object repeseentation of the record set.\n   * Used by JSON.stringify().\n   * @returns {Object} The object representation of the record set.\n   */\n  toJSON() {\n    return this.toObject();\n  }\n\n  /* istanbul ignore next */\n  get [Symbol.toStringTag]() {\n    return this.#model.name;\n  }\n\n  /* istanbul ignore next */\n  static get [Symbol.species]() {\n    return Map;\n  }\n\n  // Protected (package internal-use only)\n\n  [$set](id, value) {\n    super.set(id, value);\n    return this;\n  }\n  [$delete](id) {\n    super.delete(id);\n    return this;\n  }\n  [$addScope](name) {\n    Object.defineProperty(this, name, {\n      configurable: false,\n      // Prevents deletion\n      get: () => {\n        return this.#scopedWhere(name);\n      }\n    });\n  }\n  [$clearRecordSetForTesting]() {\n    super.clear();\n  }\n\n  // Private\n\n  #copyScopesFromModel() {\n    this.#model[$scopes].forEach((scope, name) => {\n      if (this[name]) return;\n      Object.defineProperty(this, name, {\n        configurable: false,\n        // Prevents deletion\n        get: () => {\n          return this.#scopedWhere(name);\n        }\n      });\n    });\n  }\n  #scopedWhere(scopeName) {\n    const [matcherFn, comparatorFn] = this.#model[$scopes].get(scopeName);\n    let matches = [];\n    for (const [id, value] of this.entries()) if (matcherFn(value, id, this)) matches.push([id, value]);\n    if (comparatorFn) matches.sort(([id1, value1], [id2, value2]) => comparatorFn(value1, value2, id1, id2));\n    return new RecordSet({\n      iterable: matches,\n      model: this.#model\n    });\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecordSet);\n\n//# sourceURL=webpack://@jsiqle/core/./src/record/set.js?")},"./src/relationship.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Relationship: () => (/* binding */ Relationship)\n/* harmony export */ });\n/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./field */ \"./src/field.js\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema */ \"./src/schema.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ \"./src/types.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\n\nconst {\n  $recordValue,\n  $fields,\n  $getField,\n  $getProperty,\n  $get,\n  $instances,\n  $handleExperimentalAPIMessage\n} = _symbols__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\nconst relationshipEnum = {\n  oneToOne: 'oneToOne',\n  oneToMany: 'oneToMany',\n  manyToOne: 'manyToOne',\n  manyToMany: 'manyToMany'\n};\nclass Relationship {\n  #type;\n  #from;\n  #to;\n  #name; // relationship field name in the from table\n  #reverseName; // relationship field name in the to table\n  #relationshipField; // relationship field in the from model\n  #relationshipProperty; // relationship property in the to model\n\n  // TODO: V2 enhancements\n  // After the API for relationships is stable-ish, figure out a way to add\n  // cascade.\n  constructor({\n    from,\n    to,\n    type\n  } = {}) {\n    _schema__WEBPACK_IMPORTED_MODULE_1__.Schema[$handleExperimentalAPIMessage]('Relationships are experimental in the current version. There is neither validation of existence in foreign tables nor guarantee that associations work. Please use with caution.');\n    this.#type = Relationship.#validateType(type);\n    const [fromModel, fromName, toModel, toName] = Relationship.#parseModelsAndNames(from, to, type);\n    this.#from = fromModel;\n    this.#to = toModel;\n    this.#name = fromName;\n    this.#reverseName = toName;\n    if (this.#to === this.#from && Relationship.#isSymmetric(this.#type) && this.#name === this.#reverseName) throw new RangeError('Relationship cannot be symmetric if the from and to models are the same and no name is provided for either one.');\n    this.#relationshipField = Relationship.#createField(this.#name, this.#type);\n    this.#relationshipProperty = record => {\n      return this.#getAssociatedRecordsReverse(record);\n    };\n  }\n\n  // Protected (package internal-use only)\n\n  [$getField]() {\n    return {\n      name: this.#name,\n      type: this.#type,\n      fieldName: this.#name,\n      field: this.#relationshipField\n    };\n  }\n  [$getProperty]() {\n    return {\n      name: this.#name,\n      type: this.#type,\n      propertyName: this.#reverseName,\n      property: this.#relationshipProperty\n    };\n  }\n  [$get](modelName, property, record) {\n    // When from model is specified, apply the relationship as-is\n    if (modelName === this.#from.name && property === this.#name) {\n      return this.#getAssociatedRecords(record);\n    }\n    // When to model is specified, reverse the relationship before applying it\n    /* istanbul ignore next */\n    if (modelName === this.#to.name && property === this.#reverseName) {\n      console.warn('Relationship getter called by the receiver model. This might indicate an issue with the library and should be reported.');\n      return this.#getAssociatedRecordsReverse(record);\n    }\n  }\n\n  // Private\n\n  #getAssociatedRecords(record) {\n    // Use a regular get for toOne relationships for performance\n    if (Relationship.#isToOne(this.#type)) {\n      const associationValue = record[this.#name];\n      return this.#to.records.get(associationValue);\n    }\n    // Use a where query for toMany relationships, safeguard against empty value\n    const associationValues = record[this.#name] || [];\n    return this.#to.records.only(...associationValues);\n  }\n  #getAssociatedRecordsReverse(record) {\n    const associationValue = record.id;\n    const matcher = Relationship.#isToOne(this.#type) ? associatedRecord => associatedRecord[$recordValue][this.#name] === associationValue : associatedRecord => {\n      const associatedRecordValue = associatedRecord[$recordValue][this.#name];\n      if ([undefined, null].includes(associatedRecordValue)) return false;\n      return associatedRecord[$recordValue][this.#name].includes(associationValue);\n    };\n    // Use a regular get for fromOne relationships for performance\n    if (Relationship.#isFromOne(this.#type)) {\n      return this.#from.records.find(matcher);\n    }\n    // Use a where query for fromMany relationships, safeguard against empty value\n    return this.#from.records.where(matcher);\n  }\n  static #isToOne(type) {\n    return [relationshipEnum.oneToOne, relationshipEnum.manyToOne].includes(type);\n  }\n  static #isToMany(type) {\n    return [relationshipEnum.oneToMany, relationshipEnum.manyToMany].includes(type);\n  }\n  static #isFromOne(type) {\n    return [relationshipEnum.oneToMany, relationshipEnum.oneToOne].includes(type);\n  }\n  static #isFromMany(type) {\n    return [relationshipEnum.manyToOne, relationshipEnum.manyToMany].includes(type);\n  }\n  static #isSymmetric(type) {\n    return [relationshipEnum.oneToOne, relationshipEnum.manyToMany].includes(type);\n  }\n  static #createField(name, relationshipType) {\n    // TODO: V2 enhancements\n    // Potentially add a check if the other model contains the ids(s)?\n    const isMultiple = Relationship.#isToMany(relationshipType);\n    const type = isMultiple ? _types__WEBPACK_IMPORTED_MODULE_5__.recordIdArray : _types__WEBPACK_IMPORTED_MODULE_5__.recordId;\n    // TODO: V2 enhancements\n    // Add a check for symmetric relationships to ensure that a\n    // record does not reference itself in the relationship, creating a loop.\n\n    const relationshipField = new _field__WEBPACK_IMPORTED_MODULE_0__.Field({\n      name,\n      type\n    });\n    return relationshipField;\n  }\n  static #validateType(relationshipType) {\n    if (!Object.values(relationshipEnum).includes(relationshipType)) throw new TypeError(`Invalid relationship type: ${relationshipType}.`);\n    return relationshipType;\n  }\n  static #validateModel(modelData) {\n    const modelName = typeof modelData === 'string' ? modelData : modelData.model;\n    if (!_model__WEBPACK_IMPORTED_MODULE_3__.Model[$instances].has(modelName)) throw new ReferenceError(`Model ${modelName} does not exist.`);\n    return _model__WEBPACK_IMPORTED_MODULE_3__.Model[$instances].get(modelName);\n  }\n  static #createName(type, to) {\n    if (Relationship.#isToOne(type)) return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(to);\n    if (Relationship.#isToMany(type)) return `${(0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(to)}Set`;\n  }\n  static #createReverseName = (type, from) => {\n    if (Relationship.#isFromOne(type)) return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(from);\n    if (Relationship.#isFromMany(type)) return `${(0,_utils__WEBPACK_IMPORTED_MODULE_4__.reverseCapitalize)(from)}Set`;\n  };\n  static #validateModelParams(modelData) {\n    const model = Relationship.#validateModel(modelData);\n    const name = typeof modelData === 'string' ? null : (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(modelData.name);\n    if (name !== null && model[$fields].has(name)) throw new _errors__WEBPACK_IMPORTED_MODULE_2__.DuplicationError(`Field ${name} already exists in ${model.name}.`);\n    return [model, name];\n  }\n  static #parseModelsAndNames(from, to, type) {\n    let fromModel, fromName, toModel, toName;\n    [fromModel, fromName] = Relationship.#validateModelParams(from);\n    [toModel, toName] = Relationship.#validateModelParams(to);\n    if (fromName === null) fromName = Relationship.#createName(type, toModel.name);\n    if (toName === null) toName = Relationship.#createReverseName(type, fromModel.name);\n    return [fromModel, fromName, toModel, toName];\n  }\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/relationship.js?")},"./src/schema.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _relationship__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./relationship */ \"./src/relationship.js\");\n/* harmony import */ var _serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serializer */ \"./src/serializer.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbols */ \"./src/symbols.js\");\n\n\n\n\n\n\nconst {\n  $addRelationshipAsField,\n  $addRelationshipAsProperty,\n  $handleExperimentalAPIMessage,\n  $clearCachedProperties,\n  $clearSchemaForTesting,\n  $schemaObject\n} = _symbols__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\nclass Schema {\n  static #models = new Map();\n  static #serializers = new Map();\n  static #schemaObject = {};\n  static #instantiated = false;\n  static defaultConfig = {\n    experimentalAPIMessages: 'warn'\n  };\n  static config = {\n    ...Schema.defaultConfig\n  };\n\n  /**\n   * Creates a new schema with the given name and options.\n   * @param {Object} schemaData Data for the schema to be created.\n   * @returns The schema singleton.\n   */\n  static create({\n    models = [],\n    relationships = [],\n    serializers = [],\n    config = {}\n  } = {}) {\n    if (Schema.#instantiated) throw new Error('Only one schema can be created.');\n    Schema.#parseConfig(config);\n    models.forEach(modelData => {\n      // Perform name validation for fields, properties and methods here\n      // to exit if something is wrong.\n      const {\n        fields = {},\n        properties = {},\n        methods = {}\n      } = modelData;\n      const names = [...Object.keys(fields), ...Object.keys(properties), ...Object.keys(methods)];\n      const uniqueNames = new Set(names);\n      if (uniqueNames.size !== names.length) throw new Error(`Model ${modelData.name} has duplicate field, property or method names.`);\n      names.forEach(name => (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(name));\n      Schema.#createModel(modelData);\n    });\n    relationships.forEach(relationship => Schema.#createRelationship(relationship));\n    serializers.forEach(serializer => Schema.#createSerializer(serializer));\n\n    // Lazy properties, models and serializers require initial set up as they\n    // depend on other models or serializers.\n    Schema.#schemaObject = {\n      models: Object.fromEntries([...Schema.#models.entries()]),\n      serializers: Object.fromEntries([...Schema.#serializers.entries()])\n    };\n    Schema.#instantiated = true;\n    return Schema;\n  }\n\n  /**\n   * Clears all cached properties of all models.\n   * @returns The schema singleton.\n   */\n  static clearPropertyCache() {\n    Schema[$handleExperimentalAPIMessage]('Clearing the property cache of all models should only be done if something is known to have caused the cache to contain stale data. Please use with caution.');\n    Schema.#models.forEach(model => model[$clearCachedProperties]());\n    return Schema;\n  }\n\n  /**\n   * Retrieves a model from the schema.\n   * @param {String} name The name of the model to retrieve.\n   * @returns The model or `undefined` if it does not exist.\n   */\n  static getModel(name) {\n    return Schema.#models.get(name);\n  }\n\n  /**\n   * Retrieves a serializer from the schema.\n   * @param {String} name The name of the serializer to retrieve.\n   * @returns The serializer or `undefined` if it does not exist.\n   */\n  static getSerializer(name) {\n    return Schema.#serializers.get(name);\n  }\n\n  /**\n   * Gets all models in the schema.\n   */\n  static get models() {\n    return Schema.#models;\n  }\n  static get [$schemaObject]() {\n    return Schema.#schemaObject;\n  }\n\n  /**\n   * Retrieves the data specified by the given pathName\n   * @param {String} pathName A '.'-delimited path to the data.\n   * @returns The value at the specified path.\n   */\n  static get(pathName) {\n    const [modelName, recordId, ...rest] = pathName.split('.');\n    const model = Schema.getModel(modelName);\n    if (!model) throw new ReferenceError(`Model ${modelName} does not exist in the schema.`);\n    if (recordId === undefined) return model;\n    const record = model.records.get(recordId);\n    if (!rest.length) return record;\n    if (!record) throw new ReferenceError(`Record ${recordId} does not exist in model ${modelName}.`);\n    const result = rest.reduce((acc, key) => acc[key], record);\n    return result;\n  }\n\n  // Protected (package internal-use only)\n\n  /* istanbul ignore next */\n  static [$handleExperimentalAPIMessage](message) {\n    const {\n      experimentalAPIMessages\n    } = Schema.config;\n    if (experimentalAPIMessages === 'warn') {\n      console.warn(message);\n    } else if (experimentalAPIMessages === 'error') {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ExperimentalAPIUsageError(message);\n    }\n  }\n\n  /* istanbul ignore next */\n  static [$clearSchemaForTesting]() {\n    Schema.#models.clear();\n    Schema.#serializers.clear();\n    Schema.#schemaObject = {};\n    Schema.#instantiated = false;\n  }\n\n  // Private\n\n  static #createModel(modelData) {\n    const modelName = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(modelData.name);\n    (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateObjectWithUniqueName)({\n      objectType: 'Model',\n      parentType: 'Schema'\n    }, modelData, [...Schema.#models.keys()]);\n    const model = new _model__WEBPACK_IMPORTED_MODULE_0__.Model(modelData);\n    Schema.#models.set(modelName, model);\n  }\n  static #createSerializer(serializerData) {\n    const serializerName = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateName)(serializerData.name);\n    (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateObjectWithUniqueName)({\n      objectType: 'Serializer',\n      parentType: 'Schema'\n    }, serializerData, [...Schema.#serializers.keys()]);\n    const serializer = new _serializer__WEBPACK_IMPORTED_MODULE_2__.Serializer(serializerData);\n    Schema.#serializers.set(serializerName, serializer);\n  }\n  static #createRelationship(relationshipData) {\n    const {\n      from,\n      to,\n      type /* , cascade */\n    } = relationshipData;\n    [from, to].forEach(model => {\n      if (!['string', 'object'].includes(typeof model)) throw new TypeError(`Invalid relationship model: ${model}.`);\n    });\n    const fromModelName = typeof from === 'string' ? from : from.model;\n    const toModelName = typeof to === 'string' ? to : to.model;\n    const fromModel = Schema.#models.get(fromModelName);\n    const toModel = Schema.#models.get(toModelName);\n    if (!fromModel) throw new ReferenceError(`Model ${fromModelName} not found in schema when attempting to create a relationship.`);\n    if (!toModel) throw new ReferenceError(`Model ${toModelName} not found in schema when attempting to create a relationship.`);\n    const relationship = new _relationship__WEBPACK_IMPORTED_MODULE_1__.Relationship({\n      from,\n      to,\n      type\n    });\n    fromModel[$addRelationshipAsField](relationship);\n    toModel[$addRelationshipAsProperty](relationship);\n  }\n  static #parseConfig(config = {}) {\n    if (!config) return;\n    ['experimentalAPIMessages'].forEach(key => {\n      if (config[key] !== undefined) {\n        if (['warn', 'error', 'off'].includes(config[key])) Schema.config[key] = config[key];\n      }\n    });\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Schema);\n\n//# sourceURL=webpack://@jsiqle/core/./src/schema.js?")},"./src/serializer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Serializer: () => (/* binding */ Serializer)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n\nclass Serializer {\n  #name;\n  #attributes;\n  #methods;\n  constructor({\n    name,\n    attributes = [],\n    methods = {}\n  }) {\n    this.#name = name;\n    this.#attributes = new Map();\n    this.#methods = new Map();\n    attributes.forEach(attribute => {\n      const [attributeValue, attributeName] = typeof attribute === 'string' ? [attribute, attribute] : attribute;\n      this.#attributes.set(Serializer.#validateAttribute(attributeName, [...this.#attributes.keys()]), attributeValue);\n    });\n    Object.entries(methods).forEach(([methodName, methodBody]) => {\n      this.#addMethod(methodName, methodBody);\n    });\n  }\n  serialize(object, options) {\n    const serialized = {};\n    this.#attributes.forEach((attributeValue, attributeName) => {\n      const value = this.#methods.has(attributeValue) ? this.#methods.get(attributeValue)(object, options) : object[attributeValue];\n      if (value !== undefined) serialized[attributeName] = value;\n    });\n    return serialized;\n  }\n\n  // ΝΟΤE: This also handles RecordSets (not by design).\n  // The result is an object with each key mapped to a serialized object.\n  serializeArray(objects, options) {\n    return objects.map(object => this.serialize(object, options));\n  }\n  serializeRecordSet(objects, options, keyMapFn) {\n    const serialized = {};\n    objects.forEach((value, key) => {\n      const mappedKey = keyMapFn(key, value);\n      if (mappedKey === undefined) return;\n      serialized[mappedKey] = this.serialize(value, options);\n    });\n    return serialized;\n  }\n  get name() {\n    return this.#name;\n  }\n\n  // Private\n\n  #addMethod(methodName, methodBody) {\n    const method = Serializer.#validateFunction(methodName, methodBody, [...this.#methods.keys()]);\n    this.#methods.set(methodName, method);\n  }\n  static #validateAttribute(attributeName, restrictedNames) {\n    if (typeof attributeName !== 'string') throw new TypeError(`Attribute ${attributeName} is not a string.`);\n    if (restrictedNames.includes(attributeName)) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.DuplicationError(`Attribute ${attributeName} already exists.`);\n    return attributeName;\n  }\n  static #validateFunction(callbackName, callback, restrictedNames) {\n    if (typeof callback !== 'function') throw new TypeError(`Method ${callbackName} is not a function.`);\n    if (restrictedNames.includes(callbackName)) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.DuplicationError(`Method ${callbackName} already exists.`);\n    return callback;\n  }\n}\n\n//# sourceURL=webpack://@jsiqle/core/./src/serializer.js?")},"./src/symbols.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Symbolizes any number of strings and return an object\n * @param  {...any} str Array of strings to symbolize\n * @returns {object} Object with symbolized strings\n */\nconst symbolizeAll = (...str) => str.reduce((acc, curr) => {\n  acc[`$${curr}`] = Symbol.for(curr);\n  return acc;\n}, {});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (symbolizeAll('fields', 'properties', 'cachedProperties', 'methods', 'scopes', 'relationships', 'relationshipField', 'recordModel', 'recordValue', 'wrappedRecordValue', 'recordHandler', 'recordTag', 'emptyRecordTemplate', 'addScope', 'addRelationshipAsField', 'addRelationshipAsProperty', 'getField', 'getProperty', 'instances', 'isRecord', 'groupTag', 'set', 'delete', 'get', 'handleExperimentalAPIMessage', 'clearSchemaForTesting', 'clearCachedProperties', 'clearRecordSetForTesting', 'schemaObject'));\n\n//# sourceURL=webpack://@jsiqle/core/./src/symbols.js?")},"./src/types.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isOptional: () => (/* binding */ isOptional),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   recordId: () => (/* binding */ recordId),\n/* harmony export */   recordIdArray: () => (/* binding */ recordIdArray),\n/* harmony export */   standardTypes: () => (/* binding */ standardTypes)\n/* harmony export */ });\nconst isBoolean = val => typeof val === 'boolean';\nconst isNumber = val => typeof val === 'number' && val === val;\nconst isString = val => typeof val === 'string';\nconst isDate = val => val instanceof Date;\nconst and = (...types) => val => types.every(type => type(val));\nconst or = (...types) => val => types.some(type => type(val));\nconst isArrayOf = type => val => Array.isArray(val) && val.every(type);\nconst isObject = val => typeof val === 'object';\nconst isNull = val => val === null;\nconst hasUniqueValues = arr => new Set(arr).size === arr.length;\nconst isUndefined = val => val === undefined;\nconst isOptional = type => val => or(isNull, type)(val);\nconst standardTypes = {\n  boolean: {\n    type: isBoolean\n  },\n  number: {\n    type: isNumber\n  },\n  string: {\n    type: isString\n  },\n  date: {\n    type: isDate\n  },\n  booleanArray: {\n    type: isArrayOf(isBoolean)\n  },\n  numberArray: {\n    type: isArrayOf(isNumber)\n  },\n  stringArray: {\n    type: isArrayOf(isString)\n  },\n  dateArray: {\n    type: isArrayOf(isDate)\n  },\n  object: {\n    type: isObject\n  }\n};\n\n// Internal types\nconst isNonEmptyString = val => val.trim().length !== 0;\nconst recordId = and(isString, isNonEmptyString);\nconst recordIdArray = and(isArrayOf(recordId), hasUniqueValues);\n\n//# sourceURL=webpack://@jsiqle/core/./src/types.js?")},"./src/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   reverseCapitalize: () => (/* binding */ reverseCapitalize),\n/* harmony export */   validateName: () => (/* binding */ validateName),\n/* harmony export */   validateObjectWithUniqueName: () => (/* binding */ validateObjectWithUniqueName)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n\n\n// Name validation\n// TODO: 'records' can be a bit of a loose gun here.\nconst restrictedNames = ['toString', 'toObject', 'toJSON', 'id'];\n\n/**\n * Validates the name of a field or model.\n * Restrictiorns:\n * - Must be a string\n * - Must be at least 1 character long\n * - Must not start with a number\n * - Must contain only alphanumeric characters, numbers or underscores\n * @param {string} name The name of the field or model to validate.\n * @returns {boolean} Whether the name is valid.\n */\nconst isValidName = name => {\n  if (typeof name !== 'string') return [false, 'must be a string'];\n  if (!name) return [false, 'cannot be empty'];\n  if (/^\\d/.test(name)) return [false, 'cannot start with a number'];\n  if (restrictedNames.includes(name)) return [false, 'is reserved'];\n  return [/^\\w+$/.test(name), 'must contain only alphanumeric characters, numbers or underscores'];\n};\n\n/**\n * Validates the name of a field or model.\n * Restrictiorns:\n * - Must be a string\n * - Must be at least 1 character long\n * - Must not start with a number\n * - Must contain only alphanumeric characters, numbers or underscores\n * @param {string} name The name of the field or model to validate.\n * @throws {NameError} If the name is invalid.\n * @returns {boolean} Whether the name is valid.\n */\nconst validateName = name => {\n  const [isValid, message] = isValidName(name);\n  if (!isValid) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NameError(`Name \"${name}\" is invalid - ${message}.`);\n  return name;\n};\n\n// General-purpose utilities\n\nconst reverseCapitalize = ([first, ...rest]) => first.toLowerCase() + rest.join('');\nconst deepClone = obj => {\n  if (typeof obj !== 'object') return obj;\n  if (obj === null) return null;\n  if (obj instanceof Date) return new Date(obj);\n  let clone = Object.assign({}, obj);\n  Object.entries(clone).forEach(([key, value]) => clone[key] = typeof obj[key] === 'object' ? deepClone(value) : value);\n  if (Array.isArray(obj)) {\n    clone.length = obj.length;\n    return Array.from(clone);\n  }\n  return clone;\n};\nconst isObject = obj => obj && typeof obj === 'object';\nconst validateObjectWithUniqueName = ({\n  objectType,\n  parentType,\n  parentName\n}, obj, collection) => {\n  if (!isObject(obj)) throw new TypeError(`${objectType} ${obj} is not an object.`);\n  if (collection.includes(obj.name)) {\n    const namedType = parentName ? `${parentType} ${parentName}` : parentType;\n    throw new _errors__WEBPACK_IMPORTED_MODULE_0__.DuplicationError(`${namedType} already has a ${objectType.toLowerCase()} named ${obj.name}.`);\n  }\n  return true;\n};\n\n//# sourceURL=webpack://@jsiqle/core/./src/utils.js?")}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId](module,module.exports,__webpack_require__),module.exports}__webpack_require__.d=(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})},__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),__webpack_require__.r=exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__})()));