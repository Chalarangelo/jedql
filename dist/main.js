!function(root,factory){"object"==typeof exports&&"object"==typeof module?module.exports=factory():"function"==typeof define&&define.amd?define([],factory):"object"==typeof exports?exports["@jsiqle/core"]=factory():root["@jsiqle/core"]=factory()}(global,(()=>(()=>{"use strict";var __webpack_require__={n:module=>{var getter=module&&module.__esModule?()=>module.default:()=>module;return __webpack_require__.d(getter,{a:getter}),getter},d:(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})},o:(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),r:exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})}},__webpack_exports__={};__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>src});const external_events_namespaceObject=require("events");var external_events_default=__webpack_require__.n(external_events_namespaceObject);const symbols=((...str)=>str.reduce(((acc,curr)=>(acc[`$${curr}`]=Symbol.for(curr),acc)),{}))("fields","properties","cachedProperties","methods","scopes","relationships","relationshipField","validators","recordModel","recordValue","wrappedRecordValue","recordHandler","recordTag","defaultValue","addScope","addRelationshipAsField","addRelationshipAsProperty","getField","getProperty","removeScope","instances","isRecord","groupTag","get","handleExperimentalAPIMessage");class NameError extends Error{constructor(message){super(message),this.name="NameError"}}class ValidationError extends Error{constructor(message){super(message),this.name="ValidationError"}}class DuplicationError extends Error{constructor(message){super(message),this.name="DuplicationError"}}class DefaultValueError extends Error{constructor(message){super(message),this.name="DefaultValueError"}}class ExperimentalAPIUsageError extends Error{constructor(message){super(message),this.name="ExperimentalAPIUsageError"}}class Validator{static unique(field){return(value,data)=>data.every((item=>item[field]!==value[field]))}static notNull(field){return value=>null!==value[field]}static length(field,[min,max]){return value=>value[field].length>=min&&value[field].length<=max}static minLength(field,min){return value=>value[field].length>=min}static maxLength(field,max){return value=>value[field].length<=max}static range(field,[min,max]){return value=>value[field]>=min&&value[field]<=max}static min(field,min){return value=>value[field]>=min}static max(field,max){return value=>value[field]<=max}static integer(field){return value=>Number.isInteger(value[field])}static regex(field,regex){return value=>regex.test(value[field])}static uniqueValues(field){return value=>new Set(value[field]).size===value[field].length}static sortedAscending(field){return value=>value[field].every(((item,index)=>0===index||item>=value[field][index-1]))}static sortedDescending(field){return value=>value[field].every(((item,index)=>0===index||item<=value[field][index-1]))}static custom(field,fn){return(value,data)=>fn(value[field],data.map((item=>item[field])))}}const restrictedNames={Model:["toString","toObject","toJSON"],Field:["toString","toObject","toJSON"],Property:["toString","toObject","toJSON"],Method:["toString","toObject","toJSON"],Relationship:["toString","toObject","toJSON"]},validateName=(objectType,name)=>{const[isValid,message]=((name,restrictedNames=[])=>"string"!=typeof name?[!1,"must be a string"]:name?/^\d/.test(name)?[!1,"cannot start with a number"]:restrictedNames.includes(name)?[!1,"is reserved"]:[/^\w+$/.test(name),"must contain only alphanumeric characters, numbers or underscores"]:[!1,"is required"])(name,restrictedNames[objectType]);if(!isValid)throw new NameError(`${objectType} name ${message}.`);return name},capitalize=([first,...rest])=>first.toUpperCase()+rest.join(""),reverseCapitalize=([first,...rest])=>first.toLowerCase()+rest.join(""),deepClone=obj=>{if(null===obj)return null;if(obj instanceof Date)return new Date(obj);let clone=Object.assign({},obj);return Object.entries(clone).forEach((([key,value])=>clone[key]="object"==typeof obj[key]?deepClone(value):value)),Array.isArray(obj)?(clone.length=obj.length,Array.from(clone)):clone},validateObjectWithUniqueName=({objectType,parentType,parentName},obj,collection)=>{if(!(obj=>obj&&"object"==typeof obj)(obj))throw new TypeError(`${objectType} ${obj} is not an object.`);if(((collection,item)=>collection.includes(item))(collection,obj.name))throw new DuplicationError(`${parentType} ${parentName} already has a ${objectType.toLowerCase()} named ${obj.name}.`);return!0},isBoolean=val=>"boolean"==typeof val,isNumber=val=>"number"==typeof val&&val==val,isString=val=>"string"==typeof val,isDate=val=>val instanceof Date,isArrayOf=type=>val=>Array.isArray(val)&&val.every(type),types_isObject=shape=>{const props=Object.keys(shape);return val=>{if(null==val||"object"!=typeof val)return!1;if(0===props.length)return!0;return Object.keys(val).length===props.length&&props.every((prop=>shape[prop](val[prop])))}},isObjectOf=type=>val=>null!=val&&"object"==typeof val&&Object.keys(val).every((prop=>type(val[prop]))),isNull=val=>null===val,types_enum=(...values)=>val=>values.includes(val),types_optional=(isArrayOf(isBoolean),isArrayOf(isNumber),isArrayOf(isString),isArrayOf(isDate),type=>val=>((...types)=>val=>types.some((type=>type(val))))(isNull,type)(val)),types_undefined=val=>void 0===val,standardTypes={boolean:{type:isBoolean},number:{type:isNumber},string:{type:isString},date:{type:isDate},booleanArray:{type:isArrayOf(isBoolean)},numberArray:{type:isArrayOf(isNumber)},stringArray:{type:isArrayOf(isString)},dateArray:{type:isArrayOf(isDate)},object:{type:types_isObject({})},booleanObject:{type:isObjectOf(isBoolean)},numberObject:{type:isObjectOf(isNumber)},stringObject:{type:isObjectOf(isString)},dateObject:{type:isObjectOf(isDate)},objectArray:{type:isArrayOf(types_isObject({}))}},recordId=((...types)=>val=>types.every((type=>type(val))))(isString,(val=>0!==val.trim().length)),recordIdArray=isArrayOf(recordId),{$defaultValue,$validators}=symbols;class Field{#name;#defaultValue;#type;#validators;constructor({name,type,defaultValue=null,validators={}}){this.#name=validateName("Field",name),this.#type=Field.#validateType(type),this.#defaultValue=Field.#validateDefaultValue(defaultValue,this.#type),this.#validators=new Map,Object.entries(validators).forEach((([validatorName,validator])=>{this.addValidator(validatorName,validator)}))}addValidator(validatorName,validator){this.#validators.set(...Field.#parseFieldValidator(this.#name,validatorName,validator))}get name(){return this.#name}typeCheck(value){return this.#type(value)}get[$defaultValue](){return this.#defaultValue}get[$validators](){return this.#validators}static#validateType(type){if("function"!=typeof type)throw new TypeError("Field type must be a function.");return types_optional(type)}static#validateDefaultValue(defaultValue,type){if(types_undefined(defaultValue))return null;if(!type(defaultValue))throw new ValidationError("Default value must be valid.");return defaultValue}static#parseFieldValidator(fieldName,validatorName,validator){if(void 0!==Validator[validatorName])return[`${fieldName}${capitalize(validatorName)}`,Validator[validatorName](fieldName,validator)];if("function"!=typeof validator)throw new TypeError(`Validator ${validatorName} is not defined.`);return[`${fieldName}${capitalize(validatorName)}`,Validator.custom(fieldName,validator)]}}Object.entries(standardTypes).forEach((([typeName,standardType])=>{const{type}=standardType;Field[typeName]=options=>new Field("string"==typeof options?{name:options,type}:{...options,type})})),Field.enum=({name,values})=>new Field({name,type:types_enum(...values)});const{$recordValue,$wrappedRecordValue,$recordHandler,$recordModel,$recordTag,$cachedProperties}=symbols;class Record{#recordValue;#recordHandler;#proxiedRecord;#cachedProperties;constructor(value,handler){return this.#recordValue=value,this.#recordHandler=handler,this.#cachedProperties=new Map,this.#proxiedRecord=new Proxy(this,this.#recordHandler),this.#proxiedRecord}get[$cachedProperties](){return this.#cachedProperties}get[$recordHandler](){return this.#recordHandler}get[$recordValue](){return this.#recordValue}get[$wrappedRecordValue](){return this.#proxiedRecord}get[$recordModel](){return this.#recordHandler.model}get[$recordTag](){return`${this[$recordModel].name}#${this[$recordValue].id}`}get[Symbol.toStringTag](){return this[$recordTag]}}const record=Record,{$recordTag:partial_$recordTag}=symbols;class PartialRecord{#tag;constructor(value,tag){Object.keys(value).forEach((key=>{this[key]=value[key]})),this.#tag=tag}get[partial_$recordTag](){return this.#tag}get[Symbol.toStringTag](){return this[partial_$recordTag]}toObject(){return{...this}}toJSON(){return this.toObject()}}const{$recordTag:fragment_$recordTag}=symbols;class RecordFragment extends Array{#tag;constructor(values,tag){super(),values.forEach((value=>{this.push(value)})),this.#tag=tag}get[fragment_$recordTag](){return this.#tag}get[Symbol.toStringTag](){return this[fragment_$recordTag]}toObject(){return[...this]}toJSON(){return this.toObject()}}const{$recordModel:set_$recordModel,$recordTag:set_$recordTag,$scopes,$addScope,$removeScope,$isRecord}=symbols;class RecordSet extends Map{#frozen;#scopes;constructor({iterable=[],copyScopesFrom=null}={}){super();for(const[id,value]of iterable)this.set(id,value);this.#scopes=new Map,copyScopesFrom&&this.#copyScopes(copyScopesFrom),this.#frozen=!1}freeze(){return this.#frozen=!0,this}set(id,value){if(this.#frozen)throw new TypeError("Cannot modify a frozen RecordSet.");return super.set(id,value),this}delete(id){if(this.#frozen)throw new TypeError("Cannot modify a frozen RecordSet.");return super.delete(id)}clear(){if(this.#frozen)throw new TypeError("Cannot modify a frozen RecordSet.");super.clear()}map(callbackFn){return[...this.entries()].reduce(((newMap,[id,value])=>(newMap[id]=callbackFn(value,id,this),newMap)),{})}flatMap(callbackFn){return[...this.entries()].map((([id,value])=>callbackFn(value,id,this)))}reduce(callbackFn,initialValue){return[...this.entries()].reduce(((acc,[id,value])=>callbackFn(acc,value,id,this)),initialValue)}filter(callbackFn){return[...this.entries()].reduce(((newMap,[id,value])=>(callbackFn(value,id,this)&&newMap.set(id,value),newMap)),new RecordSet({copyScopesFrom:this})).freeze()}flatFilter(callbackFn){return[...this.entries()].reduce(((arr,[id,value])=>(callbackFn(value,id,this)&&arr.push(value),arr)),[])}find(callbackFn){for(const[id,value]of this.entries())if(callbackFn(value,id,this))return value}findId(callbackFn){for(const[id,value]of this.entries())if(callbackFn(value,id,this))return id}only(...ids){return new RecordSet({iterable:ids.reduce(((itr,id)=>(this.has(id)&&itr.push([id,this.get(id)]),itr)),[]),copyScopesFrom:this}).freeze()}except(...ids){return new RecordSet({iterable:[...this.entries()].filter((([id])=>!ids.includes(id))),copyScopesFrom:this}).freeze()}sort(comparatorFn){const sorted=[...this.entries()].sort((([id1,value1],[id2,value2])=>comparatorFn(value1,value2,id1,id2)));return new RecordSet({iterable:sorted,copyScopesFrom:this}).freeze()}every(callbackFn){return 0===this.size||[...this.entries()].every((([id,value])=>callbackFn(value,id,this)))}some(callbackFn){return 0!==this.size&&[...this.entries()].some((([id,value])=>callbackFn(value,id,this)))}select(...keys){return new RecordSet({iterable:[...this.entries()].map((([key,value])=>{const obj={};return keys.forEach((key=>obj[key]=value[key])),[key,new PartialRecord(obj,value[set_$recordTag])]})),copyScopesFrom:this}).freeze()}flatSelect(...keys){return[...this.values()].map((value=>keys.reduce(((obj,key)=>({...obj,[key]:value[key]})),{})))}pluck(...keys){return new RecordSet({iterable:[...this.entries()].map((([key,value])=>{const values=keys.map((key=>value[key]));return[key,new RecordFragment(values,value[set_$recordTag])]})),copyScopesFrom:this}).freeze()}flatPluck(...keys){if(1===keys.length){const key=keys[0];return"id"===key?[...this.ids()]:[...this.values()].map((value=>value[key]))}return[...this.values()].map((value=>keys.map((key=>value[key]))))}groupBy(key){const res=new RecordSet({copyScopesFrom:this,iterable:[]});for(const[recordKey,value]of this.entries()){let keyValue=value[key];null!=keyValue&&keyValue[$isRecord]&&(keyValue=value[key].id),res.has(keyValue)||res.set(keyValue,new RecordGroup({copyScopesFrom:this,iterable:[],groupName:keyValue})),res.get(keyValue).set(recordKey,value)}for(const value of res.values())value.freeze();return res.freeze()}duplicate(){return new RecordSet({iterable:[...this.entries()],copyScopesFrom:this}).freeze()}merge(...recordSets){const res=new Map([...this.entries()]);for(const recordSet of recordSets)for(const[id,value]of recordSet.entries()){if(res.has(id))throw new DuplicationError(`Id ${id} already exists in the record set.`);res.set(id,value)}return new RecordSet({iterable:[...res.entries()],copyScopesFrom:this}).freeze()}append(...records){const res=new RecordSet({iterable:[...this.entries()],copyScopesFrom:this});for(const record of records)res.set(record.id,record);return res.freeze()}where(callbackFn){return this.filter(callbackFn)}whereNot(callbackFn){return this.filter(((value,id,map)=>!callbackFn(value,id,map)))}*flatBatchIdsIterator(batchSize){let batch=[];for(const id of this.ids())batch.push(id),batch.length===batchSize&&(yield batch,batch=[]);batch.length&&(yield batch)}*flatBatchIterator(batchSize){let batch=[];for(const[,value]of this)batch.push(value),batch.length===batchSize&&(yield batch,batch=[]);batch.length&&(yield batch)}*batchIterator(batchSize){let batch=[];for(const[id,value]of this)batch.push([id,value]),batch.length===batchSize&&(yield new RecordSet({copyScopesFrom:this,iterable:batch}).freeze(),batch=[]);batch.length&&(yield new RecordSet({copyScopesFrom:this,iterable:batch}).freeze())}limit(n){let records=[];for(const[id,value]of this)if(records.push([id,value]),records.length===n)break;return new RecordSet({iterable:records,copyScopesFrom:this}).freeze()}offset(n){let counter=0,records=[];for(const[id,value]of this)counter<n?counter++:records.push([id,value]);return new RecordSet({iterable:records,copyScopesFrom:this}).freeze()}slice(start,end){return new RecordSet({iterable:[...this.entries()].slice(start,end),copyScopesFrom:this}).freeze()}get first(){for(const[,value]of this)return value}get last(){if(0!==this.size)return[...this.entries()].pop()[1]}get count(){return this.size}get length(){return this.size}get ids(){return this.keys}toArray(){return[...this.values()]}toFlatArray(){return[...this.values()].map((value=>value instanceof RecordGroup?value.toFlatArray():value.toObject()))}toObject(){return[...this.entries()].reduce(((obj,[id,value])=>(obj[id]=value,obj)),{})}toFlatObject(){return[...this.entries()].reduce(((obj,[id,value])=>(obj[id]=value instanceof RecordGroup?value.toFlatArray():value.toObject(),obj)),{})}toJSON(){return this.toObject()}get[Symbol.toStringTag](){const records=[...this.values()];try{const firstModel=records[0][set_$recordModel].name;if(((arr,fn)=>{const eql=fn(arr[0]);return arr.every((val=>fn(val)===eql))})(records,(value=>value[set_$recordModel].name===firstModel)))return firstModel}catch(e){return""}return""}static get[Symbol.species](){return Map}[$addScope](name,scope,sortFn){if(RecordSet.#validateProperty("Scope",name,scope,this.#scopes),sortFn&&RecordSet.#validateFunction("Scope comparator",name,sortFn),this[name]||Object.getOwnPropertyNames(RecordSet.prototype).includes(name))throw new NameError(`Scope name ${name} is already in use.`);this.#scopes.set(name,[scope,sortFn]),Object.defineProperty(this,name,{configurable:!0,get:()=>this.#scopedWhere(name)})}[$removeScope](name){this.#scopes.delete(RecordSet.#validateContains("Scope",name,this.#scopes)),delete this[name]}get[$scopes](){return this.#scopes}#copyScopes(otherRecordSet){otherRecordSet[$scopes].forEach(((scope,name)=>{this.#scopes.set(name,scope),Object.defineProperty(this,name,{configurable:!0,get:()=>this.#scopedWhere(name)})}))}#scopedWhere(scopeName){const[matcherFn,comparatorFn]=this.#scopes.get(scopeName);let matches=[];for(const[id,value]of this.entries())matcherFn(value,id,this)&&matches.push([id,value]);return comparatorFn&&matches.sort((([id1,value1],[id2,value2])=>comparatorFn(value1,value2,id1,id2))),new RecordSet({iterable:matches,copyScopesFrom:this}).freeze()}static#validateProperty(callbackType,callbackName,callback,callbacks){if("function"!=typeof callback)throw new TypeError(`${callbackType} ${callbackName} is not a function.`);if(callbacks.has(callbackName))throw new DuplicationError(`${callbackType} ${callbackName} already exists.`);return callback}static#validateFunction(callbackType,callbackName,callback){if("function"!=typeof callback)throw new TypeError(`${callbackType} ${callbackName} is not a function.`);return callback}static#validateContains(objectType,objectName,objects){if(!objects.has(objectName))throw new ReferenceError(`${objectType} ${objectName} does not exist.`);return objectName}}const set=RecordSet,{$groupTag}=symbols;class RecordGroup extends set{#groupName;constructor({iterable=[],copyScopesFrom=null,groupName=""}={}){super({iterable,copyScopesFrom}),this.#groupName=groupName}get[$groupTag](){return this.#groupName}get[Symbol.toStringTag](){return this[$groupTag]}}const{$fields,$defaultValue:handler_$defaultValue,$properties,$cachedProperties:handler_$cachedProperties,$methods,$relationships,$validators:handler_$validators,$recordValue:handler_$recordValue,$wrappedRecordValue:handler_$wrappedRecordValue,$recordModel:handler_$recordModel,$recordTag:handler_$recordTag,$isRecord:handler_$isRecord,$get}=symbols;class RecordHandler{#model;constructor(model){this.#model=model}get model(){return this.#model}createRecord(recordData){if(!recordData)throw new TypeError("Record data cannot be empty.");if("object"!=typeof recordData)throw new TypeError("Record data must be an object.");const modelName=this.#getModelName(),newRecordId=RecordHandler.#validateNewRecordId(modelName,recordData.id,this.#model.records),clonedRecord=deepClone(recordData),extraProperties=Object.keys(clonedRecord).filter((property=>!this.#hasField(property)&&!this.#isRecordId(property)));extraProperties.length>0&&console.warn(`${modelName} record has extra fields: ${extraProperties.join(", ")}.`);const newRecord=new record({id:newRecordId,...extraProperties.reduce(((obj,property)=>({...obj,[property]:clonedRecord[property]})),{})},this);return this.#getFieldNames().forEach((field=>{this.set(newRecord,field,clonedRecord[field],newRecord,!0)})),this.#getValidators().forEach(((validator,validatorName)=>{if(!validator(newRecord,this.#model.records))throw new RangeError(`${modelName} record with id ${newRecordId} failed validation for ${validatorName}.`)})),[newRecordId,newRecord]}get(record,property){return this.#hasRelationshipField(property)?this.#getRelationship(record,property):this.#isRecordId(property)||this.#hasField(property)?this.#getFieldValue(record,property):this.#hasProperty(property)?this.#getProperty(record,property):this.#hasMethod(property)?this.#getMethod(record,property):this.#isCallToSerialize(property)?RecordHandler.#recordToObject(record,this.#model,this):this.#isCallToString(property)?()=>this.getRecordId(record):this.#isKnownSymbol(property)?this.#getKnownSymbol(record,property):void 0}set(record,property,value,receiver,skipValidation){const recordValue=record[handler_$recordValue],recordId=this.getRecordId(record),otherRecords=this.#model.records.except(recordId);if(this.#hasProperty(property))throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set property ${property}.`);if(this.#hasMethod(property))throw new TypeError(`${this.#getModelName()} record ${recordId} cannot set method ${property}.`);if(this.#hasField(property)){const field=this.#getField(property);RecordHandler.#setRecordField(this.#model.name,record,field,value,this.#hasRelationshipField(property)),field[handler_$validators].forEach(((validator,validatorName)=>{if(![null,void 0].includes(recordValue[property])&&!validator(recordValue,otherRecords))throw new RangeError(`${this.#getModelName()} record with id ${recordId} failed validation for ${validatorName}.`)}))}else console.warn(`${this.#model.name} record has extra field: ${property}.`),recordValue[property]=value;return skipValidation||this.#getValidators().forEach(((validator,validatorName)=>{if(!validator(recordValue,otherRecords))throw new RangeError(`${this.#getModelName()} record with id ${recordId} failed validation for ${validatorName}.`)})),!0}static#setRecordField(modelName,record,field,value,isRelationship){const recordValue=!isRelationship&&types_undefined(value)?field[handler_$defaultValue]:value;if(!isRelationship&&!field.typeCheck(recordValue))throw new TypeError(`${modelName} record has invalid value for field ${field.name}.`);record[handler_$wrappedRecordValue]&&record[handler_$cachedProperties].clear(),record[handler_$recordValue][field.name]=recordValue}static#recordToObject(record,model){const recordValue=record[handler_$recordValue],fields=model[$fields],object={id:recordValue.id};return fields.forEach((field=>{void 0!==recordValue[field.name]&&(object[field.name]=recordValue[field.name])})),()=>object}static#validateNewRecordId=(modelName,id,records)=>{let newRecordId=id;if(!recordId(newRecordId))throw new TypeError(`${modelName} record has invalid id.`);if(records.has(newRecordId))throw new DuplicationError(`${modelName} record with id ${newRecordId} already exists.`);return newRecordId};#getModelName(){return this.#model.name}#getFieldNames(){return[...this.#model[$fields].keys()]}#getValidators(){return this.#model[handler_$validators]}#isRecordId(property){return"id"===property}getRecordId(record){return record[handler_$recordValue].id}#hasField(property){return this.#model[$fields].has(property)}#getField(property){return this.#model[$fields].get(property)}#getFieldValue(record,property){return record[handler_$recordValue][property]}#hasProperty(property){return this.#model[$properties].has(property)}#getProperty(record,property){if(this.#model[handler_$cachedProperties].has(property)){if(record[handler_$cachedProperties]&&record[handler_$cachedProperties].has(property))return record[handler_$cachedProperties].get(property);const value=this.#model[$properties].get(property)(record[handler_$wrappedRecordValue]);return record[handler_$cachedProperties].set(property,value),value}return this.#model[$properties].get(property)(record[handler_$wrappedRecordValue])}#hasMethod(method){return this.#model[$methods].has(method)}#getMethod(record,method){const methodFn=this.#model[$methods].get(method);return(...args)=>methodFn(record[handler_$wrappedRecordValue],...args)}#hasRelationshipField(property){return!!this.#hasField(property)&&this.#model[$relationships].has(`${property}.${property}`)}#getRelationship(record,property){return this.#model[$relationships].get(`${property}.${property}`)[$get](this.#getModelName(),property,record[handler_$recordValue])}#isCallToSerialize(property){return"toObject"===property||"toJSON"===property}#isCallToString(property){return"toString"===property}#isKnownSymbol(property){return[handler_$recordModel,handler_$recordTag,handler_$recordValue,handler_$isRecord].includes(property)}#getKnownSymbol(record,property){return property===handler_$isRecord||record[property]}}const handler=RecordHandler,{$fields:model_$fields,$properties:model_$properties,$cachedProperties:model_$cachedProperties,$methods:model_$methods,$scopes:model_$scopes,$relationships:model_$relationships,$validators:model_$validators,$recordHandler:model_$recordHandler,$addScope:model_$addScope,$addRelationshipAsField,$addRelationshipAsProperty,$getField,$getProperty,$removeScope:model_$removeScope,$instances,$handleExperimentalAPIMessage}=symbols,allStandardTypes=[...Object.keys(standardTypes),"enum"];class Model extends(external_events_default()){#records;#recordHandler;#fields;#properties;#methods;#relationships;#validators;#cachedProperties;static#instances=new Map;constructor({name,fields={},properties={},methods={},scopes={},validators={}}={}){if(super(),this.name=validateName("Model",name),Model.#instances.has(name))throw new DuplicationError(`A model named ${name} already exists.`);this.#records=new set,this.#recordHandler=new handler(this),this.#fields=new Map,this.#properties=new Map,this.#methods=new Map,this.#relationships=new Map,this.#validators=new Map,this.#cachedProperties=new Set,Object.entries(fields).forEach((([fieldName,field])=>{this.addField({name:fieldName,...field})})),Object.entries(properties).forEach((([propertyName,property])=>{"object"==typeof property?this.addProperty({name:propertyName,...property}):this.addProperty({name:propertyName,body:property})})),Object.entries(methods).forEach((([methodName,method])=>{this.addMethod(methodName,method)})),Object.entries(scopes).forEach((([scopeName,scope])=>{this.addScope(scopeName,...Model.#parseScope(scope))})),Object.entries(validators).forEach((([validatorName,validator])=>{this.addValidator(validatorName,validator)})),Model.#instances.set(this.name,this)}addField(fieldOptions){this.emit("beforeAddField",{field:fieldOptions,model:this});const field=Model.#parseField(this.name,fieldOptions,["id",...this.#fields.keys(),...this.#properties.keys(),...this.#methods.keys()]);return this.#fields.set(fieldOptions.name,field),this.emit("fieldAdded",{field,model:this}),this.emit("change",{type:"fieldAdded",field,model:this}),field}addProperty({name,body,cache=!1}){this.emit("beforeAddProperty",{property:{name,body},model:this});const propertyName=validateName("Property",name);this.#properties.set(propertyName,Model.#validateFunction("Property",name,body,["id",...this.#fields.keys(),...this.#properties.keys(),...this.#methods.keys()])),cache&&this.#cachedProperties.add(propertyName),this.emit("propertyAdded",{property:{name:propertyName,body},model:this}),this.emit("change",{type:"propertyAdded",property:{name:propertyName,body},model:this})}addMethod(name,method){this.emit("beforeAddMethod",{method:{name,body:method},model:this});const methodName=validateName("Method",name);this.#methods.set(methodName,Model.#validateFunction("Method",name,method,["id",...this.#fields.keys(),...this.#properties.keys(),...this.#methods.keys()])),this.emit("methodAdded",{method:{name:methodName,body:method},model:this}),this.emit("change",{type:"methodAdded",method:{name:methodName,body:method},model:this})}addScope(name,scope,sortFn){this.emit("beforeAddScope",{scope:{name,body:scope},model:this});const scopeName=validateName("Scope",name);this.#records[model_$addScope](scopeName,scope,sortFn),this.emit("scopeAdded",{scope:{name:scopeName,body:scope},model:this}),this.emit("change",{type:"scopeAdded",scope:{name:scopeName,body:scope},model:this})}removeScope(name){if(!Model.#validateContains(this.name,"Scope",name,this.#records[model_$scopes]))return!1;const scope=this.#records[model_$scopes].get(name);return this.emit("beforeRemoveScope",{scope:{name,body:scope},model:this}),this.#records[model_$removeScope](name),this.emit("scopeRemoved",{scope:{name},model:this}),this.emit("change",{type:"scopeRemoved",scope:{name,body:scope},model:this}),!0}addValidator(name,validator){this.emit("beforeAddValidator",{validator:{name,body:validator},model:this}),this.#validators.set(name,Model.#validateFunction("Validator",name,validator,[...this.#validators.keys()])),this.emit("validatorAdded",{validator:{name,body:validator},model:this}),this.emit("change",{type:"validatorAdded",validator:{name,body:validator},model:this})}removeValidator(name){if(!Model.#validateContains(this.name,"Validator",name,this.#validators))return!1;const validator=this.#validators.get(name);return this.emit("beforeRemoveValidator",{validator:{name,body:validator},model:this}),this.#validators.delete(name),this.emit("validatorRemoved",{validator:{name},model:this}),this.emit("change",{type:"validatorRemoved",validator:{name,body:validator},model:this}),!0}createRecord(record){this.emit("beforeCreateRecord",{record,model:this});const[newRecordId,newRecord]=this.#recordHandler.createRecord(record);return this.#records.set(newRecordId,newRecord),this.emit("recordCreated",{newRecord,model:this}),newRecord}removeRecord(recordId){if(!this.#records.has(recordId))return console.warn(`Record ${recordId} does not exist.`),!1;const record=this.#records.get(recordId);return this.emit("beforeRemoveRecord",{record,model:this}),this.#records.delete(recordId),this.emit("recordRemoved",{record:{id:recordId},model:this}),!0}updateRecord(recordId,record){if("object"!=typeof record)throw new TypeError("Record data must be an object.");if(!this.#records.has(recordId))throw new ReferenceError(`Record ${recordId} does not exist.`);const oldRecord=this.#records.get(recordId);return this.emit("beforeUpdateRecord",{record:oldRecord,newRecord:{id:recordId,...record},model:this}),Object.entries(record).forEach((([fieldName,fieldValue])=>{oldRecord[fieldName]=fieldValue})),this.emit("recordUpdated",{record:oldRecord,model:this}),oldRecord}get records(){return this.#records}static get[$instances](){return Model.#instances}get[model_$recordHandler](){return this.#recordHandler}get[model_$fields](){return this.#fields}get[model_$properties](){return this.#properties}get[model_$cachedProperties](){return this.#cachedProperties}get[model_$methods](){return this.#methods}get[model_$relationships](){return this.#relationships}get[model_$validators](){return this.#validators}[$addRelationshipAsField](relationship){const{name,type,fieldName,field}=relationship[$getField](),relationshipName=`${name}.${fieldName}`;if(this.emit("beforeAddRelationship",{relationship:{name,type},model:this}),["id",...this.#fields.keys(),...this.#properties.keys(),...this.#methods.keys()].includes(fieldName))throw new NameError(`Relationship field ${fieldName} is already in use.`);if(this.#relationships.has(relationshipName))throw new NameError(`Relationship ${relationshipName} is already in use.`);this.#fields.set(fieldName,field),this.#relationships.set(relationshipName,relationship),this.emit("relationshipAdded",{relationship:{name,type},model:this}),this.emit("change",{type:"relationshipAdded",relationship:{relationship:{name,type},model:this},model:this})}[$addRelationshipAsProperty](relationship){const{name,type,propertyName,property}=relationship[$getProperty](),relationshipName=`${name}.${propertyName}`;if(this.emit("beforeAddRelationship",{relationship:{name,type},model:this}),["id",...this.#fields.keys(),...this.#properties.keys(),...this.#methods.keys()].includes(propertyName))throw new NameError(`Relationship property ${propertyName} is already in use.`);if(this.#relationships.has(relationshipName))throw new NameError(`Relationship ${name} is already in use.`);this.#properties.set(propertyName,property),this.#relationships.set(relationshipName,relationship),this.emit("relationshipAdded",{relationship:{name,type},model:this}),this.emit("change",{type:"relationshipAdded",relationship:{relationship:{name,type},model:this},model:this})}static#parseField(modelName,field,restrictedNames){validateObjectWithUniqueName({objectType:"Field",parentType:"Model",parentName:modelName},field,restrictedNames);return allStandardTypes.includes(field.type)?Field[field.type](field):("function"==typeof field.type&&Schema[$handleExperimentalAPIMessage](`The provided type for ${field.name} is not part of the standard types. Function types are experimental and may go away in a later release.`),new Field(field))}static#parseScope(scope){if("function"==typeof scope)return[scope];if("object"==typeof scope){const{matcher,sorter}=scope;if("function"!=typeof matcher)throw new TypeError("The provided matcher for the scope is not a function.");if(sorter&&"function"!=typeof sorter)throw new TypeError("The provided sorter for the scope is not a function.");return[matcher,sorter]}throw new TypeError("The provided scope is not a function or valid object.")}static#validateFunction(callbackType,callbackName,callback,restrictedNames){if("function"!=typeof callback)throw new TypeError(`${callbackType} ${callbackName} is not a function.`);if(restrictedNames.includes(callbackName))throw new DuplicationError(`${callbackType} ${callbackName} already exists.`);return callback}static#validateContains(modelName,objectType,objectName,objects){return!!objects.has(objectName)||(console.warn(`Model ${modelName} does not contain a ${objectType.toLowerCase()} named ${objectName}.`),!1)}}const{$recordValue:relationship_$recordValue,$fields:relationship_$fields,$getField:relationship_$getField,$getProperty:relationship_$getProperty,$get:relationship_$get,$defaultValue:relationship_$defaultValue,$instances:relationship_$instances,$handleExperimentalAPIMessage:relationship_$handleExperimentalAPIMessage}=symbols,relationshipEnum={oneToOne:"oneToOne",oneToMany:"oneToMany",manyToOne:"manyToOne",manyToMany:"manyToMany"};class Relationship{#type;#from;#to;#name;#reverseName;#relationshipField;#relationshipProperty;constructor({from,to,type}={}){Schema[relationship_$handleExperimentalAPIMessage]("Relationships are experimental in the current version. There is neither validation of existence in foreign tables nor guarantee that associations work. Please use with caution."),this.#type=Relationship.#validateType(type);const[fromModel,fromName,toModel,toName]=Relationship.#parseModelsAndNames(from,to,type);if(this.#from=fromModel,this.#to=toModel,this.#name=fromName,this.#reverseName=toName,this.#to===this.#from&&Relationship.#isSymmetric(this.#type)&&this.#name===this.#reverseName)throw new RangeError("Relationship cannot be symmetric if the from and to models are the same and no name is provided for either one.");this.#relationshipField=Relationship.#createField(this.#name,this.#type),this.#relationshipProperty=record=>this.#getAssociatedRecordsReverse(record)}[relationship_$getField](){return{name:this.#name,type:this.#type,fieldName:this.#name,field:this.#relationshipField}}[relationship_$getProperty](){return{name:this.#name,type:this.#type,propertyName:this.#reverseName,property:this.#relationshipProperty}}[relationship_$get](modelName,property,record){return modelName===this.#from.name&&property===this.#name?this.#getAssociatedRecords(record):modelName===this.#to.name&&property===this.#reverseName?(console.warn("Relationship getter called by the receiver model. This might indicate an issue with the library and should be reported."),this.#getAssociatedRecordsReverse(record)):void 0}#getAssociatedRecords(record){if(Relationship.#isToOne(this.#type)){const associationValue=record[this.#name];return this.#to.records.get(associationValue)}const associationValues=record[this.#name]||[];return this.#to.records.only(...associationValues)}#getAssociatedRecordsReverse(record){const associationValue=record.id,matcher=Relationship.#isToOne(this.#type)?associatedRecord=>associatedRecord[relationship_$recordValue][this.#name]===associationValue:associatedRecord=>{const associatedRecordValue=associatedRecord[relationship_$recordValue][this.#name];return![void 0,null].includes(associatedRecordValue)&&associatedRecord[relationship_$recordValue][this.#name].includes(associationValue)};return Relationship.#isFromOne(this.#type)?this.#from.records.find(matcher):this.#from.records.where(matcher)}static#isToOne(type){return[relationshipEnum.oneToOne,relationshipEnum.manyToOne].includes(type)}static#isToMany(type){return[relationshipEnum.oneToMany,relationshipEnum.manyToMany].includes(type)}static#isFromOne(type){return[relationshipEnum.oneToMany,relationshipEnum.oneToOne].includes(type)}static#isFromMany(type){return[relationshipEnum.manyToOne,relationshipEnum.manyToMany].includes(type)}static#isSymmetric(type){return[relationshipEnum.oneToOne,relationshipEnum.manyToMany].includes(type)}static#createField(name,relationshipType){const isSingleSource=Relationship.#isFromOne(relationshipType),isMultiple=Relationship.#isToMany(relationshipType),type=isMultiple?recordIdArray:recordId,validators={};isSingleSource&&!isMultiple&&(validators.unique=!0),isMultiple&&(validators.uniqueValues=!0);const relationshipField=new Field({name,type,defaultValue:isMultiple?[]:null,validators});return Object.defineProperty(relationshipField,relationship_$defaultValue,{get(){throw new DefaultValueError("Relationship field does not have a default value.")}}),relationshipField}static#validateType(relationshipType){if(!Object.values(relationshipEnum).includes(relationshipType))throw new TypeError(`Invalid relationship type: ${relationshipType}.`);return relationshipType}static#validateModel(modelData){const modelName="string"==typeof modelData?modelData:modelData.model;if(!Model[relationship_$instances].has(modelName))throw new ReferenceError(`Model ${modelName} does not exist.`);return Model[relationship_$instances].get(modelName)}static#createName(type,to){return Relationship.#isToOne(type)?reverseCapitalize(to):Relationship.#isToMany(type)?`${reverseCapitalize(to)}Set`:void 0}static#createReverseName=(type,from)=>Relationship.#isFromOne(type)?reverseCapitalize(from):Relationship.#isFromMany(type)?`${reverseCapitalize(from)}Set`:void 0;static#validateModelParams(modelData){const model=Relationship.#validateModel(modelData),name="string"==typeof modelData?null:validateName("Field",modelData.name);if(null!==name&&model[relationship_$fields].has(name))throw new DuplicationError(`Field ${name} already exists in ${model.name}.`);return[model,name]}static#parseModelsAndNames(from,to,type){let fromModel,fromName,toModel,toName;return[fromModel,fromName]=Relationship.#validateModelParams(from),[toModel,toName]=Relationship.#validateModelParams(to),null===fromName&&(fromName=Relationship.#createName(type,toModel.name)),null===toName&&(toName=Relationship.#createReverseName(type,fromModel.name)),[fromModel,fromName,toModel,toName]}}class Serializer{#name;#attributes;#methods;constructor({name,attributes=[],methods={}}){this.#name=validateName("Serializer",name),this.#attributes=new Map,this.#methods=new Map,attributes.forEach((attribute=>{const[attributeValue,attributeName]="string"==typeof attribute?[attribute,attribute]:attribute;this.#attributes.set(Serializer.#validateAttribute(attributeName,[...this.#attributes.keys()]),attributeValue)})),Object.entries(methods).forEach((([methodName,methodBody])=>{this.addMethod(methodName,methodBody)}))}addMethod(methodName,methodBody){const method=Serializer.#validateFunction(methodName,methodBody,[...this.#methods.keys()]);this.#methods.set(methodName,method)}serialize(object,options){const serialized={};return this.#attributes.forEach(((attributeValue,attributeName)=>{const value=this.#methods.has(attributeValue)?this.#methods.get(attributeValue)(object,options):object[attributeValue];void 0!==value&&(serialized[attributeName]=value)})),serialized}serializeArray(objects,options){return objects.map((object=>this.serialize(object,options)))}serializeRecordSet(objects,options,keyMapFn){const serialized={};return objects.forEach(((value,key)=>{const mappedKey=keyMapFn(key,value);void 0!==mappedKey&&(serialized[mappedKey]=this.serialize(value,options))})),serialized}get name(){return this.#name}static#validateAttribute(attributeName,restrictedNames){if("string"!=typeof attributeName)throw new TypeError(`Attribute ${attributeName} is not a string.`);if(restrictedNames.includes(attributeName))throw new DuplicationError(`Attribute ${attributeName} already exists.`);return attributeName}static#validateFunction(callbackName,callback,restrictedNames){if("function"!=typeof callback)throw new TypeError(`Method ${callbackName} is not a function.`);if(restrictedNames.includes(callbackName))throw new DuplicationError(`Method ${callbackName} already exists.`);return callback}}const{$addRelationshipAsField:schema_$addRelationshipAsField,$addRelationshipAsProperty:schema_$addRelationshipAsProperty,$handleExperimentalAPIMessage:schema_$handleExperimentalAPIMessage,$instances:schema_$instances}=symbols;class Schema extends(external_events_default()){#name;#models;#serializers;static defaultConfig={experimentalAPIMessages:"warn"};static config={...Schema.defaultConfig};static#schemas=new Map;constructor({name,models=[],relationships=[],serializers=[],config={}}={}){super(),this.#name=validateName("Schema",name),this.#models=new Map,this.#serializers=new Map,Schema.#parseConfig(config),Schema.#schemas.set(this.#name,this);const lazyPropertyMap={};models.forEach((model=>{const{lazyProperties,...modelData}=Schema.#separateModelProperties(model);Object.keys(lazyProperties).length&&(lazyPropertyMap[modelData.name]=lazyProperties),this.createModel(modelData)})),relationships.forEach((relationship=>this.createRelationship(relationship))),serializers.forEach((serializer=>this.createSerializer(serializer)));const schemaData={models:Object.fromEntries([...this.#models.entries()]),serializers:Object.fromEntries([...this.#serializers.entries()])};models.forEach((model=>{const modelRecord=this.getModel(model.name),lazyProperties=lazyPropertyMap[model.name]||{};lazyProperties&&Object.entries(lazyProperties).forEach((([propertyName,{body:propertyInitializer,cache}])=>{modelRecord.addProperty({name:propertyName,body:value=>propertyInitializer(value,this.#schemaObject),cache})})),model.lazyMethods&&Object.entries(model.lazyMethods).forEach((([methodName,methodInitializer])=>{modelRecord.addMethod(methodName,methodInitializer(schemaData))}))})),serializers.forEach((serializer=>{const serializerRecord=this.getSerializer(serializer.name);serializer.lazyMethods&&Object.entries(serializer.lazyMethods).forEach((([methodName,methodInitializer])=>{serializerRecord.addMethod(methodName,methodInitializer(schemaData))}))}))}createModel(modelData){this.emit("beforeCreateModel",{model:modelData,schema:this});const model=Schema.#parseModel(this.#name,modelData,this.#models);return this.#models.set(model.name,model),model.on("change",(({type,...eventData})=>{this.emit("change",{type:`model${capitalize(type)}`,...eventData,schema:this})})),this.emit("modelCreated",{model,schema:this}),this.emit("change",{type:"modelCreated",model,schema:this}),model}getModel(name){return this.#models.get(name)}removeModel(name){const model=this.getModel(name);if(this.emit("beforeRemoveModel",{model,schema:this}),!this.#models.has(name))throw new ReferenceError(`Model ${name} does not exist in schema ${this.#name}.`);this.#models.delete(name),Model[schema_$instances].delete(name),this.emit("modelRemoved",{model:{name},schema:this}),this.emit("change",{type:"modelRemoved",model,schema:this})}createRelationship(relationshipData){this.emit("beforeCreateRelationship",{relationship:relationshipData,schema:this});const relationship=Schema.#applyRelationship(this.#name,relationshipData,this.#models);return this.emit("relationshipCreated",{relationship,schema:this}),this.emit("change",{type:"relationshipCreated",relationship,schema:this}),relationship}createSerializer(serializerData){this.emit("beforeCreateSerializer",{serializer:serializerData,schema:this});const serializer=Schema.#parseSerializer(this.#name,serializerData,this.#serializers);return this.#serializers.set(serializer.name,serializer),this.emit("serializerCreated",{serializer,schema:this}),this.emit("change",{type:"serializerCreated",serializer,schema:this}),serializer}getSerializer(name){return this.#serializers.get(name)}get name(){return this.#name}get models(){return this.#models}static create(schemaData){return new Schema(schemaData)}static get(name){return Schema.#schemas.get(name)}get(pathName){this.emit("beforeGet",{pathName,schema:this});const[modelName,recordId,...rest]=pathName.split("."),model=this.getModel(modelName);if(!model)throw new ReferenceError(`Model ${modelName} does not exist in schema ${this.#name}.`);if(void 0===recordId)return model;const record=model.records.get(recordId);if(!rest.length)return record;if(!record)throw new ReferenceError(`Record ${recordId} does not exist in model ${modelName}.`);const result=rest.reduce(((acc,key)=>acc[key]),record);return this.emit("got",{pathName,result,schema:this}),result}static[schema_$handleExperimentalAPIMessage](message){const{experimentalAPIMessages}=Schema.config;if("warn"===experimentalAPIMessages)console.warn(message);else if("error"===experimentalAPIMessages)throw new ExperimentalAPIUsageError(message)}get#schemaObject(){return{models:Object.fromEntries([...this.#models.entries()]),serializers:Object.fromEntries([...this.#serializers.entries()])}}static#parseModel(schemaName,modelData,models){return validateObjectWithUniqueName({objectType:"Model",parentType:"Schema",parentName:schemaName},modelData,[...models.keys()]),new Model(modelData)}static#separateModelProperties(modelData){const{properties:modelProperties={},...model}=modelData,[properties,lazyProperties]=Object.entries(modelProperties).reduce(((acc,[propertyName,property])=>{const isObject="object"==typeof property,propertyFn=isObject?property.body:property;return acc[2===propertyFn.length?1:0][propertyName]={body:propertyFn,cache:!!isObject&&Boolean(property.cache)},acc}),[{},{}]);return{...model,properties,lazyProperties}}static#applyRelationship(schemName,relationshipData,models){const{from,to,type}=relationshipData;[from,to].forEach((model=>{if(!["string","object"].includes(typeof model))throw new TypeError(`Invalid relationship model: ${model}.`)}));const fromModelName="string"==typeof from?from:from.model,toModelName="string"==typeof to?to:to.model,fromModel=models.get(fromModelName),toModel=models.get(toModelName);if(!fromModel)throw new ReferenceError(`Model ${fromModelName} not found in schema ${schemName} when attempting to create a relationship.`);if(!toModel)throw new ReferenceError(`Model ${toModelName} not found in schema ${schemName} when attempting to create a relationship.`);const relationship=new Relationship({from,to,type});return fromModel[schema_$addRelationshipAsField](relationship),toModel[schema_$addRelationshipAsProperty](relationship),relationship}static#parseSerializer(schemaName,serializerData,serializers){return validateObjectWithUniqueName({objectType:"Serializer",parentType:"Schema",parentName:schemaName},serializerData,[...serializers.keys()]),new Serializer(serializerData)}static#parseConfig(config={}){config&&["experimentalAPIMessages"].forEach((key=>{void 0!==config[key]&&["warn","error","off"].includes(config[key])&&(Schema.config[key]=config[key])}))}}const src=Schema;return __webpack_exports__})()));