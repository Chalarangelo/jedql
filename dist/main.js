!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["@jsiqle/core"]=t():e["@jsiqle/core"]=t()}(global,(function(){return(()=>{"use strict";var e={n:t=>{var r=t&&t.__esModule?()=>t.default:()=>t;return e.d(r,{a:r}),r},d:(t,r)=>{for(var i in r)e.o(r,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:r[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>rt});const r=require("events");var i=e.n(r);const s=["fields","key","keyType","methods","scopes","relationships","relationshipField","validators","recordModel","recordValue","recordHandler","recordTag","defaultValue","addScope","addRelationshipAsField","addRelationshipAsMethod","getField","getMethod","removeScope","copyScopes","instances","isRecord","groupTag","get","handleExperimentalAPIMessage"].reduce(((e,t)=>(e[`$${t}`]=Symbol.for(t),e)),{});class o extends Error{constructor(e){super(e),this.name="NameError"}}class a extends Error{constructor(e){super(e),this.name="ValidationError"}}class n extends Error{constructor(e){super(e),this.name="DuplicationError"}}class d extends Error{constructor(e){super(e),this.name="DefaultValueError"}}class l extends Error{constructor(e){super(e),this.name="ExperimentalAPIUsageError"}}class h{static unique(e){return(t,r)=>r.every((r=>r[e]!==t[e]))}static length(e,[t,r]){return i=>i[e].length>=t&&i[e].length<=r}static minLength(e,t){return r=>r[e].length>=t}static maxLength(e,t){return r=>r[e].length<=t}static range(e,[t,r]){return i=>i[e]>=t&&i[e]<=r}static min(e,t){return r=>r[e]>=t}static max(e,t){return r=>r[e]<=t}static integer(e){return t=>Number.isInteger(t[e])}static regex(e,t){return r=>t.test(r[e])}static uniqueValues(e){return t=>new Set(t[e]).size===t[e].length}static sortedAscending(e){return t=>t[e].every(((r,i)=>0===i||r>=t[e][i-1]))}static sortedDescending(e){return t=>t[e].every(((r,i)=>0===i||r<=t[e][i-1]))}static custom(e,t){return(r,i)=>t(r[e],i.map((t=>t[e])))}}const c={Model:["toString","toObject","toJSON"],Field:["toString","toObject","toJSON"],Relationship:["toString","toObject","toJSON"]},m=(e,t)=>{const[r,i]=((e,t=[])=>"string"!=typeof e?[!1,"must be a string"]:e?/^\d/.test(e)?[!1,"cannot start with a number"]:t.includes(e)?[!1,"is reserved"]:[/^\w+$/.test(e),"must contain only alphanumeric characters, numbers or underscores"]:[!1,"is required"])(t,c[e]);if(!r)throw new o(`${e} name ${i}.`);return t},u=([e,...t])=>e.toUpperCase()+t.join(""),p=([e,...t])=>e.toLowerCase()+t.join(""),f=e=>{if(null===e)return null;let t=Object.assign({},e);return Object.entries(t).forEach((([r,i])=>t[r]="object"==typeof e[r]?f(i):i)),Array.isArray(e)?(t.length=e.length,Array.from(t)):t},y=({objectType:e,parentType:t,parentName:r},i,s)=>{if(!(e=>e&&"object"==typeof e)(i))throw new TypeError(`${e} ${i} is not an object.`);if(((e,t)=>e.includes(t))(s,i.name))throw new n(`${t} ${r} already has a ${e.toLowerCase()} named ${i.name}.`);return!0},g=e=>"boolean"==typeof e,w=e=>"number"==typeof e&&e==e,b=e=>"string"==typeof e,v=e=>e instanceof Date,$=(...e)=>t=>e.every((e=>e(t))),M=(...e)=>t=>e.some((e=>e(t))),R=e=>e>=0,F=e=>t=>Array.isArray(t)&&t.every(e),T=e=>{const t=Object.keys(e);return r=>null!=r&&"object"==typeof r&&(Object.keys(r).length===t.length&&t.every((t=>e[t](r[t]))))},O=e=>t=>null!=t&&"object"==typeof t&&Object.keys(t).every((r=>e(t[r]))),S=e=>null===e,j=e=>void 0===e,E=M(S,j),V={bool:g,number:w,positiveNumber:$(w,R),string:b,date:v,stringOrNumber:M(b,w),numberOrString:M(b,w),enum:(...e)=>t=>e.includes(t),boolArray:F(g),numberArray:F(w),stringArray:F(b),dateArray:F(v),oneOf:M,arrayOf:F,oneOrArrayOf:e=>t=>M(F(e),e)(t),object:T,objectOf:O,optional:e=>t=>M(E,e)(t),null:S,undefined:j,nil:E},A={boolean:{type:g,defaultValue:!1},number:{type:w,defaultValue:0},positiveNumber:{type:$(w,R),defaultValue:0},string:{type:b,defaultValue:""},date:{type:v,defaultValue:new Date},stringOrNumber:{type:M(b,w),defaultValue:""},numberOrString:{type:M(b,w),defaultValue:0},booleanArray:{type:F(g),defaultValue:[]},numberArray:{type:F(w),defaultValue:[]},stringArray:{type:F(b),defaultValue:[]},dateArray:{type:F(v),defaultValue:[]},object:{type:T({}),defaultValue:{}},booleanObject:{type:O(g),defaultValue:{a:!0}},numberObject:{type:O(w),defaultValue:{}},stringObject:{type:O(b),defaultValue:{}},dateObject:{type:O(v),defaultValue:{}},objectArray:{type:F(T({})),defaultValue:[]}},k=$(b,(e=>0!==e.trim().length)),{$defaultValue:N,$validators:x}=s;class C{#e;#t;#r;#i;#s;constructor({name:e,type:t,required:r=!1,defaultValue:i=null,validators:s={}}){this.#e=m("Field",e),this.#r=C.#o(r),this.#i=C.#a(t,r),this.#t=C.#n(i,this.#i,this.#r),this.#s=new Map,Object.entries(s).forEach((([e,t])=>{this.addValidator(e,t)}))}addValidator(e,t){this.#s.set(...C.#d(this.#e,e,t))}get name(){return this.#e}get required(){return this.#r}typeCheck(e){return this.#i(e)}get[N](){return this.#t}get[x](){return this.#s}static#a(e,t){if("function"!=typeof e)throw new TypeError("Field type must be a function.");return t?e:V.optional(e)}static#o(e){if("boolean"!=typeof e)throw new TypeError("Field required must be a boolean.");return e}static#n(e,t,r){if(r&&V.nil(e))throw new a("Default value cannot be null or undefined.");if(!t(e))throw new a("Default value must be valid.");return e}static#d(e,t,r){if(void 0!==h[t])return[`${e}${u(t)}`,h[t](e,r)];if("function"!=typeof r)throw new TypeError(`Validator ${t} is not defined.`);return[`${e}${u(t)}`,h.custom(e,r)]}}Object.entries(A).forEach((([e,t])=>{const{type:r,defaultValue:i}=t;C[e]=e=>new C("string"==typeof e?{name:e,type:r}:{...e,type:r}),C[`${e}Required`]=e=>{if("string"==typeof e)return new C({name:e,type:r,required:!0,defaultValue:i});const t=e.defaultValue||i;return new C({...e,type:r,required:!0,defaultValue:t})}})),C.enum=({name:e,values:t})=>new C({name:e,type:V.enum(...t)}),C.enumRequired=({name:e,values:t,defaultValue:r=t[0]})=>new C({name:e,type:V.enum(...t),required:!0,defaultValue:r}),C.auto=e=>{const t="string"==typeof e?e:e.name,r=function*(){let e=0;for(;;)yield e++}();let i=0;const s=new C({name:t,type:e=>e===i,required:!0,defaultValue:i});return Object.defineProperty(s,N,{get(){const e=r.next().value;return i=e,e}}),s};const{$recordValue:q,$recordHandler:z,$recordModel:P,$recordTag:K,$key:I}=s;class H{#l;#h;constructor(e,t){return this.#l=e,this.#h=t,new Proxy(this,this.#h)}get[z](){return this.#h}get[q](){return this.#l}get[P](){return this.#h.model}get[K](){const e=this[P],t=e[I].name;return`${e.name}#${this[q][t]}`}get[Symbol.toStringTag](){return this[K]}}const D=H,{$recordTag:_}=s;class J{#c;constructor(e,t){Object.keys(e).forEach((t=>{this[t]=e[t]})),this.#c=t}get[_](){return this.#c}get[Symbol.toStringTag](){return this[_]}toObject(){return{...this}}toJSON(){return this.toObject()}}const{$recordTag:U}=s;class L extends Array{#c;constructor(e,t){super(),e.forEach((e=>{this.push(e)})),this.#c=t}get[U](){return this.#c}get[Symbol.toStringTag](){return this[U]}toObject(){return[...this]}toJSON(){return this.toObject()}}const{$recordModel:B,$recordTag:G,$scopes:Q,$addScope:W,$removeScope:X,$copyScopes:Y,$isRecord:Z,$key:ee,$handleExperimentalAPIMessage:te}=s;class re extends Map{#m;#u;constructor({iterable:e=[],copyScopesFrom:t=null}={}){super();for(const[t,r]of e)this.set(t,r);this.#u=new Map,t&&this[Y](t),this.#m=!1}freeze(){return this.#m=!0,this}set(e,t){if(tt[te]("Calling RecordSet.prototype.set() is discouraged as it may cause unexpected behavior. This method may be removed in a future version of the library."),this.#m)throw new TypeError("Cannot modify a frozen RecordSet.");return super.set(e,t),this}delete(e){if(this.#m)throw new TypeError("Cannot modify a frozen RecordSet.");return super.delete(e)}clear(){if(this.#m)throw new TypeError("Cannot modify a frozen RecordSet.");super.clear()}map(e){return[...this.entries()].reduce(((t,[r,i])=>(t[r]=e(i,r,this),t)),{})}flatMap(e){return[...this.entries()].map((([t,r])=>e(r,t,this)))}reduce(e,t){return[...this.entries()].reduce(((t,[r,i])=>e(t,i,r,this)),t)}filter(e){return[...this.entries()].reduce(((t,[r,i])=>(e(i,r,this)&&t.set(r,i),t)),new re({copyScopesFrom:this})).freeze()}flatFilter(e){return[...this.entries()].reduce(((t,[r,i])=>(e(i,r,this)&&t.push(i),t)),[])}find(e){const t=[...this.entries()].find((([t,r])=>e(r,t,this)));if(t)return t[1]}findKey(e){const t=[...this.entries()].find((([t,r])=>e(r,t,this)));if(t)return t[0]}only(...e){return new re({iterable:[...this.entries()].filter((([t])=>e.includes(t))),copyScopesFrom:this}).freeze()}except(...e){return new re({iterable:[...this.entries()].filter((([t])=>!e.includes(t))),copyScopesFrom:this}).freeze()}sort(e){const t=[...this.entries()].sort((([t,r],[i,s])=>e(r,s,t,i)));return new re({iterable:t,copyScopesFrom:this}).freeze()}every(e){return 0===this.size||[...this.entries()].every((([t,r])=>e(r,t,this)))}some(e){return 0!==this.size&&[...this.entries()].some((([t,r])=>e(r,t,this)))}select(...e){return new re({iterable:[...this.entries()].map((([t,r])=>{const i={};return e.forEach((e=>i[e]=r[e])),[t,new J(i,r[G])]})),copyScopesFrom:this}).freeze()}flatSelect(...e){return[...this.values()].map((t=>e.reduce(((e,r)=>({...e,[r]:t[r]})),{})))}pluck(...e){return new re({iterable:[...this.entries()].map((([t,r])=>{const i=e.map((e=>r[e]));return[t,new L(i,r[G])]})),copyScopesFrom:this}).freeze()}flatPluck(...e){const t=1===e.length;return[...this.values()].map((r=>t?r[e[0]]:e.map((e=>r[e]))))}groupBy(e){const t=new re({copyScopesFrom:this,iterable:[]});for(const[r,i]of this.entries()){let s=i[e];null!=s&&s[Z]&&(s=i[e][ee]),t.has(s)||t.set(s,new oe({copyScopesFrom:this,iterable:[],groupName:s})),t.get(s).set(r,i)}for(const e of t.values())e.freeze();return t.freeze()}where(e){return this.filter(e)}whereNot(e){return this.filter(((t,r,i)=>!e(t,r,i)))}*batchIterator(e){let t=[];for(const[,r]of this)t.push(r),t.length===e&&(yield t,t=[]);t.length&&(yield t)}limit(e){let t=[];for(const[r,i]of this)if(t.push([r,i]),t.length===e)break;return new re({iterable:t,copyScopesFrom:this}).freeze()}offset(e){let t=0,r=[];for(const[i,s]of this)t<e?t++:r.push([i,s]);return new re({iterable:r,copyScopesFrom:this}).freeze()}get first(){for(const[,e]of this)return e}get last(){if(0!==this.size)return[...this.entries()].pop()[1]}get count(){return this.size}toArray(){return[...this.values()]}toFlatArray(){return[...this.values()].map((e=>e instanceof oe?e.toFlatArray():e.toObject()))}toObject(){return[...this.entries()].reduce(((e,[t,r])=>(e[t]=r,e)),{})}toFlatObject(){return[...this.entries()].reduce(((e,[t,r])=>(e[t]=r instanceof oe?r.toFlatArray():r.toObject(),e)),{})}toJSON(){return this.toObject()}get[Symbol.toStringTag](){const e=[...this.values()];try{const t=e[0][B].name;if(((e,t)=>{const r=t(e[0]);return e.every((e=>t(e)===r))})(e,(e=>e[B].name===t)))return t}catch(e){return""}return""}static get[Symbol.species](){return Map}[W](e,t){if(re.#p("Scope",e,t,this.#u),this[e]||Object.getOwnPropertyNames(re.prototype).includes(e))throw new o(`Scope name ${e} is already in use.`);this.#u.set(e,t),Object.defineProperty(this,e,{configurable:!0,get:()=>this.where(this.#u.get(e))})}[X](e){this.#u.delete(re.#f("Scope",e,this.#u)),delete this[e]}[Y](e){e[Q].forEach(((e,t)=>{this[W](t,e)}))}get[Q](){return this.#u}static#p(e,t,r,i){if("function"!=typeof r)throw new TypeError(`${e} ${t} is not a function.`);if(i.has(t))throw new n(`${e} ${t} already exists.`);return r}static#f(e,t,r){if(!r.has(t))throw new ReferenceError(`${e} ${t} does not exist.`);return t}}const ie=re,{$groupTag:se}=s;class oe extends ie{#y;constructor({iterable:e=[],copyScopesFrom:t=null,groupName:r=""}={}){super({iterable:e,copyScopesFrom:t}),this.#y=r}get[se](){return this.#y}get[Symbol.toStringTag](){return this[se]}}const{$fields:ae,$defaultValue:ne,$key:de,$keyType:le,$methods:he,$relationships:ce,$validators:me,$recordValue:ue,$recordModel:pe,$recordTag:fe,$isRecord:ye,$get:ge}=s;class we{#g;constructor(e){this.#g=e}get model(){return this.#g}createRecord(e){if(!e)throw new TypeError("Record data cannot be empty.");if("object"!=typeof e)throw new TypeError("Record data must be an object.");const t=this.#w(),r=we.#b(t,this.#v(),e[this.#v().name],this.#g.records),i=f(e),s=Object.keys(i).filter((e=>!this.#$(e)&&!this.#M(e)));s.length>0&&console.warn(`${t} record has extra fields: ${s.join(", ")}.`);const o=new D({[this.#v().name]:r,...s.reduce(((e,t)=>({...e,[t]:i[t]})),{})},this);return this.#R().forEach((e=>{this.set(o,e,i[e],o,!0)})),this.#F().forEach(((e,i)=>{if(!e(o,this.#g.records))throw new RangeError(`${t} record with key ${r} failed validation for ${i}.`)})),[r,o]}get(e,t){return this.#T(t)?this.#O(e,t):this.#M(t)||this.#$(t)?this.#S(e,t):this.#j(t)?this.#E(e,t):this.#V(t)?we.#A(e,this.#g,this):this.#k(t)?()=>this.#N(e):this.#x(t)?this.#C(e,t):void 0}set(e,t,r,i,s){const o=e[ue],a=this.#N(e),n=this.#g.records.except(a);if(this.#j(t))throw new TypeError(`${this.#w()} record ${a} cannot set method ${t}.`);if(this.#$(t)){const e=this.#q(t);we.#z(this.#g.name,o,e,r),e[me].forEach(((e,r)=>{if(![null,void 0].includes(o[t])&&!e(o,n))throw new RangeError(`${this.#w()} record with key ${a} failed validation for ${r}.`)}))}else console.warn(`${this.#g.name} record has extra field: ${t}.`),o[t]=r;return s||this.#F().forEach(((e,t)=>{if(!e(o,n))throw new RangeError(`${this.#w()} record with key ${a} failed validation for ${t}.`)})),!0}static#z(e,t,r,i){const s=r.required&&V.nil(i)?r[ne]:i;if(!r.typeCheck(s))throw new TypeError(`${e} record has invalid value for field ${r.name}.`);t[r.name]=s}static#A(e,t,r){const i=e[ue],s=t[ae],o=t[he],a=t[de].name,n={[a]:i[a]};return s.forEach((e=>{void 0!==i[e.name]&&(n[e.name]=i[e.name])})),({include:t=[]}={})=>{let i=n;return t.map((e=>{const[t,...r]=e.split(".");return[t,r.join(".")]})).forEach((([t,i])=>{if(n[t])if(Array.isArray(n[t])){const s=r.get(e,t);n[t]=s.map((e=>e.toObject({include:[i]})))}else n[t]=r.get(e,t).toObject({include:[i]});else o.has(t)&&(n[t]=r.get(e,t))})),i}}static#b=(e,t,r,i)=>{let s=r;if("string"===t[le]&&!t.typeCheck(s))throw new TypeError(`${e} record has invalid value for key ${t.name}.`);if("auto"===t[le]&&(s=t[ne]),i.has(s))throw new n(`${e} record with key ${s} already exists.`);return s};#w(){return this.#g.name}#R(){return[...this.#g[ae].keys()]}#F(){return this.#g[me]}#M(e){return this.#g[de].name===e}#v(){return this.#g[de]}#N(e){return e[ue][this.#g[de].name]}#$(e){return this.#g[ae].has(e)}#q(e){return this.#g[ae].get(e)}#S(e,t){return e[ue][t]}#j(e){return this.#g[he].has(e)}#E(e,t){return this.#g[he].get(t)(e[ue])}#T(e){return!!this.#$(e)&&this.#g[ce].has(`${e}.${e}`)}#O(e,t){return this.#g[ce].get(`${t}.${t}`)[ge](this.#w(),t,e[ue])}#V(e){return"toObject"===e||"toJSON"===e}#k(e){return"toString"===e}#x(e){return[pe,fe,ue,ye,de].includes(e)}#C(e,t){return t===ye||(t===de&&this.#v(),e[t])}}const be=we,{$fields:ve,$defaultValue:$e,$key:Me,$keyType:Re,$methods:Fe,$scopes:Te,$relationships:Oe,$validators:Se,$recordHandler:je,$addScope:Ee,$addRelationshipAsField:Ve,$addRelationshipAsMethod:Ae,$getField:ke,$getMethod:Ne,$removeScope:xe,$instances:Ce,$handleExperimentalAPIMessage:qe}=s,ze=[...Object.keys(A),...Object.keys(A).map((e=>`${e}Required`)),"enum","enumRequired","auto"];class Pe extends(i()){#P;#h;#K;#I;#H;#D;#s;#_=!1;static#J=new Map;constructor({name:e,fields:t=[],key:r="id",methods:i={},scopes:s={},validators:o={}}={}){if(super(),this.name=m("Model",e),Pe.#J.has(e))throw new n(`A model named ${e} already exists.`);this.#P=new ie,this.#h=new be(this),this.#I=Pe.#U(this.name,r),this.#K=new Map,this.#H=new Map,this.#D=new Map,this.#s=new Map,t.forEach((e=>this.addField(e))),Object.entries(i).forEach((([e,t])=>{this.addMethod(e,t)})),Object.entries(s).forEach((([e,t])=>{this.addScope(e,t)})),Object.entries(o).forEach((([e,t])=>{this.addValidator(e,t)})),Pe.#J.set(this.name,this)}addField(e,t){this.#_||this.emit("beforeAddField",{field:e,model:this});const r=Pe.#L(this.name,e,[...this.#K.keys(),this.#I.name,...this.#H.keys()]);return this.#K.set(e.name,r),this.#_||this.emit("fieldAdded",{field:r,model:this}),this.emit("beforeRetrofillField",{field:r,retrofill:t,model:this}),Pe.#B(r,this.#P,t),this.emit("fieldRetrofilled",{field:r,retrofill:t,model:this}),this.#_||this.emit("change",{type:"fieldAdded",field:r,model:this}),r}removeField(e){if(!Pe.#f(this.name,"Field",e,this.#K))return!1;const t=this.#K.get(e);return this.#_||this.emit("beforeRemoveField",{field:t,model:this}),this.#K.delete(e),this.#_||(this.emit("fieldRemoved",{field:{name:e},model:this}),this.emit("change",{type:"fieldRemoved",field:t,model:this})),!0}updateField(e,t,r){if(t.name!==e)throw new o(`Field name ${t.name} does not match ${e}.`);if(!Pe.#f(this.name,"Field",e,this.#K))throw new ReferenceError(`Field ${e} does not exist.`);const i=this.#K.get(e);this.#_=!0,this.emit("beforeUpdateField",{prevField:i,field:t,model:this}),this.removeField(e);const s=this.addField(t,r);this.emit("fieldUpdated",{field:s,model:this}),this.#_=!1,this.emit("change",{type:"fieldUpdated",field:s,model:this})}addMethod(e,t){this.emit("beforeAddMethod",{method:{name:e,body:t},model:this});const r=m("Method",e);this.#H.set(r,Pe.#p("Method",e,t,[...this.#K.keys(),this.#I.name,...this.#H.keys()])),this.emit("methodAdded",{method:{name:r,body:t},model:this}),this.emit("change",{type:"methodAdded",method:{name:r,body:t},model:this})}removeMethod(e){if(!Pe.#f(this.name,"Method",e,this.#H))return!1;const t=this.#H.get(e);return this.emit("beforeRemoveMethod",{method:{name:e,body:t},model:this}),this.#H.delete(e),this.emit("methodRemoved",{method:{name:e},model:this}),this.emit("change",{type:"methodRemoved",method:{name:e,body:t},model:this}),!0}addScope(e,t){this.emit("beforeAddScope",{scope:{name:e,body:t},model:this});const r=m("Scope",e);this.#P[Ee](r,t),this.emit("scopeAdded",{scope:{name:r,body:t},model:this}),this.emit("change",{type:"scopeAdded",scope:{name:r,body:t},model:this})}removeScope(e){if(!Pe.#f(this.name,"Scope",e,this.#P[Te]))return!1;const t=this.#P[Te].get(e);return this.emit("beforeRemoveScope",{scope:{name:e,body:t},model:this}),this.#P[xe](e),this.emit("scopeRemoved",{scope:{name:e},model:this}),this.emit("change",{type:"scopeRemoved",scope:{name:e,body:t},model:this}),!0}addValidator(e,t){this.emit("beforeAddValidator",{validator:{name:e,body:t},model:this}),this.#s.set(e,Pe.#p("Validator",e,t,[...this.#s.keys()])),this.emit("validatorAdded",{validator:{name:e,body:t},model:this}),this.emit("change",{type:"validatorAdded",validator:{name:e,body:t},model:this})}removeValidator(e){if(!Pe.#f(this.name,"Validator",e,this.#s))return!1;const t=this.#s.get(e);return this.emit("beforeRemoveValidator",{validator:{name:e,body:t},model:this}),this.#s.delete(e),this.emit("validatorRemoved",{validator:{name:e},model:this}),this.emit("change",{type:"validatorRemoved",validator:{name:e,body:t},model:this}),!0}createRecord(e){this.emit("beforeCreateRecord",{record:e,model:this});const[t,r]=this.#h.createRecord(e);return this.#P.set(t,r),this.emit("recordCreated",{newRecord:r,model:this}),r}removeRecord(e){if(!this.#P.has(e))return console.warn(`Record ${e} does not exist.`),!1;const t=this.#P.get(e);return this.emit("beforeRemoveRecord",{record:t,model:this}),this.#P.delete(e),this.emit("recordRemoved",{record:{[this.#I.name]:e},model:this}),!0}updateRecord(e,t){if("object"!=typeof t)throw new TypeError("Record data must be an object.");if(!this.#P.has(e))throw new ReferenceError(`Record ${e} does not exist.`);const r=this.#P.get(e);return this.emit("beforeUpdateRecord",{record:r,newRecord:{[this.#I.name]:e,...t},model:this}),Object.entries(t).forEach((([e,t])=>{r[e]=t})),this.emit("recordUpdated",{record:r,model:this}),r}get records(){return this.#P}static get[Ce](){return Pe.#J}get[je](){return this.#h}get[ve](){return this.#K}get[Me](){return this.#I}get[Fe](){return this.#H}get[Oe](){return this.#D}get[Se](){return this.#s}[Ve](e){const{name:t,type:r,fieldName:i,field:s}=e[ke](),a=`${t}.${i}`;if(this.emit("beforeAddRelationship",{relationship:{name:t,type:r},model:this}),[...this.#K.keys(),this.#I.name,...this.#H.keys()].includes(i))throw new o(`Relationship field ${i} is already in use.`);if(this.#D.has(a))throw new o(`Relationship ${a} is already in use.`);this.#K.set(i,s),this.#D.set(a,e),this.emit("relationshipAdded",{relationship:{name:t,type:r},model:this}),this.emit("change",{type:"relationshipAdded",relationship:{relationship:{name:t,type:r},model:this},model:this})}[Ae](e){const{name:t,type:r,methodName:i,method:s}=e[Ne](),a=`${t}.${i}`;if(this.emit("beforeAddRelationship",{relationship:{name:t,type:r},model:this}),[...this.#K.keys(),this.#I.name,...this.#H.keys()].includes(i))throw new o(`Relationship method ${i} is already in use.`);if(this.#D.has(a))throw new o(`Relationship ${t} is already in use.`);this.#H.set(i,s),this.#D.set(a,e),this.emit("relationshipAdded",{relationship:{name:t,type:r},model:this}),this.emit("change",{type:"relationshipAdded",relationship:{relationship:{name:t,type:r},model:this},model:this})}static#G(e){let t,r="id",i="string";return"string"==typeof e?r=e:"object"==typeof e&&(r=e.name||r,i=e.type||i),"string"===i?(t=new C({name:r,type:k,required:!0,defaultValue:"__emptyKey__"}),Object.defineProperty(t,$e,{get(){throw new d(`Key field ${r} does not have a default value.`)}})):"auto"===i&&(t=C.auto(r)),Object.defineProperty(t,Re,{get:()=>i}),t}static#U(e,t){if("string"!=typeof t&&"object"!=typeof t)throw new TypeError(`${e} key ${t} is not a string or object.`);if("object"==typeof t&&!t.name)throw new TypeError(`${e} key ${t} is missing a name.`);if("object"==typeof t&&!["auto","string"].includes(t.type))throw new TypeError(`${e} key ${t} type must be either "string" or "auto".`);return Pe.#G(t)}static#L(e,t,r){return y({objectType:"Field",parentType:"Model",parentName:e},t,r),ze.includes(t.type)?C[t.type](t):("function"==typeof t.type&&tt[qe](`The provided type for ${t.name} is not part of the standard types. Function types are experimental and may go away in a later release.`),new C(t))}static#p(e,t,r,i){if("function"!=typeof r)throw new TypeError(`${e} ${t} is not a function.`);if(i.includes(t))throw new n(`${e} ${t} already exists.`);return r}static#f(e,t,r,i){return!!i.has(r)||(console.warn(`Model ${e} does not contain a ${t.toLowerCase()} named ${r}.`),!1)}static#B(e,t,r){if(!e.required&&void 0===r)return;const i=void 0!==r?"function"==typeof r?r:()=>r:t=>t[e.name]?t[e.name]:e[$e];t.forEach((t=>{t[e.name]=i(t)}))}}const{$key:Ke,$recordValue:Ie,$fields:He,$getField:De,$getMethod:_e,$get:Je,$defaultValue:Ue,$instances:Le,$handleExperimentalAPIMessage:Be}=s,Ge={oneToOne:"oneToOne",oneToMany:"oneToMany",manyToOne:"manyToOne",manyToMany:"manyToMany"};class Qe{#i;#Q;#W;#e;#X;#Y;#Z;constructor({from:e,to:t,type:r}={}){tt[Be]("Relationships are experimental in the current version. There is neither validation of existence in foreign tables nor guarantee that associations work. Please use with caution."),this.#i=Qe.#a(r);const[i,s,o,a]=Qe.#ee(e,t,r);if(this.#Q=i,this.#W=o,this.#e=s,this.#X=a,this.#W===this.#Q&&Qe.#te(this.#i)&&this.#e===this.#X)throw new RangeError("Relationship cannot be symmetric if the from and to models are the same and no name is provided for either one.");this.#Y=Qe.#re(this.#e,this.#i,this.#W[Ke]),this.#Z=e=>this.#ie(e)}[De](){return{name:this.#e,type:this.#i,fieldName:this.#e,field:this.#Y}}[_e](){return{name:this.#e,type:this.#i,methodName:this.#X,method:this.#Z}}[Je](e,t,r){return e===this.#Q.name&&t===this.#e?this.#se(r):e===this.#W.name&&t===this.#X?(console.warn("Relationship getter called by the receiver model. This might indicate an issue with the library and should be reported."),this.#ie(r)):void 0}#se(e){if(Qe.#oe(this.#i)){const t=e[this.#e];return this.#W.records.get(t)}const t=e[this.#e]||[],r=this.#W[Ke].name;return this.#W.records.where((e=>t.includes(e[r])))}#ie(e){const t=e[this.#W[Ke].name],r=Qe.#oe(this.#i)?e=>e[Ie][this.#e]===t:e=>{const r=e[Ie][this.#e];return![void 0,null].includes(r)&&e[Ie][this.#e].includes(t)};return Qe.#ae(this.#i)?this.#Q.records.find(r):this.#Q.records.where(r)}static#oe(e){return[Ge.oneToOne,Ge.manyToOne].includes(e)}static#ne(e){return[Ge.oneToMany,Ge.manyToMany].includes(e)}static#ae(e){return[Ge.oneToMany,Ge.oneToOne].includes(e)}static#de(e){return[Ge.manyToOne,Ge.manyToMany].includes(e)}static#te(e){return[Ge.oneToOne,Ge.manyToMany].includes(e)}static#re(e,t,r){const i=Qe.#ae(t),s=Qe.#ne(t),o=s?V.arrayOf((e=>r.typeCheck(e))):e=>r.typeCheck(e),a={};i&&!s&&(a.unique=!0),s&&(a.uniqueValues=!0);const n=new C({name:e,type:o,required:!1,defaultValue:s?[]:null,validators:a});return Object.defineProperty(n,Ue,{get(){throw new d("Relationship field does not have a default value.")}}),n}static#a(e){if(!Object.values(Ge).includes(e))throw new TypeError(`Invalid relationship type: ${e}.`);return e}static#le(e){const t="string"==typeof e?e:e.model;if(!Pe[Le].has(t))throw new ReferenceError(`Model ${t} does not exist.`);return Pe[Le].get(t)}static#he(e,t){return Qe.#oe(e)?p(t):Qe.#ne(e)?`${p(t)}Set`:void 0}static#ce=(e,t)=>Qe.#ae(e)?p(t):Qe.#de(e)?`${p(t)}Set`:void 0;static#me(e){const t=Qe.#le(e),r="string"==typeof e?null:m("Field",e.name);if(null!==r&&t[He].has(r))throw new n(`Field ${r} already exists in ${t.name}.`);return[t,r]}static#ee(e,t,r){let i,s,o,a;return[i,s]=Qe.#me(e),[o,a]=Qe.#me(t),null===s&&(s=Qe.#he(r,o.name)),null===a&&(a=Qe.#ce(r,i.name)),[i,s,o,a]}}const{$addRelationshipAsField:We,$addRelationshipAsMethod:Xe,$handleExperimentalAPIMessage:Ye,$key:Ze,$keyType:et}=s;class tt extends(i()){#e;#ue;static defaultConfig={experimentalAPIMessages:"warn"};static config={...tt.defaultConfig};static#pe=new Map;constructor({name:e,models:t=[],config:r={}}={}){super(),this.#e=m("Schema",e),this.#ue=new Map,tt.#fe(r),tt.#pe.set(this.#e,this),t.forEach((e=>this.createModel(e)))}createModel(e){this.emit("beforeCreateModel",{model:e,schema:this});const t=tt.#ye(this.#e,e,this.#ue);return this.#ue.set(t.name,t),t.on("change",(({type:e,...t})=>{this.emit("change",{type:`model${u(e)}`,...t,schema:this})})),this.emit("modelCreated",{model:t,schema:this}),this.emit("change",{type:"modelCreated",model:t,schema:this}),t}getModel(e){return this.#ue.get(e)}removeModel(e){const t=this.getModel(e);if(this.emit("beforeRemoveModel",{model:t,schema:this}),!this.#ue.has(e))throw new ReferenceError(`Model ${e} does not exist in schema ${this.#e}.`);this.#ue.delete(e),this.emit("modelRemoved",{model:{name:e},schema:this}),this.emit("change",{type:"modelRemoved",model:t,schema:this})}createRelationship(e){this.emit("beforeCreateRelationship",{relationship:e,schema:this});const t=tt.#ge(this.#e,e,this.#ue);return this.emit("relationshipCreated",{relationship:t,schema:this}),this.emit("change",{type:"relationshipCreated",relationship:t,schema:this}),t}get name(){return this.#e}get models(){return this.#ue}static create(e){return new tt(e)}static get(e){return tt.#pe.get(e)}get(e){this.emit("beforeGet",{pathName:e,schema:this});const[t,r,...i]=e.split("."),s=this.getModel(t);if(!s)throw new ReferenceError(`Model ${t} does not exist in schema ${this.#e}.`);if(void 0===r)return s;const o=s[Ze][et],a=s.records.get("string"===o?r:Number.parseInt(r));if(!i.length)return a;if(!a)throw new ReferenceError(`Record ${r} does not exist in model ${t}.`);const n=i.reduce(((e,t)=>e[t]),a);return this.emit("got",{pathName:e,result:n,schema:this}),n}static[Ye](e){const{experimentalAPIMessages:t}=tt.config;if("warn"===t)console.warn(e);else if("error"===t)throw new l(e)}static#ye(e,t,r){return y({objectType:"Model",parentType:"Schema",parentName:e},t,[...r.keys()]),new Pe(t)}static#ge(e,t,r){const{from:i,to:s,type:o}=t;[i,s].forEach((e=>{if(!["string","object"].includes(typeof e))throw new TypeError(`Invalid relationship model: ${e}.`)}));const a="string"==typeof i?i:i.model,n="string"==typeof s?s:s.model,d=r.get(a),l=r.get(n);if(!d)throw new ReferenceError(`Model ${a} not found in schema ${e} when attempting to create a relationship.`);if(!l)throw new ReferenceError(`Model ${n} not found in schema ${e} when attempting to create a relationship.`);const h=new Qe({from:i,to:s,type:o});return d[We](h),l[Xe](h),h}static#fe(e={}){e&&["experimentalAPIMessages"].forEach((t=>{void 0!==e[t]&&["warn","error","off"].includes(e[t])&&(tt.config[t]=e[t])}))}}const rt=tt;return t})()}));